"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@juhomat";
exports.ids = ["vendor-chunks/@juhomat"];
exports.modules = {

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/ContentProcessor.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/ContentProcessor.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentProcessor = void 0;\nclass ContentProcessor {\n    /**\n     * Clean and process HTML content for indexing\n     */\n    processContent(content) {\n        // Remove HTML tags\n        let cleaned = content.replace(/<[^>]*>/g, ' ');\n        // Normalize whitespace\n        cleaned = cleaned.replace(/\\s+/g, ' ').trim();\n        // Remove common navigation and footer text\n        cleaned = this.removeNavigation(cleaned);\n        // Remove excessive punctuation\n        cleaned = cleaned.replace(/[.]{3,}/g, '...');\n        cleaned = cleaned.replace(/[-]{3,}/g, '--');\n        return cleaned;\n    }\n    /**\n     * Count words in content\n     */\n    countWords(content) {\n        if (!content || content.trim().length === 0) {\n            return 0;\n        }\n        return content.trim().split(/\\s+/).length;\n    }\n    /**\n     * Extract main content from page (remove navigation, ads, etc.)\n     */\n    extractMainContent(content) {\n        // This is a simplified approach - in production you might use\n        // libraries like readability.js or more sophisticated content extraction\n        // Remove script and style tags completely\n        let cleaned = content.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '');\n        cleaned = cleaned.replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '');\n        // Remove common non-content elements\n        cleaned = cleaned.replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, '');\n        cleaned = cleaned.replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, '');\n        cleaned = cleaned.replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, '');\n        cleaned = cleaned.replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, '');\n        // Look for main content areas\n        const mainContentMatch = cleaned.match(/<main[^>]*>([\\s\\S]*?)<\\/main>/i);\n        if (mainContentMatch) {\n            return this.processContent(mainContentMatch[1]);\n        }\n        const articleMatch = cleaned.match(/<article[^>]*>([\\s\\S]*?)<\\/article>/i);\n        if (articleMatch) {\n            return this.processContent(articleMatch[1]);\n        }\n        return this.processContent(cleaned);\n    }\n    /**\n     * Split content into sentences\n     */\n    splitIntoSentences(content) {\n        // Simple sentence splitting - could be improved with NLP libraries\n        return content\n            .split(/[.!?]+/)\n            .map(sentence => sentence.trim())\n            .filter(sentence => sentence.length > 10); // Filter out very short fragments\n    }\n    /**\n     * Remove common navigation text patterns\n     */\n    removeNavigation(content) {\n        const navigationPatterns = [\n            /home\\s*\\|\\s*about\\s*\\|\\s*contact/gi,\n            /skip\\s+to\\s+main\\s+content/gi,\n            /back\\s+to\\s+top/gi,\n            /follow\\s+us\\s+on/gi,\n            /subscribe\\s+to\\s+our\\s+newsletter/gi,\n            /all\\s+rights\\s+reserved/gi,\n            /copyright\\s+Â©/gi\n        ];\n        let cleaned = content;\n        navigationPatterns.forEach(pattern => {\n            cleaned = cleaned.replace(pattern, ' ');\n        });\n        return cleaned;\n    }\n    /**\n     * Extract keywords from content\n     */\n    extractKeywords(content, maxKeywords = 10) {\n        // Simple keyword extraction - remove common words and get most frequent\n        const commonWords = new Set([\n            'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',\n            'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have',\n            'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should',\n            'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they'\n        ]);\n        const words = content\n            .toLowerCase()\n            .replace(/[^\\w\\s]/g, ' ')\n            .split(/\\s+/)\n            .filter(word => word.length > 3 && !commonWords.has(word));\n        const wordCounts = new Map();\n        words.forEach(word => {\n            wordCounts.set(word, (wordCounts.get(word) || 0) + 1);\n        });\n        return Array.from(wordCounts.entries())\n            .sort((a, b) => b[1] - a[1])\n            .slice(0, maxKeywords)\n            .map(([word]) => word);\n    }\n}\nexports.ContentProcessor = ContentProcessor;\n//# sourceMappingURL=ContentProcessor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2NyYXdsaW5nL0NvbnRlbnRQcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxHQUFHO0FBQzFDLHVDQUF1QyxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9jcmF3bGluZy9Db250ZW50UHJvY2Vzc29yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250ZW50UHJvY2Vzc29yID0gdm9pZCAwO1xuY2xhc3MgQ29udGVudFByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ2xlYW4gYW5kIHByb2Nlc3MgSFRNTCBjb250ZW50IGZvciBpbmRleGluZ1xuICAgICAqL1xuICAgIHByb2Nlc3NDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgLy8gUmVtb3ZlIEhUTUwgdGFnc1xuICAgICAgICBsZXQgY2xlYW5lZCA9IGNvbnRlbnQucmVwbGFjZSgvPFtePl0qPi9nLCAnICcpO1xuICAgICAgICAvLyBOb3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpO1xuICAgICAgICAvLyBSZW1vdmUgY29tbW9uIG5hdmlnYXRpb24gYW5kIGZvb3RlciB0ZXh0XG4gICAgICAgIGNsZWFuZWQgPSB0aGlzLnJlbW92ZU5hdmlnYXRpb24oY2xlYW5lZCk7XG4gICAgICAgIC8vIFJlbW92ZSBleGNlc3NpdmUgcHVuY3R1YXRpb25cbiAgICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvWy5dezMsfS9nLCAnLi4uJyk7XG4gICAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoL1stXXszLH0vZywgJy0tJyk7XG4gICAgICAgIHJldHVybiBjbGVhbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudCB3b3JkcyBpbiBjb250ZW50XG4gICAgICovXG4gICAgY291bnRXb3Jkcyhjb250ZW50KSB7XG4gICAgICAgIGlmICghY29udGVudCB8fCBjb250ZW50LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50LnRyaW0oKS5zcGxpdCgvXFxzKy8pLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBtYWluIGNvbnRlbnQgZnJvbSBwYWdlIChyZW1vdmUgbmF2aWdhdGlvbiwgYWRzLCBldGMuKVxuICAgICAqL1xuICAgIGV4dHJhY3RNYWluQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGFwcHJvYWNoIC0gaW4gcHJvZHVjdGlvbiB5b3UgbWlnaHQgdXNlXG4gICAgICAgIC8vIGxpYnJhcmllcyBsaWtlIHJlYWRhYmlsaXR5LmpzIG9yIG1vcmUgc29waGlzdGljYXRlZCBjb250ZW50IGV4dHJhY3Rpb25cbiAgICAgICAgLy8gUmVtb3ZlIHNjcmlwdCBhbmQgc3R5bGUgdGFncyBjb21wbGV0ZWx5XG4gICAgICAgIGxldCBjbGVhbmVkID0gY29udGVudC5yZXBsYWNlKC88c2NyaXB0W14+XSo+W1xcc1xcU10qPzxcXC9zY3JpcHQ+L2dpLCAnJyk7XG4gICAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoLzxzdHlsZVtePl0qPltcXHNcXFNdKj88XFwvc3R5bGU+L2dpLCAnJyk7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tb24gbm9uLWNvbnRlbnQgZWxlbWVudHNcbiAgICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvPG5hdltePl0qPltcXHNcXFNdKj88XFwvbmF2Pi9naSwgJycpO1xuICAgICAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC88aGVhZGVyW14+XSo+W1xcc1xcU10qPzxcXC9oZWFkZXI+L2dpLCAnJyk7XG4gICAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoLzxmb290ZXJbXj5dKj5bXFxzXFxTXSo/PFxcL2Zvb3Rlcj4vZ2ksICcnKTtcbiAgICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgvPGFzaWRlW14+XSo+W1xcc1xcU10qPzxcXC9hc2lkZT4vZ2ksICcnKTtcbiAgICAgICAgLy8gTG9vayBmb3IgbWFpbiBjb250ZW50IGFyZWFzXG4gICAgICAgIGNvbnN0IG1haW5Db250ZW50TWF0Y2ggPSBjbGVhbmVkLm1hdGNoKC88bWFpbltePl0qPihbXFxzXFxTXSo/KTxcXC9tYWluPi9pKTtcbiAgICAgICAgaWYgKG1haW5Db250ZW50TWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NDb250ZW50KG1haW5Db250ZW50TWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFydGljbGVNYXRjaCA9IGNsZWFuZWQubWF0Y2goLzxhcnRpY2xlW14+XSo+KFtcXHNcXFNdKj8pPFxcL2FydGljbGU+L2kpO1xuICAgICAgICBpZiAoYXJ0aWNsZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQ29udGVudChhcnRpY2xlTWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NDb250ZW50KGNsZWFuZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdCBjb250ZW50IGludG8gc2VudGVuY2VzXG4gICAgICovXG4gICAgc3BsaXRJbnRvU2VudGVuY2VzKGNvbnRlbnQpIHtcbiAgICAgICAgLy8gU2ltcGxlIHNlbnRlbmNlIHNwbGl0dGluZyAtIGNvdWxkIGJlIGltcHJvdmVkIHdpdGggTkxQIGxpYnJhcmllc1xuICAgICAgICByZXR1cm4gY29udGVudFxuICAgICAgICAgICAgLnNwbGl0KC9bLiE/XSsvKVxuICAgICAgICAgICAgLm1hcChzZW50ZW5jZSA9PiBzZW50ZW5jZS50cmltKCkpXG4gICAgICAgICAgICAuZmlsdGVyKHNlbnRlbmNlID0+IHNlbnRlbmNlLmxlbmd0aCA+IDEwKTsgLy8gRmlsdGVyIG91dCB2ZXJ5IHNob3J0IGZyYWdtZW50c1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY29tbW9uIG5hdmlnYXRpb24gdGV4dCBwYXR0ZXJuc1xuICAgICAqL1xuICAgIHJlbW92ZU5hdmlnYXRpb24oY29udGVudCkge1xuICAgICAgICBjb25zdCBuYXZpZ2F0aW9uUGF0dGVybnMgPSBbXG4gICAgICAgICAgICAvaG9tZVxccypcXHxcXHMqYWJvdXRcXHMqXFx8XFxzKmNvbnRhY3QvZ2ksXG4gICAgICAgICAgICAvc2tpcFxccyt0b1xccyttYWluXFxzK2NvbnRlbnQvZ2ksXG4gICAgICAgICAgICAvYmFja1xccyt0b1xccyt0b3AvZ2ksXG4gICAgICAgICAgICAvZm9sbG93XFxzK3VzXFxzK29uL2dpLFxuICAgICAgICAgICAgL3N1YnNjcmliZVxccyt0b1xccytvdXJcXHMrbmV3c2xldHRlci9naSxcbiAgICAgICAgICAgIC9hbGxcXHMrcmlnaHRzXFxzK3Jlc2VydmVkL2dpLFxuICAgICAgICAgICAgL2NvcHlyaWdodFxccyvCqS9naVxuICAgICAgICBdO1xuICAgICAgICBsZXQgY2xlYW5lZCA9IGNvbnRlbnQ7XG4gICAgICAgIG5hdmlnYXRpb25QYXR0ZXJucy5mb3JFYWNoKHBhdHRlcm4gPT4ge1xuICAgICAgICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZShwYXR0ZXJuLCAnICcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsZWFuZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3Qga2V5d29yZHMgZnJvbSBjb250ZW50XG4gICAgICovXG4gICAgZXh0cmFjdEtleXdvcmRzKGNvbnRlbnQsIG1heEtleXdvcmRzID0gMTApIHtcbiAgICAgICAgLy8gU2ltcGxlIGtleXdvcmQgZXh0cmFjdGlvbiAtIHJlbW92ZSBjb21tb24gd29yZHMgYW5kIGdldCBtb3N0IGZyZXF1ZW50XG4gICAgICAgIGNvbnN0IGNvbW1vbldvcmRzID0gbmV3IFNldChbXG4gICAgICAgICAgICAndGhlJywgJ2EnLCAnYW4nLCAnYW5kJywgJ29yJywgJ2J1dCcsICdpbicsICdvbicsICdhdCcsICd0bycsICdmb3InLFxuICAgICAgICAgICAgJ29mJywgJ3dpdGgnLCAnYnknLCAnaXMnLCAnYXJlJywgJ3dhcycsICd3ZXJlJywgJ2JlJywgJ2JlZW4nLCAnaGF2ZScsXG4gICAgICAgICAgICAnaGFzJywgJ2hhZCcsICdkbycsICdkb2VzJywgJ2RpZCcsICd3aWxsJywgJ3dvdWxkJywgJ2NvdWxkJywgJ3Nob3VsZCcsXG4gICAgICAgICAgICAndGhpcycsICd0aGF0JywgJ3RoZXNlJywgJ3Rob3NlJywgJ2knLCAneW91JywgJ2hlJywgJ3NoZScsICdpdCcsICd3ZScsICd0aGV5J1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBjb250ZW50XG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1teXFx3XFxzXS9nLCAnICcpXG4gICAgICAgICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgICAgICAgLmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID4gMyAmJiAhY29tbW9uV29yZHMuaGFzKHdvcmQpKTtcbiAgICAgICAgY29uc3Qgd29yZENvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgd29yZHMuZm9yRWFjaCh3b3JkID0+IHtcbiAgICAgICAgICAgIHdvcmRDb3VudHMuc2V0KHdvcmQsICh3b3JkQ291bnRzLmdldCh3b3JkKSB8fCAwKSArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20od29yZENvdW50cy5lbnRyaWVzKCkpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG4gICAgICAgICAgICAuc2xpY2UoMCwgbWF4S2V5d29yZHMpXG4gICAgICAgICAgICAubWFwKChbd29yZF0pID0+IHdvcmQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udGVudFByb2Nlc3NvciA9IENvbnRlbnRQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250ZW50UHJvY2Vzc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/ContentProcessor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/WebCrawler.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/WebCrawler.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebCrawler = void 0;\nconst ContentProcessor_1 = __webpack_require__(/*! ./ContentProcessor */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/ContentProcessor.js\");\nclass WebCrawler {\n    constructor(scraper) {\n        this.visited = new Set();\n        this.queue = [];\n        this.scraper = scraper;\n        this.contentProcessor = new ContentProcessor_1.ContentProcessor();\n    }\n    async crawlWebsite(startUrl, options = {}) {\n        const { maxPages = 10, maxDepth = 2, includePatterns = [], excludePatterns = [], followExternalLinks = false, delay = 1000 } = options;\n        const results = [];\n        const startDomain = new URL(startUrl).hostname;\n        this.queue.push({ url: startUrl, depth: 0 });\n        this.visited.add(this.normalizeUrl(startUrl));\n        while (this.queue.length > 0 && results.length < maxPages) {\n            const { url, depth } = this.queue.shift();\n            if (depth > maxDepth) {\n                continue;\n            }\n            try {\n                // Add delay between requests\n                if (results.length > 0 && delay > 0) {\n                    await this.sleep(delay);\n                }\n                const startTime = Date.now();\n                const scrapingResult = await this.scraper.scrapePage({\n                    url,\n                    waitFor: 2000,\n                    includeImages: false,\n                    followLinks: true\n                });\n                if (!scrapingResult.success || !scrapingResult.data) {\n                    throw new Error(scrapingResult.error || 'Scraping failed');\n                }\n                const scrapedData = scrapingResult.data;\n                const responseTime = Date.now() - startTime;\n                const processedContent = this.contentProcessor.processContent(scrapedData.content);\n                const wordCount = this.contentProcessor.countWords(processedContent);\n                // Extract and filter links\n                const extractedLinks = this.extractLinks(scrapedData.links || [], startDomain, followExternalLinks);\n                const filteredLinks = this.filterLinks(extractedLinks, includePatterns, excludePatterns);\n                // Add new links to queue\n                for (const link of filteredLinks) {\n                    const normalizedLink = this.normalizeUrl(link);\n                    if (!this.visited.has(normalizedLink) && this.queue.length + results.length < maxPages) {\n                        this.visited.add(normalizedLink);\n                        this.queue.push({ url: link, depth: depth + 1 });\n                    }\n                }\n                results.push({\n                    url,\n                    title: scrapedData.title || 'Untitled',\n                    content: processedContent,\n                    links: filteredLinks,\n                    depth,\n                    timestamp: new Date(),\n                    metadata: {\n                        wordCount,\n                        contentType: 'text/html',\n                        responseTime\n                    }\n                });\n            }\n            catch (error) {\n                console.warn(`Failed to crawl ${url}:`, error);\n                // Continue with next URL instead of failing completely\n            }\n        }\n        return results;\n    }\n    extractLinks(links, baseDomain, followExternalLinks) {\n        return links.filter(link => {\n            try {\n                const url = new URL(link);\n                if (!followExternalLinks && url.hostname !== baseDomain) {\n                    return false;\n                }\n                return url.protocol === 'http:' || url.protocol === 'https:';\n            }\n            catch {\n                return false;\n            }\n        });\n    }\n    filterLinks(links, includePatterns, excludePatterns) {\n        return links.filter(link => {\n            // Check include patterns\n            if (includePatterns.length > 0) {\n                const included = includePatterns.some(pattern => this.matchesPattern(link, pattern));\n                if (!included)\n                    return false;\n            }\n            // Check exclude patterns\n            if (excludePatterns.length > 0) {\n                const excluded = excludePatterns.some(pattern => this.matchesPattern(link, pattern));\n                if (excluded)\n                    return false;\n            }\n            return true;\n        });\n    }\n    matchesPattern(url, pattern) {\n        // Simple pattern matching - convert glob-like patterns to regex\n        const regexPattern = pattern\n            .replace(/\\*\\*/g, '.*') // ** matches any characters\n            .replace(/\\*/g, '[^/]*') // * matches any characters except /\n            .replace(/\\?/g, '.'); // ? matches single character\n        const regex = new RegExp(regexPattern, 'i');\n        return regex.test(url);\n    }\n    normalizeUrl(url) {\n        try {\n            const urlObj = new URL(url);\n            // Remove trailing slash and fragment\n            return urlObj.origin + urlObj.pathname.replace(/\\/$/, '') + urlObj.search;\n        }\n        catch {\n            return url;\n        }\n    }\n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\nexports.WebCrawler = WebCrawler;\n//# sourceMappingURL=WebCrawler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2NyYXdsaW5nL1dlYkNyYXdsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLDJCQUEyQixtQkFBTyxDQUFDLG9JQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxnQkFBZ0IscUhBQXFIO0FBQ3JJO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2QkFBNkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvY3Jhd2xpbmcvV2ViQ3Jhd2xlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViQ3Jhd2xlciA9IHZvaWQgMDtcbmNvbnN0IENvbnRlbnRQcm9jZXNzb3JfMSA9IHJlcXVpcmUoXCIuL0NvbnRlbnRQcm9jZXNzb3JcIik7XG5jbGFzcyBXZWJDcmF3bGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JhcGVyKSB7XG4gICAgICAgIHRoaXMudmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnNjcmFwZXIgPSBzY3JhcGVyO1xuICAgICAgICB0aGlzLmNvbnRlbnRQcm9jZXNzb3IgPSBuZXcgQ29udGVudFByb2Nlc3Nvcl8xLkNvbnRlbnRQcm9jZXNzb3IoKTtcbiAgICB9XG4gICAgYXN5bmMgY3Jhd2xXZWJzaXRlKHN0YXJ0VXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBtYXhQYWdlcyA9IDEwLCBtYXhEZXB0aCA9IDIsIGluY2x1ZGVQYXR0ZXJucyA9IFtdLCBleGNsdWRlUGF0dGVybnMgPSBbXSwgZm9sbG93RXh0ZXJuYWxMaW5rcyA9IGZhbHNlLCBkZWxheSA9IDEwMDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnREb21haW4gPSBuZXcgVVJMKHN0YXJ0VXJsKS5ob3N0bmFtZTtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdXJsOiBzdGFydFVybCwgZGVwdGg6IDAgfSk7XG4gICAgICAgIHRoaXMudmlzaXRlZC5hZGQodGhpcy5ub3JtYWxpemVVcmwoc3RhcnRVcmwpKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoID4gMCAmJiByZXN1bHRzLmxlbmd0aCA8IG1heFBhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgZGVwdGggfSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBkZWxheSBiZXR3ZWVuIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zbGVlcChkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyYXBpbmdSZXN1bHQgPSBhd2FpdCB0aGlzLnNjcmFwZXIuc2NyYXBlUGFnZSh7XG4gICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvcjogMjAwMCxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUltYWdlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZvbGxvd0xpbmtzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY3JhcGluZ1Jlc3VsdC5zdWNjZXNzIHx8ICFzY3JhcGluZ1Jlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzY3JhcGluZ1Jlc3VsdC5lcnJvciB8fCAnU2NyYXBpbmcgZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmFwZWREYXRhID0gc2NyYXBpbmdSZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZENvbnRlbnQgPSB0aGlzLmNvbnRlbnRQcm9jZXNzb3IucHJvY2Vzc0NvbnRlbnQoc2NyYXBlZERhdGEuY29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZENvdW50ID0gdGhpcy5jb250ZW50UHJvY2Vzc29yLmNvdW50V29yZHMocHJvY2Vzc2VkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBhbmQgZmlsdGVyIGxpbmtzXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFjdGVkTGlua3MgPSB0aGlzLmV4dHJhY3RMaW5rcyhzY3JhcGVkRGF0YS5saW5rcyB8fCBbXSwgc3RhcnREb21haW4sIGZvbGxvd0V4dGVybmFsTGlua3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTGlua3MgPSB0aGlzLmZpbHRlckxpbmtzKGV4dHJhY3RlZExpbmtzLCBpbmNsdWRlUGF0dGVybnMsIGV4Y2x1ZGVQYXR0ZXJucyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5ldyBsaW5rcyB0byBxdWV1ZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBmaWx0ZXJlZExpbmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMaW5rID0gdGhpcy5ub3JtYWxpemVVcmwobGluayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy52aXNpdGVkLmhhcyhub3JtYWxpemVkTGluaykgJiYgdGhpcy5xdWV1ZS5sZW5ndGggKyByZXN1bHRzLmxlbmd0aCA8IG1heFBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0ZWQuYWRkKG5vcm1hbGl6ZWRMaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaCh7IHVybDogbGluaywgZGVwdGg6IGRlcHRoICsgMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBzY3JhcGVkRGF0YS50aXRsZSB8fCAnVW50aXRsZWQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBwcm9jZXNzZWRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBsaW5rczogZmlsdGVyZWRMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAndGV4dC9odG1sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGltZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBjcmF3bCAke3VybH06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggbmV4dCBVUkwgaW5zdGVhZCBvZiBmYWlsaW5nIGNvbXBsZXRlbHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgZXh0cmFjdExpbmtzKGxpbmtzLCBiYXNlRG9tYWluLCBmb2xsb3dFeHRlcm5hbExpbmtzKSB7XG4gICAgICAgIHJldHVybiBsaW5rcy5maWx0ZXIobGluayA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobGluayk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb2xsb3dFeHRlcm5hbExpbmtzICYmIHVybC5ob3N0bmFtZSAhPT0gYmFzZURvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1cmwucHJvdG9jb2wgPT09ICdodHRwOicgfHwgdXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaWx0ZXJMaW5rcyhsaW5rcywgaW5jbHVkZVBhdHRlcm5zLCBleGNsdWRlUGF0dGVybnMpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtzLmZpbHRlcihsaW5rID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGluY2x1ZGUgcGF0dGVybnNcbiAgICAgICAgICAgIGlmIChpbmNsdWRlUGF0dGVybnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVkID0gaW5jbHVkZVBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiB0aGlzLm1hdGNoZXNQYXR0ZXJuKGxpbmssIHBhdHRlcm4pKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBleGNsdWRlIHBhdHRlcm5zXG4gICAgICAgICAgICBpZiAoZXhjbHVkZVBhdHRlcm5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGV4Y2x1ZGVQYXR0ZXJucy5zb21lKHBhdHRlcm4gPT4gdGhpcy5tYXRjaGVzUGF0dGVybihsaW5rLCBwYXR0ZXJuKSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1hdGNoZXNQYXR0ZXJuKHVybCwgcGF0dGVybikge1xuICAgICAgICAvLyBTaW1wbGUgcGF0dGVybiBtYXRjaGluZyAtIGNvbnZlcnQgZ2xvYi1saWtlIHBhdHRlcm5zIHRvIHJlZ2V4XG4gICAgICAgIGNvbnN0IHJlZ2V4UGF0dGVybiA9IHBhdHRlcm5cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCpcXCovZywgJy4qJykgLy8gKiogbWF0Y2hlcyBhbnkgY2hhcmFjdGVyc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKi9nLCAnW14vXSonKSAvLyAqIG1hdGNoZXMgYW55IGNoYXJhY3RlcnMgZXhjZXB0IC9cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXD8vZywgJy4nKTsgLy8gPyBtYXRjaGVzIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4UGF0dGVybiwgJ2knKTtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QodXJsKTtcbiAgICB9XG4gICAgbm9ybWFsaXplVXJsKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNsYXNoIGFuZCBmcmFnbWVudFxuICAgICAgICAgICAgcmV0dXJuIHVybE9iai5vcmlnaW4gKyB1cmxPYmoucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sICcnKSArIHVybE9iai5zZWFyY2g7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzbGVlcChtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJDcmF3bGVyID0gV2ViQ3Jhd2xlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkNyYXdsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/WebCrawler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Crawling Adapters Exports\n// Centralized exports for all crawling-related adapters\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentProcessor = exports.WebCrawler = void 0;\nvar WebCrawler_1 = __webpack_require__(/*! ./WebCrawler */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/WebCrawler.js\");\nObject.defineProperty(exports, \"WebCrawler\", ({ enumerable: true, get: function () { return WebCrawler_1.WebCrawler; } }));\nvar ContentProcessor_1 = __webpack_require__(/*! ./ContentProcessor */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/ContentProcessor.js\");\nObject.defineProperty(exports, \"ContentProcessor\", ({ enumerable: true, get: function () { return ContentProcessor_1.ContentProcessor; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2NyYXdsaW5nL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxrQkFBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsd0hBQWM7QUFDekMsOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILHlCQUF5QixtQkFBTyxDQUFDLG9JQUFvQjtBQUNyRCxvREFBbUQsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDMUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2NyYXdsaW5nL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ3Jhd2xpbmcgQWRhcHRlcnMgRXhwb3J0c1xuLy8gQ2VudHJhbGl6ZWQgZXhwb3J0cyBmb3IgYWxsIGNyYXdsaW5nLXJlbGF0ZWQgYWRhcHRlcnNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udGVudFByb2Nlc3NvciA9IGV4cG9ydHMuV2ViQ3Jhd2xlciA9IHZvaWQgMDtcbnZhciBXZWJDcmF3bGVyXzEgPSByZXF1aXJlKFwiLi9XZWJDcmF3bGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2ViQ3Jhd2xlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gV2ViQ3Jhd2xlcl8xLldlYkNyYXdsZXI7IH0gfSk7XG52YXIgQ29udGVudFByb2Nlc3Nvcl8xID0gcmVxdWlyZShcIi4vQ29udGVudFByb2Nlc3NvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnRlbnRQcm9jZXNzb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbnRlbnRQcm9jZXNzb3JfMS5Db250ZW50UHJvY2Vzc29yOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLAdapter.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLAdapter.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// PostgreSQL Database Adapter Implementation\n// Provides PostgreSQL database operations with connection pooling and health monitoring\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PostgreSQLAdapter = void 0;\nconst pg_1 = __webpack_require__(/*! pg */ \"pg\");\nclass PostgreSQLAdapter {\n    constructor(config, logger) {\n        this.pool = null;\n        this.connectionStartTime = 0;\n        this.config = config;\n        this.logger = logger;\n    }\n    /**\n     * Connect to PostgreSQL database\n     */\n    async connect() {\n        try {\n            const poolConfig = {\n                host: this.config.host,\n                port: this.config.port,\n                database: this.config.database,\n                user: this.config.username,\n                password: this.config.password,\n                ssl: this.config.ssl,\n                max: this.config.maxConnections || 20,\n                connectionTimeoutMillis: this.config.connectionTimeout || 30000,\n                idleTimeoutMillis: this.config.idleTimeout || 30000,\n                application_name: 'hexagonal-framework'\n            };\n            this.pool = new pg_1.Pool(poolConfig);\n            this.connectionStartTime = Date.now();\n            // Test connection\n            const client = await this.pool.connect();\n            client.release();\n            this.logger.info('PostgreSQL connection established', {\n                host: this.config.host,\n                port: this.config.port,\n                database: this.config.database\n            });\n        }\n        catch (error) {\n            this.logger.error('Failed to connect to PostgreSQL', {\n                host: this.config.host,\n                port: this.config.port,\n                database: this.config.database,\n                error: error.message\n            });\n            throw error;\n        }\n    }\n    /**\n     * Disconnect from PostgreSQL database\n     */\n    async disconnect() {\n        if (this.pool) {\n            await this.pool.end();\n            this.pool = null;\n            this.logger.info('PostgreSQL connection closed');\n        }\n    }\n    /**\n     * Execute a raw SQL query\n     */\n    async query(sql, params) {\n        if (!this.pool) {\n            throw new Error('Database not connected. Call connect() first.');\n        }\n        try {\n            this.logger.debug('Executing query', { sql, paramCount: params?.length || 0 });\n            const start = Date.now();\n            const result = await this.pool.query(sql, params);\n            const duration = Date.now() - start;\n            this.logger.debug('Query executed successfully', {\n                duration,\n                rowCount: result.rowCount || 0\n            });\n            return {\n                success: true,\n                data: {\n                    rows: result.rows,\n                    rowCount: result.rowCount || 0,\n                    fields: result.fields\n                }\n            };\n        }\n        catch (error) {\n            this.logger.error('Query execution failed', {\n                sql,\n                error: error.message\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Insert a record into a table\n     */\n    async insert(table, data) {\n        const columns = Object.keys(data);\n        const values = Object.values(data);\n        const placeholders = values.map((_, index) => `$${index + 1}`).join(', ');\n        const sql = `\n      INSERT INTO ${table} (${columns.join(', ')})\n      VALUES (${placeholders})\n      RETURNING id\n    `;\n        try {\n            const result = await this.query(sql, values);\n            if (result.success && result.data?.rows.length) {\n                return {\n                    success: true,\n                    data: result.data.rows[0].id\n                };\n            }\n            return {\n                success: false,\n                error: 'Insert operation did not return an ID'\n            };\n        }\n        catch (error) {\n            this.logger.error('Insert operation failed', {\n                table,\n                error: error.message\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Update a record in a table\n     */\n    async update(table, id, data) {\n        const columns = Object.keys(data);\n        const values = Object.values(data);\n        const setClause = columns.map((col, index) => `${col} = $${index + 1}`).join(', ');\n        const sql = `\n      UPDATE ${table}\n      SET ${setClause}\n      WHERE id = $${values.length + 1}\n    `;\n        try {\n            const result = await this.query(sql, [...values, id]);\n            return {\n                success: result.success,\n                data: result.data ? result.data.rowCount > 0 : false,\n                error: result.error\n            };\n        }\n        catch (error) {\n            this.logger.error('Update operation failed', {\n                table,\n                id,\n                error: error.message\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Delete a record from a table\n     */\n    async delete(table, id) {\n        const sql = `DELETE FROM ${table} WHERE id = $1`;\n        try {\n            const result = await this.query(sql, [id]);\n            return {\n                success: result.success,\n                data: result.data ? result.data.rowCount > 0 : false,\n                error: result.error\n            };\n        }\n        catch (error) {\n            this.logger.error('Delete operation failed', {\n                table,\n                id,\n                error: error.message\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Execute operations within a transaction\n     */\n    async transaction(operations) {\n        if (!this.pool) {\n            throw new Error('Database not connected. Call connect() first.');\n        }\n        const client = await this.pool.connect();\n        try {\n            await client.query('BEGIN');\n            this.logger.debug('Transaction started');\n            // Store original pool reference and replace with client for transaction\n            const originalPool = this.pool;\n            this.pool = {\n                query: client.query.bind(client)\n            };\n            await operations();\n            await client.query('COMMIT');\n            this.logger.debug('Transaction committed');\n            // Restore original pool\n            this.pool = originalPool;\n            return { success: true };\n        }\n        catch (error) {\n            await client.query('ROLLBACK');\n            this.logger.error('Transaction rolled back', {\n                error: error.message\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        finally {\n            client.release();\n        }\n    }\n    /**\n     * Check if the database connection is healthy\n     */\n    async isHealthy() {\n        try {\n            if (!this.pool) {\n                return false;\n            }\n            const result = await this.query('SELECT 1 as health_check');\n            return result.success;\n        }\n        catch (error) {\n            this.logger.error('Health check failed', {\n                error: error.message\n            });\n            return false;\n        }\n    }\n    /**\n     * Get connection information\n     */\n    getConnectionInfo() {\n        return {\n            host: this.config.host,\n            port: this.config.port,\n            database: this.config.database,\n            connected: this.pool !== null,\n            activeConnections: this.pool?.totalCount || 0,\n            maxConnections: this.config.maxConnections || 20,\n            uptime: this.connectionStartTime ? Date.now() - this.connectionStartTime : 0\n        };\n    }\n    /**\n     * Get service name for health checks\n     */\n    getServiceName() {\n        return `PostgreSQL Database (${this.config.host}:${this.config.port}/${this.config.database})`;\n    }\n    /**\n     * Create a table if it doesn't exist\n     */\n    async createTable(tableName, schema) {\n        const sql = `CREATE TABLE IF NOT EXISTS ${tableName} (${schema})`;\n        try {\n            const result = await this.query(sql);\n            if (result.success) {\n                this.logger.info('Table created or already exists', { tableName });\n            }\n            return {\n                success: result.success,\n                data: result.success,\n                error: result.error\n            };\n        }\n        catch (error) {\n            this.logger.error('Create table failed', {\n                tableName,\n                error: error.message\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Check if a table exists\n     */\n    async tableExists(tableName) {\n        const sql = `\n      SELECT EXISTS (\n        SELECT FROM information_schema.tables \n        WHERE table_schema = 'public' \n        AND table_name = $1\n      )\n    `;\n        try {\n            const result = await this.query(sql, [tableName]);\n            return result.success && result.data?.rows[0]?.exists || false;\n        }\n        catch (error) {\n            this.logger.error('Table existence check failed', {\n                tableName,\n                error: error.message\n            });\n            return false;\n        }\n    }\n    /**\n     * Execute a batch of queries\n     */\n    async batch(queries) {\n        const results = [];\n        try {\n            const transactionResult = await this.transaction(async () => {\n                for (const queryDef of queries) {\n                    const result = await this.query(queryDef.sql, queryDef.params);\n                    if (!result.success) {\n                        throw new Error(`Batch query failed: ${result.error}`);\n                    }\n                    if (result.data) {\n                        results.push(result.data);\n                    }\n                }\n            });\n            if (!transactionResult.success) {\n                return {\n                    success: false,\n                    error: transactionResult.error\n                };\n            }\n            return {\n                success: true,\n                data: results\n            };\n        }\n        catch (error) {\n            this.logger.error('Batch execution failed', {\n                queryCount: queries.length,\n                error: error.message\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n}\nexports.PostgreSQLAdapter = PostgreSQLAdapter;\n//# sourceMappingURL=PostgreSQLAdapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2RhdGFiYXNlL1Bvc3RncmVTUUxBZGFwdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGNBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQ0FBc0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0Esb0JBQW9CLE9BQU8sR0FBRyxtQkFBbUI7QUFDakQsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEtBQUssS0FBSyxVQUFVO0FBQzdFO0FBQ0EsZUFBZTtBQUNmLFlBQVk7QUFDWixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLHFCQUFxQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVcsR0FBRyxPQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxXQUFXO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsYUFBYTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvZGF0YWJhc2UvUG9zdGdyZVNRTEFkYXB0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBQb3N0Z3JlU1FMIERhdGFiYXNlIEFkYXB0ZXIgSW1wbGVtZW50YXRpb25cbi8vIFByb3ZpZGVzIFBvc3RncmVTUUwgZGF0YWJhc2Ugb3BlcmF0aW9ucyB3aXRoIGNvbm5lY3Rpb24gcG9vbGluZyBhbmQgaGVhbHRoIG1vbml0b3Jpbmdcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9zdGdyZVNRTEFkYXB0ZXIgPSB2b2lkIDA7XG5jb25zdCBwZ18xID0gcmVxdWlyZShcInBnXCIpO1xuY2xhc3MgUG9zdGdyZVNRTEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMucG9vbCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byBQb3N0Z3JlU1FMIGRhdGFiYXNlXG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBvb2xDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgaG9zdDogdGhpcy5jb25maWcuaG9zdCxcbiAgICAgICAgICAgICAgICBwb3J0OiB0aGlzLmNvbmZpZy5wb3J0LFxuICAgICAgICAgICAgICAgIGRhdGFiYXNlOiB0aGlzLmNvbmZpZy5kYXRhYmFzZSxcbiAgICAgICAgICAgICAgICB1c2VyOiB0aGlzLmNvbmZpZy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogdGhpcy5jb25maWcucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgc3NsOiB0aGlzLmNvbmZpZy5zc2wsXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5tYXhDb25uZWN0aW9ucyB8fCAyMCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dE1pbGxpczogdGhpcy5jb25maWcuY29ubmVjdGlvblRpbWVvdXQgfHwgMzAwMDAsXG4gICAgICAgICAgICAgICAgaWRsZVRpbWVvdXRNaWxsaXM6IHRoaXMuY29uZmlnLmlkbGVUaW1lb3V0IHx8IDMwMDAwLFxuICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uX25hbWU6ICdoZXhhZ29uYWwtZnJhbWV3b3JrJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucG9vbCA9IG5ldyBwZ18xLlBvb2wocG9vbENvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgLy8gVGVzdCBjb25uZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLnBvb2wuY29ubmVjdCgpO1xuICAgICAgICAgICAgY2xpZW50LnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1Bvc3RncmVTUUwgY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcsIHtcbiAgICAgICAgICAgICAgICBob3N0OiB0aGlzLmNvbmZpZy5ob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IHRoaXMuY29uZmlnLnBvcnQsXG4gICAgICAgICAgICAgICAgZGF0YWJhc2U6IHRoaXMuY29uZmlnLmRhdGFiYXNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byBQb3N0Z3JlU1FMJywge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29uZmlnLmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogdGhpcy5jb25maWcucG9ydCxcbiAgICAgICAgICAgICAgICBkYXRhYmFzZTogdGhpcy5jb25maWcuZGF0YWJhc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIFBvc3RncmVTUUwgZGF0YWJhc2VcbiAgICAgKi9cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5wb29sKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBvb2wuZW5kKCk7XG4gICAgICAgICAgICB0aGlzLnBvb2wgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnUG9zdGdyZVNRTCBjb25uZWN0aW9uIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSByYXcgU1FMIHF1ZXJ5XG4gICAgICovXG4gICAgYXN5bmMgcXVlcnkoc3FsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2Ugbm90IGNvbm5lY3RlZC4gQ2FsbCBjb25uZWN0KCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdFeGVjdXRpbmcgcXVlcnknLCB7IHNxbCwgcGFyYW1Db3VudDogcGFyYW1zPy5sZW5ndGggfHwgMCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucG9vbC5xdWVyeShzcWwsIHBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdRdWVyeSBleGVjdXRlZCBzdWNjZXNzZnVsbHknLCB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJlc3VsdC5yb3dDb3VudCB8fCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3M6IHJlc3VsdC5yb3dzLFxuICAgICAgICAgICAgICAgICAgICByb3dDb3VudDogcmVzdWx0LnJvd0NvdW50IHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkczogcmVzdWx0LmZpZWxkc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignUXVlcnkgZXhlY3V0aW9uIGZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICBzcWwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSByZWNvcmQgaW50byBhIHRhYmxlXG4gICAgICovXG4gICAgYXN5bmMgaW5zZXJ0KHRhYmxlLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0gdmFsdWVzLm1hcCgoXywgaW5kZXgpID0+IGAkJHtpbmRleCArIDF9YCkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3Qgc3FsID0gYFxuICAgICAgSU5TRVJUIElOVE8gJHt0YWJsZX0gKCR7Y29sdW1ucy5qb2luKCcsICcpfSlcbiAgICAgIFZBTFVFUyAoJHtwbGFjZWhvbGRlcnN9KVxuICAgICAgUkVUVVJOSU5HIGlkXG4gICAgYDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnkoc3FsLCB2YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhPy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLnJvd3NbMF0uaWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0luc2VydCBvcGVyYXRpb24gZGlkIG5vdCByZXR1cm4gYW4gSUQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0luc2VydCBvcGVyYXRpb24gZmFpbGVkJywge1xuICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgcmVjb3JkIGluIGEgdGFibGVcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUodGFibGUsIGlkLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhkYXRhKTtcbiAgICAgICAgY29uc3Qgc2V0Q2xhdXNlID0gY29sdW1ucy5tYXAoKGNvbCwgaW5kZXgpID0+IGAke2NvbH0gPSAkJHtpbmRleCArIDF9YCkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3Qgc3FsID0gYFxuICAgICAgVVBEQVRFICR7dGFibGV9XG4gICAgICBTRVQgJHtzZXRDbGF1c2V9XG4gICAgICBXSEVSRSBpZCA9ICQke3ZhbHVlcy5sZW5ndGggKyAxfVxuICAgIGA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5KHNxbCwgWy4uLnZhbHVlcywgaWRdKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEgPyByZXN1bHQuZGF0YS5yb3dDb3VudCA+IDAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1VwZGF0ZSBvcGVyYXRpb24gZmFpbGVkJywge1xuICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcmVjb3JkIGZyb20gYSB0YWJsZVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZSh0YWJsZSwgaWQpIHtcbiAgICAgICAgY29uc3Qgc3FsID0gYERFTEVURSBGUk9NICR7dGFibGV9IFdIRVJFIGlkID0gJDFgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeShzcWwsIFtpZF0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSA/IHJlc3VsdC5kYXRhLnJvd0NvdW50ID4gMCA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRGVsZXRlIG9wZXJhdGlvbiBmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIG9wZXJhdGlvbnMgd2l0aGluIGEgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyB0cmFuc2FjdGlvbihvcGVyYXRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5wb29sKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBjb25uZWN0ZWQuIENhbGwgY29ubmVjdCgpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMucG9vbC5jb25uZWN0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucXVlcnkoJ0JFR0lOJyk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnVHJhbnNhY3Rpb24gc3RhcnRlZCcpO1xuICAgICAgICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgcG9vbCByZWZlcmVuY2UgYW5kIHJlcGxhY2Ugd2l0aCBjbGllbnQgZm9yIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFBvb2wgPSB0aGlzLnBvb2w7XG4gICAgICAgICAgICB0aGlzLnBvb2wgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGNsaWVudC5xdWVyeS5iaW5kKGNsaWVudClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBvcGVyYXRpb25zKCk7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucXVlcnkoJ0NPTU1JVCcpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1RyYW5zYWN0aW9uIGNvbW1pdHRlZCcpO1xuICAgICAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBwb29sXG4gICAgICAgICAgICB0aGlzLnBvb2wgPSBvcmlnaW5hbFBvb2w7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucXVlcnkoJ1JPTExCQUNLJyk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignVHJhbnNhY3Rpb24gcm9sbGVkIGJhY2snLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsaWVudC5yZWxlYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeVxuICAgICAqL1xuICAgIGFzeW5jIGlzSGVhbHRoeSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wb29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeSgnU0VMRUNUIDEgYXMgaGVhbHRoX2NoZWNrJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignSGVhbHRoIGNoZWNrIGZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGNvbm5lY3Rpb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRDb25uZWN0aW9uSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29uZmlnLmhvc3QsXG4gICAgICAgICAgICBwb3J0OiB0aGlzLmNvbmZpZy5wb3J0LFxuICAgICAgICAgICAgZGF0YWJhc2U6IHRoaXMuY29uZmlnLmRhdGFiYXNlLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB0aGlzLnBvb2wgIT09IG51bGwsXG4gICAgICAgICAgICBhY3RpdmVDb25uZWN0aW9uczogdGhpcy5wb29sPy50b3RhbENvdW50IHx8IDAsXG4gICAgICAgICAgICBtYXhDb25uZWN0aW9uczogdGhpcy5jb25maWcubWF4Q29ubmVjdGlvbnMgfHwgMjAsXG4gICAgICAgICAgICB1cHRpbWU6IHRoaXMuY29ubmVjdGlvblN0YXJ0VGltZSA/IERhdGUubm93KCkgLSB0aGlzLmNvbm5lY3Rpb25TdGFydFRpbWUgOiAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZXJ2aWNlIG5hbWUgZm9yIGhlYWx0aCBjaGVja3NcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGBQb3N0Z3JlU1FMIERhdGFiYXNlICgke3RoaXMuY29uZmlnLmhvc3R9OiR7dGhpcy5jb25maWcucG9ydH0vJHt0aGlzLmNvbmZpZy5kYXRhYmFzZX0pYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRhYmxlKHRhYmxlTmFtZSwgc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHNxbCA9IGBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAke3RhYmxlTmFtZX0gKCR7c2NoZW1hfSlgO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeShzcWwpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnVGFibGUgY3JlYXRlZCBvciBhbHJlYWR5IGV4aXN0cycsIHsgdGFibGVOYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuc3VjY2VzcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0NyZWF0ZSB0YWJsZSBmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB0YWJsZSBleGlzdHNcbiAgICAgKi9cbiAgICBhc3luYyB0YWJsZUV4aXN0cyh0YWJsZU5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3FsID0gYFxuICAgICAgU0VMRUNUIEVYSVNUUyAoXG4gICAgICAgIFNFTEVDVCBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgXG4gICAgICAgIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICdwdWJsaWMnIFxuICAgICAgICBBTkQgdGFibGVfbmFtZSA9ICQxXG4gICAgICApXG4gICAgYDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnkoc3FsLCBbdGFibGVOYW1lXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGE/LnJvd3NbMF0/LmV4aXN0cyB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdUYWJsZSBleGlzdGVuY2UgY2hlY2sgZmFpbGVkJywge1xuICAgICAgICAgICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIGJhdGNoIG9mIHF1ZXJpZXNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaChxdWVyaWVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVzdWx0ID0gYXdhaXQgdGhpcy50cmFuc2FjdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBxdWVyeURlZiBvZiBxdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnkocXVlcnlEZWYuc3FsLCBxdWVyeURlZi5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhdGNoIHF1ZXJ5IGZhaWxlZDogJHtyZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRyYW5zYWN0aW9uUmVzdWx0LmVycm9yXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0JhdGNoIGV4ZWN1dGlvbiBmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgcXVlcnlDb3VudDogcXVlcmllcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUG9zdGdyZVNRTEFkYXB0ZXIgPSBQb3N0Z3JlU1FMQWRhcHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVTUUxBZGFwdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLAdapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLServiceFactory.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLServiceFactory.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// PostgreSQL Service Factory\n// Creates PostgreSQL database adapter instances following the factory pattern\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PostgreSQLServiceFactory = void 0;\nconst PostgreSQLAdapter_1 = __webpack_require__(/*! ./PostgreSQLAdapter */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLAdapter.js\");\nclass PostgreSQLServiceFactory {\n    /**\n     * Create PostgreSQL adapter instance\n     * @param config - Framework configuration\n     * @param logger - Logger instance\n     * @returns PostgreSQL adapter instance\n     */\n    create(config, logger) {\n        const databaseConfig = this.buildDatabaseConfig(config);\n        logger.info('Creating PostgreSQL adapter', {\n            host: databaseConfig.host,\n            port: databaseConfig.port,\n            database: databaseConfig.database\n        });\n        return new PostgreSQLAdapter_1.PostgreSQLAdapter(databaseConfig, logger);\n    }\n    /**\n     * Get service name for registration\n     * @returns Service name\n     */\n    getServiceName() {\n        return 'databaseAdapter';\n    }\n    /**\n     * Build database configuration from framework config\n     * @param config - Framework configuration\n     * @returns Database configuration\n     */\n    buildDatabaseConfig(config) {\n        // First try to get from environment variables\n        const envConfig = this.getConfigFromEnvironment();\n        if (envConfig) {\n            return envConfig;\n        }\n        // Fallback to framework config if available\n        if (config.services.database) {\n            return {\n                host: config.services.database.host || 'localhost',\n                port: config.services.database.port || 5432,\n                database: config.services.database.database || 'postgres',\n                username: config.services.database.username || 'postgres',\n                password: config.services.database.password || '',\n                ssl: config.services.database.ssl || false,\n                maxConnections: config.services.database.maxConnections || 20,\n                connectionTimeout: config.services.database.connectionTimeout || 30000,\n                idleTimeout: config.services.database.idleTimeout || 30000\n            };\n        }\n        // Default configuration\n        return {\n            host: 'localhost',\n            port: 5432,\n            database: 'postgres',\n            username: 'postgres',\n            password: '',\n            ssl: false,\n            maxConnections: 20,\n            connectionTimeout: 30000,\n            idleTimeout: 30000\n        };\n    }\n    /**\n     * Get database configuration from environment variables\n     * @returns Database configuration or null if not available\n     */\n    getConfigFromEnvironment() {\n        const requiredEnvVars = ['DB_HOST', 'DB_PORT', 'DB_NAME', 'DB_USERNAME', 'DB_PASSWORD'];\n        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n        if (missingVars.length > 0) {\n            return null;\n        }\n        return {\n            host: process.env.DB_HOST,\n            port: parseInt(process.env.DB_PORT),\n            database: process.env.DB_NAME,\n            username: process.env.DB_USERNAME,\n            password: process.env.DB_PASSWORD,\n            ssl: process.env.DB_SSL === 'true',\n            maxConnections: process.env.DB_MAX_CONNECTIONS ? parseInt(process.env.DB_MAX_CONNECTIONS) : 20,\n            connectionTimeout: process.env.DB_CONNECTION_TIMEOUT ? parseInt(process.env.DB_CONNECTION_TIMEOUT) : 30000,\n            idleTimeout: process.env.DB_IDLE_TIMEOUT ? parseInt(process.env.DB_IDLE_TIMEOUT) : 30000\n        };\n    }\n}\nexports.PostgreSQLServiceFactory = PostgreSQLServiceFactory;\n//# sourceMappingURL=PostgreSQLServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2RhdGFiYXNlL1Bvc3RncmVTUUxTZXJ2aWNlRmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLDRCQUE0QixtQkFBTyxDQUFDLHNJQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvZGF0YWJhc2UvUG9zdGdyZVNRTFNlcnZpY2VGYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gUG9zdGdyZVNRTCBTZXJ2aWNlIEZhY3Rvcnlcbi8vIENyZWF0ZXMgUG9zdGdyZVNRTCBkYXRhYmFzZSBhZGFwdGVyIGluc3RhbmNlcyBmb2xsb3dpbmcgdGhlIGZhY3RvcnkgcGF0dGVyblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb3N0Z3JlU1FMU2VydmljZUZhY3RvcnkgPSB2b2lkIDA7XG5jb25zdCBQb3N0Z3JlU1FMQWRhcHRlcl8xID0gcmVxdWlyZShcIi4vUG9zdGdyZVNRTEFkYXB0ZXJcIik7XG5jbGFzcyBQb3N0Z3JlU1FMU2VydmljZUZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBQb3N0Z3JlU1FMIGFkYXB0ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gRnJhbWV3b3JrIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gbG9nZ2VyIC0gTG9nZ2VyIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgUG9zdGdyZVNRTCBhZGFwdGVyIGluc3RhbmNlXG4gICAgICovXG4gICAgY3JlYXRlKGNvbmZpZywgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlQ29uZmlnID0gdGhpcy5idWlsZERhdGFiYXNlQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdDcmVhdGluZyBQb3N0Z3JlU1FMIGFkYXB0ZXInLCB7XG4gICAgICAgICAgICBob3N0OiBkYXRhYmFzZUNvbmZpZy5ob3N0LFxuICAgICAgICAgICAgcG9ydDogZGF0YWJhc2VDb25maWcucG9ydCxcbiAgICAgICAgICAgIGRhdGFiYXNlOiBkYXRhYmFzZUNvbmZpZy5kYXRhYmFzZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3JlU1FMQWRhcHRlcl8xLlBvc3RncmVTUUxBZGFwdGVyKGRhdGFiYXNlQ29uZmlnLCBsb2dnZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2VydmljZSBuYW1lIGZvciByZWdpc3RyYXRpb25cbiAgICAgKiBAcmV0dXJucyBTZXJ2aWNlIG5hbWVcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdkYXRhYmFzZUFkYXB0ZXInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCBkYXRhYmFzZSBjb25maWd1cmF0aW9uIGZyb20gZnJhbWV3b3JrIGNvbmZpZ1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBGcmFtZXdvcmsgY29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIERhdGFiYXNlIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBidWlsZERhdGFiYXNlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICAgIGNvbnN0IGVudkNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnRnJvbUVudmlyb25tZW50KCk7XG4gICAgICAgIGlmIChlbnZDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnZDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZnJhbWV3b3JrIGNvbmZpZyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNvbmZpZy5zZXJ2aWNlcy5kYXRhYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0OiBjb25maWcuc2VydmljZXMuZGF0YWJhc2UuaG9zdCB8fCAnbG9jYWxob3N0JyxcbiAgICAgICAgICAgICAgICBwb3J0OiBjb25maWcuc2VydmljZXMuZGF0YWJhc2UucG9ydCB8fCA1NDMyLFxuICAgICAgICAgICAgICAgIGRhdGFiYXNlOiBjb25maWcuc2VydmljZXMuZGF0YWJhc2UuZGF0YWJhc2UgfHwgJ3Bvc3RncmVzJyxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogY29uZmlnLnNlcnZpY2VzLmRhdGFiYXNlLnVzZXJuYW1lIHx8ICdwb3N0Z3JlcycsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5zZXJ2aWNlcy5kYXRhYmFzZS5wYXNzd29yZCB8fCAnJyxcbiAgICAgICAgICAgICAgICBzc2w6IGNvbmZpZy5zZXJ2aWNlcy5kYXRhYmFzZS5zc2wgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IGNvbmZpZy5zZXJ2aWNlcy5kYXRhYmFzZS5tYXhDb25uZWN0aW9ucyB8fCAyMCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogY29uZmlnLnNlcnZpY2VzLmRhdGFiYXNlLmNvbm5lY3Rpb25UaW1lb3V0IHx8IDMwMDAwLFxuICAgICAgICAgICAgICAgIGlkbGVUaW1lb3V0OiBjb25maWcuc2VydmljZXMuZGF0YWJhc2UuaWRsZVRpbWVvdXQgfHwgMzAwMDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBob3N0OiAnbG9jYWxob3N0JyxcbiAgICAgICAgICAgIHBvcnQ6IDU0MzIsXG4gICAgICAgICAgICBkYXRhYmFzZTogJ3Bvc3RncmVzJyxcbiAgICAgICAgICAgIHVzZXJuYW1lOiAncG9zdGdyZXMnLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICcnLFxuICAgICAgICAgICAgc3NsOiBmYWxzZSxcbiAgICAgICAgICAgIG1heENvbm5lY3Rpb25zOiAyMCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiAzMDAwMCxcbiAgICAgICAgICAgIGlkbGVUaW1lb3V0OiAzMDAwMFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YWJhc2UgY29uZmlndXJhdGlvbiBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEByZXR1cm5zIERhdGFiYXNlIGNvbmZpZ3VyYXRpb24gb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZ2V0Q29uZmlnRnJvbUVudmlyb25tZW50KCkge1xuICAgICAgICBjb25zdCByZXF1aXJlZEVudlZhcnMgPSBbJ0RCX0hPU1QnLCAnREJfUE9SVCcsICdEQl9OQU1FJywgJ0RCX1VTRVJOQU1FJywgJ0RCX1BBU1NXT1JEJ107XG4gICAgICAgIGNvbnN0IG1pc3NpbmdWYXJzID0gcmVxdWlyZWRFbnZWYXJzLmZpbHRlcih2YXJOYW1lID0+ICFwcm9jZXNzLmVudlt2YXJOYW1lXSk7XG4gICAgICAgIGlmIChtaXNzaW5nVmFycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdDogcHJvY2Vzcy5lbnYuREJfSE9TVCxcbiAgICAgICAgICAgIHBvcnQ6IHBhcnNlSW50KHByb2Nlc3MuZW52LkRCX1BPUlQpLFxuICAgICAgICAgICAgZGF0YWJhc2U6IHByb2Nlc3MuZW52LkRCX05BTUUsXG4gICAgICAgICAgICB1c2VybmFtZTogcHJvY2Vzcy5lbnYuREJfVVNFUk5BTUUsXG4gICAgICAgICAgICBwYXNzd29yZDogcHJvY2Vzcy5lbnYuREJfUEFTU1dPUkQsXG4gICAgICAgICAgICBzc2w6IHByb2Nlc3MuZW52LkRCX1NTTCA9PT0gJ3RydWUnLFxuICAgICAgICAgICAgbWF4Q29ubmVjdGlvbnM6IHByb2Nlc3MuZW52LkRCX01BWF9DT05ORUNUSU9OUyA/IHBhcnNlSW50KHByb2Nlc3MuZW52LkRCX01BWF9DT05ORUNUSU9OUykgOiAyMCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiBwcm9jZXNzLmVudi5EQl9DT05ORUNUSU9OX1RJTUVPVVQgPyBwYXJzZUludChwcm9jZXNzLmVudi5EQl9DT05ORUNUSU9OX1RJTUVPVVQpIDogMzAwMDAsXG4gICAgICAgICAgICBpZGxlVGltZW91dDogcHJvY2Vzcy5lbnYuREJfSURMRV9USU1FT1VUID8gcGFyc2VJbnQocHJvY2Vzcy5lbnYuREJfSURMRV9USU1FT1VUKSA6IDMwMDAwXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Qb3N0Z3JlU1FMU2VydmljZUZhY3RvcnkgPSBQb3N0Z3JlU1FMU2VydmljZUZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3N0Z3JlU1FMU2VydmljZUZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Database Adapters Index\n// Exports all database adapter components\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PostgreSQLServiceFactory = exports.PostgreSQLAdapter = void 0;\nvar PostgreSQLAdapter_1 = __webpack_require__(/*! ./PostgreSQLAdapter */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLAdapter.js\");\nObject.defineProperty(exports, \"PostgreSQLAdapter\", ({ enumerable: true, get: function () { return PostgreSQLAdapter_1.PostgreSQLAdapter; } }));\nvar PostgreSQLServiceFactory_1 = __webpack_require__(/*! ./PostgreSQLServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/PostgreSQLServiceFactory.js\");\nObject.defineProperty(exports, \"PostgreSQLServiceFactory\", ({ enumerable: true, get: function () { return PostgreSQLServiceFactory_1.PostgreSQLServiceFactory; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2RhdGFiYXNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyx5QkFBeUI7QUFDNUQsMEJBQTBCLG1CQUFPLENBQUMsc0lBQXFCO0FBQ3ZELHFEQUFvRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUM3SSxpQ0FBaUMsbUJBQU8sQ0FBQyxvSkFBNEI7QUFDckUsNERBQTJELEVBQUUscUNBQXFDLCtEQUErRCxFQUFDO0FBQ2xLIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9kYXRhYmFzZS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIERhdGFiYXNlIEFkYXB0ZXJzIEluZGV4XG4vLyBFeHBvcnRzIGFsbCBkYXRhYmFzZSBhZGFwdGVyIGNvbXBvbmVudHNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9zdGdyZVNRTFNlcnZpY2VGYWN0b3J5ID0gZXhwb3J0cy5Qb3N0Z3JlU1FMQWRhcHRlciA9IHZvaWQgMDtcbnZhciBQb3N0Z3JlU1FMQWRhcHRlcl8xID0gcmVxdWlyZShcIi4vUG9zdGdyZVNRTEFkYXB0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQb3N0Z3JlU1FMQWRhcHRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUG9zdGdyZVNRTEFkYXB0ZXJfMS5Qb3N0Z3JlU1FMQWRhcHRlcjsgfSB9KTtcbnZhciBQb3N0Z3JlU1FMU2VydmljZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL1Bvc3RncmVTUUxTZXJ2aWNlRmFjdG9yeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBvc3RncmVTUUxTZXJ2aWNlRmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUG9zdGdyZVNRTFNlcnZpY2VGYWN0b3J5XzEuUG9zdGdyZVNRTFNlcnZpY2VGYWN0b3J5OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/EmbeddingServiceFactory.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/EmbeddingServiceFactory.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Embedding Service Factory\n// Creates embedding generator instances following the factory pattern\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmbeddingServiceFactory = void 0;\nconst OpenAIEmbeddingGenerator_1 = __webpack_require__(/*! ./OpenAIEmbeddingGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/OpenAIEmbeddingGenerator.js\");\nclass EmbeddingServiceFactory {\n    /**\n     * Create embedding generator instance\n     * @param config - Framework configuration\n     * @param logger - Logger instance\n     * @returns Embedding generator instance\n     */\n    create(config, logger) {\n        const openaiConfig = this.buildOpenAIConfig(config);\n        logger.info('Creating OpenAI Embedding Generator', {\n            embeddingModel: openaiConfig.embeddingModel,\n            organization: openaiConfig.organization ? 'configured' : 'none'\n        });\n        return new OpenAIEmbeddingGenerator_1.OpenAIEmbeddingGenerator(openaiConfig, logger);\n    }\n    /**\n     * Get service name for registration\n     * @returns Service name\n     */\n    getServiceName() {\n        return 'embeddingGenerator';\n    }\n    /**\n     * Build OpenAI configuration from framework config\n     * @param config - Framework configuration\n     * @returns OpenAI configuration\n     */\n    buildOpenAIConfig(config) {\n        // First try to get from environment variables\n        const envConfig = this.getConfigFromEnvironment();\n        if (envConfig) {\n            return envConfig;\n        }\n        // Fallback to framework config if available\n        if (config.services.openai) {\n            return {\n                apiKey: config.services.openai.apiKey,\n                organization: config.services.openai.organization,\n                model: config.services.openai.model,\n                embeddingModel: config.services.openai.embeddingModel,\n                baseUrl: config.services.openai.baseUrl\n            };\n        }\n        // Default configuration - requires API key from environment\n        const apiKey = process.env.OPENAI_API_KEY;\n        if (!apiKey) {\n            throw new Error('OpenAI API key is required. Set OPENAI_API_KEY environment variable or configure in framework config.');\n        }\n        return {\n            apiKey,\n            organization: process.env.OPENAI_ORGANIZATION,\n            embeddingModel: process.env.OPENAI_EMBEDDING_MODEL || 'text-embedding-3-small',\n            baseUrl: process.env.OPENAI_BASE_URL || 'https://api.openai.com/v1'\n        };\n    }\n    /**\n     * Get OpenAI configuration from environment variables\n     * @returns OpenAI configuration or null if not available\n     */\n    getConfigFromEnvironment() {\n        const apiKey = process.env.OPENAI_API_KEY;\n        if (!apiKey) {\n            return null;\n        }\n        return {\n            apiKey,\n            organization: process.env.OPENAI_ORGANIZATION,\n            embeddingModel: process.env.OPENAI_EMBEDDING_MODEL || 'text-embedding-3-small',\n            baseUrl: process.env.OPENAI_BASE_URL || 'https://api.openai.com/v1'\n        };\n    }\n}\nexports.EmbeddingServiceFactory = EmbeddingServiceFactory;\n//# sourceMappingURL=EmbeddingServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2VtYmVkZGluZ3MvRW1iZWRkaW5nU2VydmljZUZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQjtBQUMvQixtQ0FBbUMsbUJBQU8sQ0FBQyxzSkFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2VtYmVkZGluZ3MvRW1iZWRkaW5nU2VydmljZUZhY3RvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFbWJlZGRpbmcgU2VydmljZSBGYWN0b3J5XG4vLyBDcmVhdGVzIGVtYmVkZGluZyBnZW5lcmF0b3IgaW5zdGFuY2VzIGZvbGxvd2luZyB0aGUgZmFjdG9yeSBwYXR0ZXJuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVtYmVkZGluZ1NlcnZpY2VGYWN0b3J5ID0gdm9pZCAwO1xuY29uc3QgT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9PcGVuQUlFbWJlZGRpbmdHZW5lcmF0b3JcIik7XG5jbGFzcyBFbWJlZGRpbmdTZXJ2aWNlRmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGVtYmVkZGluZyBnZW5lcmF0b3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gRnJhbWV3b3JrIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0gbG9nZ2VyIC0gTG9nZ2VyIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgRW1iZWRkaW5nIGdlbmVyYXRvciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNyZWF0ZShjb25maWcsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBvcGVuYWlDb25maWcgPSB0aGlzLmJ1aWxkT3BlbkFJQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdDcmVhdGluZyBPcGVuQUkgRW1iZWRkaW5nIEdlbmVyYXRvcicsIHtcbiAgICAgICAgICAgIGVtYmVkZGluZ01vZGVsOiBvcGVuYWlDb25maWcuZW1iZWRkaW5nTW9kZWwsXG4gICAgICAgICAgICBvcmdhbml6YXRpb246IG9wZW5haUNvbmZpZy5vcmdhbml6YXRpb24gPyAnY29uZmlndXJlZCcgOiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yXzEuT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yKG9wZW5haUNvbmZpZywgbG9nZ2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlcnZpY2UgbmFtZSBmb3IgcmVnaXN0cmF0aW9uXG4gICAgICogQHJldHVybnMgU2VydmljZSBuYW1lXG4gICAgICovXG4gICAgZ2V0U2VydmljZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnZW1iZWRkaW5nR2VuZXJhdG9yJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgT3BlbkFJIGNvbmZpZ3VyYXRpb24gZnJvbSBmcmFtZXdvcmsgY29uZmlnXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEZyYW1ld29yayBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgT3BlbkFJIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBidWlsZE9wZW5BSUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAgICBjb25zdCBlbnZDb25maWcgPSB0aGlzLmdldENvbmZpZ0Zyb21FbnZpcm9ubWVudCgpO1xuICAgICAgICBpZiAoZW52Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gZW52Q29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGZyYW1ld29yayBjb25maWcgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChjb25maWcuc2VydmljZXMub3BlbmFpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFwaUtleTogY29uZmlnLnNlcnZpY2VzLm9wZW5haS5hcGlLZXksXG4gICAgICAgICAgICAgICAgb3JnYW5pemF0aW9uOiBjb25maWcuc2VydmljZXMub3BlbmFpLm9yZ2FuaXphdGlvbixcbiAgICAgICAgICAgICAgICBtb2RlbDogY29uZmlnLnNlcnZpY2VzLm9wZW5haS5tb2RlbCxcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmdNb2RlbDogY29uZmlnLnNlcnZpY2VzLm9wZW5haS5lbWJlZGRpbmdNb2RlbCxcbiAgICAgICAgICAgICAgICBiYXNlVXJsOiBjb25maWcuc2VydmljZXMub3BlbmFpLmJhc2VVcmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uIC0gcmVxdWlyZXMgQVBJIGtleSBmcm9tIGVudmlyb25tZW50XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZO1xuICAgICAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgQVBJIGtleSBpcyByZXF1aXJlZC4gU2V0IE9QRU5BSV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIGNvbmZpZ3VyZSBpbiBmcmFtZXdvcmsgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICBvcmdhbml6YXRpb246IHByb2Nlc3MuZW52Lk9QRU5BSV9PUkdBTklaQVRJT04sXG4gICAgICAgICAgICBlbWJlZGRpbmdNb2RlbDogcHJvY2Vzcy5lbnYuT1BFTkFJX0VNQkVERElOR19NT0RFTCB8fCAndGV4dC1lbWJlZGRpbmctMy1zbWFsbCcsXG4gICAgICAgICAgICBiYXNlVXJsOiBwcm9jZXNzLmVudi5PUEVOQUlfQkFTRV9VUkwgfHwgJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEnXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBPcGVuQUkgY29uZmlndXJhdGlvbiBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEByZXR1cm5zIE9wZW5BSSBjb25maWd1cmF0aW9uIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGdldENvbmZpZ0Zyb21FbnZpcm9ubWVudCgpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVk7XG4gICAgICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uOiBwcm9jZXNzLmVudi5PUEVOQUlfT1JHQU5JWkFUSU9OLFxuICAgICAgICAgICAgZW1iZWRkaW5nTW9kZWw6IHByb2Nlc3MuZW52Lk9QRU5BSV9FTUJFRERJTkdfTU9ERUwgfHwgJ3RleHQtZW1iZWRkaW5nLTMtc21hbGwnLFxuICAgICAgICAgICAgYmFzZVVybDogcHJvY2Vzcy5lbnYuT1BFTkFJX0JBU0VfVVJMIHx8ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxJ1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRW1iZWRkaW5nU2VydmljZUZhY3RvcnkgPSBFbWJlZGRpbmdTZXJ2aWNlRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtYmVkZGluZ1NlcnZpY2VGYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/EmbeddingServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/OpenAIEmbeddingGenerator.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/OpenAIEmbeddingGenerator.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// OpenAI Embedding Generator Implementation\n// Provides text-to-vector conversion using OpenAI's embedding models\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OpenAIEmbeddingGenerator = void 0;\nclass OpenAIEmbeddingGenerator {\n    constructor(config, logger) {\n        this.usageStats = {\n            totalRequests: 0,\n            totalTokens: 0,\n            totalEmbeddings: 0,\n            totalProcessingTime: 0\n        };\n        // Rate limiting\n        this.requestQueue = [];\n        this.isProcessingQueue = false;\n        this.lastRequestTime = 0;\n        this.minRequestInterval = 50; // ms between requests\n        this.config = config;\n        this.logger = logger;\n        this.defaultModel = config.embeddingModel || 'text-embedding-3-small';\n        this.baseUrl = config.baseUrl || 'https://api.openai.com/v1';\n        this.logger.info('OpenAI Embedding Generator initialized', {\n            defaultModel: this.defaultModel,\n            organization: config.organization ? 'configured' : 'none'\n        });\n    }\n    /**\n     * Generate embeddings for text(s)\n     */\n    async generateEmbeddings(request) {\n        const startTime = Date.now();\n        try {\n            const texts = Array.isArray(request.text) ? request.text : [request.text];\n            const model = request.model || this.defaultModel;\n            this.logger.debug('Generating embeddings', {\n                textCount: texts.length,\n                model,\n                dimensions: request.dimensions\n            });\n            // Validate inputs\n            if (texts.length === 0) {\n                return {\n                    success: false,\n                    error: 'No text provided for embedding generation'\n                };\n            }\n            const tooLongTexts = texts.filter(text => this.estimateTokens(text) > 8000);\n            if (tooLongTexts.length > 0) {\n                return {\n                    success: false,\n                    error: `Text too long: ${tooLongTexts.length} texts exceed token limit`\n                };\n            }\n            // Process with rate limiting\n            const response = await this.queueRequest(async () => {\n                const params = {\n                    input: texts,\n                    model,\n                    encoding_format: 'float'\n                };\n                if (request.dimensions) {\n                    params.dimensions = request.dimensions;\n                }\n                return await this.callOpenAIEmbeddingAPI(params);\n            });\n            const processingTime = Date.now() - startTime;\n            // Extract embeddings\n            const embeddings = response.data.map((item) => item.embedding);\n            // Update usage stats\n            this.usageStats.totalRequests++;\n            this.usageStats.totalTokens += response.usage?.total_tokens || 0;\n            this.usageStats.totalEmbeddings += embeddings.length;\n            this.usageStats.totalProcessingTime += processingTime;\n            this.logger.debug('Embeddings generated successfully', {\n                embeddingCount: embeddings.length,\n                dimensions: embeddings[0]?.length || 0,\n                tokensUsed: response.usage?.total_tokens || 0,\n                processingTime\n            });\n            return {\n                success: true,\n                data: {\n                    embeddings,\n                    model: response.model,\n                    usage: {\n                        promptTokens: response.usage?.prompt_tokens || 0,\n                        totalTokens: response.usage?.total_tokens || 0\n                    },\n                    metadata: {\n                        dimensions: embeddings[0]?.length || 0,\n                        processingTime,\n                        batchSize: embeddings.length\n                    }\n                }\n            };\n        }\n        catch (error) {\n            const processingTime = Date.now() - startTime;\n            this.logger.error('Embedding generation failed', {\n                error: error.message,\n                processingTime\n            });\n            return {\n                success: false,\n                error: `Embedding generation failed: ${error.message}`\n            };\n        }\n    }\n    /**\n     * Generate embedding for a single text\n     */\n    async generateEmbedding(text, model) {\n        const result = await this.generateEmbeddings({\n            text: [text],\n            model\n        });\n        if (!result.success) {\n            return {\n                success: false,\n                error: result.error\n            };\n        }\n        return {\n            success: true,\n            data: result.data.embeddings[0]\n        };\n    }\n    /**\n     * Generate embeddings for multiple texts in batch\n     */\n    async generateBatchEmbeddings(texts, model, batchSize = 100) {\n        try {\n            if (texts.length === 0) {\n                return {\n                    success: true,\n                    data: []\n                };\n            }\n            // Process in batches to respect API limits\n            const allEmbeddings = [];\n            for (let i = 0; i < texts.length; i += batchSize) {\n                const batch = texts.slice(i, i + batchSize);\n                this.logger.debug('Processing embedding batch', {\n                    batchIndex: Math.floor(i / batchSize) + 1,\n                    batchSize: batch.length,\n                    totalBatches: Math.ceil(texts.length / batchSize)\n                });\n                const batchResult = await this.generateEmbeddings({\n                    text: batch,\n                    model\n                });\n                if (!batchResult.success) {\n                    return {\n                        success: false,\n                        error: `Batch ${Math.floor(i / batchSize) + 1} failed: ${batchResult.error}`\n                    };\n                }\n                allEmbeddings.push(...batchResult.data.embeddings);\n                // Add delay between batches to respect rate limits\n                if (i + batchSize < texts.length) {\n                    await this.delay(100);\n                }\n            }\n            return {\n                success: true,\n                data: allEmbeddings\n            };\n        }\n        catch (error) {\n            this.logger.error('Batch embedding generation failed', {\n                error: error.message,\n                textCount: texts.length,\n                batchSize\n            });\n            return {\n                success: false,\n                error: `Batch embedding generation failed: ${error.message}`\n            };\n        }\n    }\n    /**\n     * Get available embedding models\n     */\n    getAvailableModels() {\n        return [\n            {\n                name: 'text-embedding-3-small',\n                dimensions: 1536,\n                maxTokens: 8191,\n                costPer1000Tokens: 0.00002,\n                description: 'Most capable small embedding model'\n            },\n            {\n                name: 'text-embedding-3-large',\n                dimensions: 3072,\n                maxTokens: 8191,\n                costPer1000Tokens: 0.00013,\n                description: 'Most capable large embedding model'\n            },\n            {\n                name: 'text-embedding-ada-002',\n                dimensions: 1536,\n                maxTokens: 8191,\n                costPer1000Tokens: 0.0001,\n                description: 'Legacy embedding model'\n            }\n        ];\n    }\n    /**\n     * Get default model name\n     */\n    getDefaultModel() {\n        return this.defaultModel;\n    }\n    /**\n     * Calculate similarity between two embeddings\n     */\n    calculateSimilarity(embedding1, embedding2, method = 'cosine') {\n        if (embedding1.length !== embedding2.length) {\n            throw new Error('Embedding dimensions must match');\n        }\n        switch (method) {\n            case 'cosine':\n                return this.cosineSimilarity(embedding1, embedding2);\n            case 'euclidean':\n                return this.euclideanDistance(embedding1, embedding2);\n            case 'dot':\n                return this.dotProduct(embedding1, embedding2);\n            default:\n                throw new Error(`Unknown similarity method: ${method}`);\n        }\n    }\n    /**\n     * Estimate token count for text\n     */\n    estimateTokens(text) {\n        // Rough estimation: ~4 characters per token for English text\n        return Math.ceil(text.length / 4);\n    }\n    /**\n     * Check if the service is healthy\n     */\n    async isHealthy() {\n        try {\n            const testResult = await this.generateEmbedding('health check');\n            return testResult.success;\n        }\n        catch (error) {\n            this.logger.error('Embedding service health check failed', {\n                error: error.message\n            });\n            return false;\n        }\n    }\n    /**\n     * Get service name for health checks\n     */\n    getServiceName() {\n        return 'OpenAI Embedding Generator';\n    }\n    /**\n     * Get usage statistics\n     */\n    getUsageStats() {\n        return {\n            ...this.usageStats,\n            averageProcessingTime: this.usageStats.totalRequests > 0\n                ? this.usageStats.totalProcessingTime / this.usageStats.totalRequests\n                : 0\n        };\n    }\n    /**\n     * Queue request with rate limiting\n     */\n    async queueRequest(request) {\n        return new Promise((resolve, reject) => {\n            this.requestQueue.push(async () => {\n                try {\n                    const result = await request();\n                    resolve(result);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n            this.processQueue();\n        });\n    }\n    /**\n     * Process request queue with rate limiting\n     */\n    async processQueue() {\n        if (this.isProcessingQueue || this.requestQueue.length === 0) {\n            return;\n        }\n        this.isProcessingQueue = true;\n        while (this.requestQueue.length > 0) {\n            const request = this.requestQueue.shift();\n            // Enforce minimum interval between requests\n            const timeSinceLastRequest = Date.now() - this.lastRequestTime;\n            if (timeSinceLastRequest < this.minRequestInterval) {\n                await this.delay(this.minRequestInterval - timeSinceLastRequest);\n            }\n            this.lastRequestTime = Date.now();\n            await request();\n        }\n        this.isProcessingQueue = false;\n    }\n    /**\n     * Delay utility\n     */\n    delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    /**\n     * Calculate cosine similarity\n     */\n    cosineSimilarity(a, b) {\n        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n        if (magnitudeA === 0 || magnitudeB === 0) {\n            return 0;\n        }\n        return dotProduct / (magnitudeA * magnitudeB);\n    }\n    /**\n     * Calculate euclidean distance\n     */\n    euclideanDistance(a, b) {\n        const squaredDiffs = a.map((val, i) => Math.pow(val - b[i], 2));\n        return Math.sqrt(squaredDiffs.reduce((sum, val) => sum + val, 0));\n    }\n    /**\n     * Calculate dot product\n     */\n    dotProduct(a, b) {\n        return a.reduce((sum, val, i) => sum + val * b[i], 0);\n    }\n    /**\n     * Call OpenAI API for embeddings\n     */\n    async callOpenAIEmbeddingAPI(params) {\n        const response = await fetch(`${this.baseUrl}/embeddings`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(params)\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));\n            throw new Error(`OpenAI API error: ${errorData.error?.message || response.statusText}`);\n        }\n        return await response.json();\n    }\n    /**\n     * Get headers for OpenAI API requests\n     */\n    getHeaders() {\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.config.apiKey}`\n        };\n        if (this.config.organization) {\n            headers['OpenAI-Organization'] = this.config.organization;\n        }\n        return headers;\n    }\n}\nexports.OpenAIEmbeddingGenerator = OpenAIEmbeddingGenerator;\n//# sourceMappingURL=OpenAIEmbeddingGenerator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2VtYmVkZGluZ3MvT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQixVQUFVLGtCQUFrQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtRUFBbUUsU0FBUyxnQ0FBZ0M7QUFDNUcsaURBQWlELGdEQUFnRDtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9lbWJlZGRpbmdzL09wZW5BSUVtYmVkZGluZ0dlbmVyYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIE9wZW5BSSBFbWJlZGRpbmcgR2VuZXJhdG9yIEltcGxlbWVudGF0aW9uXG4vLyBQcm92aWRlcyB0ZXh0LXRvLXZlY3RvciBjb252ZXJzaW9uIHVzaW5nIE9wZW5BSSdzIGVtYmVkZGluZyBtb2RlbHNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yID0gdm9pZCAwO1xuY2xhc3MgT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLnVzYWdlU3RhdHMgPSB7XG4gICAgICAgICAgICB0b3RhbFJlcXVlc3RzOiAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IDAsXG4gICAgICAgICAgICB0b3RhbEVtYmVkZGluZ3M6IDAsXG4gICAgICAgICAgICB0b3RhbFByb2Nlc3NpbmdUaW1lOiAwXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJhdGUgbGltaXRpbmdcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0VGltZSA9IDA7XG4gICAgICAgIHRoaXMubWluUmVxdWVzdEludGVydmFsID0gNTA7IC8vIG1zIGJldHdlZW4gcmVxdWVzdHNcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmRlZmF1bHRNb2RlbCA9IGNvbmZpZy5lbWJlZGRpbmdNb2RlbCB8fCAndGV4dC1lbWJlZGRpbmctMy1zbWFsbCc7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsIHx8ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxJztcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnT3BlbkFJIEVtYmVkZGluZyBHZW5lcmF0b3IgaW5pdGlhbGl6ZWQnLCB7XG4gICAgICAgICAgICBkZWZhdWx0TW9kZWw6IHRoaXMuZGVmYXVsdE1vZGVsLFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uOiBjb25maWcub3JnYW5pemF0aW9uID8gJ2NvbmZpZ3VyZWQnIDogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBlbWJlZGRpbmdzIGZvciB0ZXh0KHMpXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVFbWJlZGRpbmdzKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRzID0gQXJyYXkuaXNBcnJheShyZXF1ZXN0LnRleHQpID8gcmVxdWVzdC50ZXh0IDogW3JlcXVlc3QudGV4dF07XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHJlcXVlc3QubW9kZWwgfHwgdGhpcy5kZWZhdWx0TW9kZWw7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnR2VuZXJhdGluZyBlbWJlZGRpbmdzJywge1xuICAgICAgICAgICAgICAgIHRleHRDb3VudDogdGV4dHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHJlcXVlc3QuZGltZW5zaW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBpbnB1dHNcbiAgICAgICAgICAgIGlmICh0ZXh0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdObyB0ZXh0IHByb3ZpZGVkIGZvciBlbWJlZGRpbmcgZ2VuZXJhdGlvbidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vTG9uZ1RleHRzID0gdGV4dHMuZmlsdGVyKHRleHQgPT4gdGhpcy5lc3RpbWF0ZVRva2Vucyh0ZXh0KSA+IDgwMDApO1xuICAgICAgICAgICAgaWYgKHRvb0xvbmdUZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgVGV4dCB0b28gbG9uZzogJHt0b29Mb25nVGV4dHMubGVuZ3RofSB0ZXh0cyBleGNlZWQgdG9rZW4gbGltaXRgXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3Mgd2l0aCByYXRlIGxpbWl0aW5nXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucXVldWVSZXF1ZXN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0ZXh0cyxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nX2Zvcm1hdDogJ2Zsb2F0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZGltZW5zaW9ucyA9IHJlcXVlc3QuZGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsbE9wZW5BSUVtYmVkZGluZ0FQSShwYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGVtYmVkZGluZ3NcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSByZXNwb25zZS5kYXRhLm1hcCgoaXRlbSkgPT4gaXRlbS5lbWJlZGRpbmcpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHVzYWdlIHN0YXRzXG4gICAgICAgICAgICB0aGlzLnVzYWdlU3RhdHMudG90YWxSZXF1ZXN0cysrO1xuICAgICAgICAgICAgdGhpcy51c2FnZVN0YXRzLnRvdGFsVG9rZW5zICs9IHJlc3BvbnNlLnVzYWdlPy50b3RhbF90b2tlbnMgfHwgMDtcbiAgICAgICAgICAgIHRoaXMudXNhZ2VTdGF0cy50b3RhbEVtYmVkZGluZ3MgKz0gZW1iZWRkaW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnVzYWdlU3RhdHMudG90YWxQcm9jZXNzaW5nVGltZSArPSBwcm9jZXNzaW5nVGltZTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdFbWJlZGRpbmdzIGdlbmVyYXRlZCBzdWNjZXNzZnVsbHknLCB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nQ291bnQ6IGVtYmVkZGluZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IGVtYmVkZGluZ3NbMF0/Lmxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICAgIHRva2Vuc1VzZWQ6IHJlc3BvbnNlLnVzYWdlPy50b3RhbF90b2tlbnMgfHwgMCxcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nVGltZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBlbWJlZGRpbmdzLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogcmVzcG9uc2UubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IHJlc3BvbnNlLnVzYWdlPy5wcm9tcHRfdG9rZW5zIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogcmVzcG9uc2UudXNhZ2U/LnRvdGFsX3Rva2VucyB8fCAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBlbWJlZGRpbmdzWzBdPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBlbWJlZGRpbmdzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NpbmdUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFbWJlZGRpbmcgZ2VuZXJhdGlvbiBmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEVtYmVkZGluZyBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZW1iZWRkaW5nIGZvciBhIHNpbmdsZSB0ZXh0XG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVFbWJlZGRpbmcodGV4dCwgbW9kZWwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUVtYmVkZGluZ3Moe1xuICAgICAgICAgICAgdGV4dDogW3RleHRdLFxuICAgICAgICAgICAgbW9kZWxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLmVtYmVkZGluZ3NbMF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZW1iZWRkaW5ncyBmb3IgbXVsdGlwbGUgdGV4dHMgaW4gYmF0Y2hcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUJhdGNoRW1iZWRkaW5ncyh0ZXh0cywgbW9kZWwsIGJhdGNoU2l6ZSA9IDEwMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRleHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgaW4gYmF0Y2hlcyB0byByZXNwZWN0IEFQSSBsaW1pdHNcbiAgICAgICAgICAgIGNvbnN0IGFsbEVtYmVkZGluZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dHMubGVuZ3RoOyBpICs9IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGV4dHMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1Byb2Nlc3NpbmcgZW1iZWRkaW5nIGJhdGNoJywge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaEluZGV4OiBNYXRoLmZsb29yKGkgLyBiYXRjaFNpemUpICsgMSxcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBiYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQmF0Y2hlczogTWF0aC5jZWlsKHRleHRzLmxlbmd0aCAvIGJhdGNoU2l6ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaFJlc3VsdCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVFbWJlZGRpbmdzKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYmF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXRjaFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQmF0Y2ggJHtNYXRoLmZsb29yKGkgLyBiYXRjaFNpemUpICsgMX0gZmFpbGVkOiAke2JhdGNoUmVzdWx0LmVycm9yfWBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWxsRW1iZWRkaW5ncy5wdXNoKC4uLmJhdGNoUmVzdWx0LmRhdGEuZW1iZWRkaW5ncyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGRlbGF5IGJldHdlZW4gYmF0Y2hlcyB0byByZXNwZWN0IHJhdGUgbGltaXRzXG4gICAgICAgICAgICAgICAgaWYgKGkgKyBiYXRjaFNpemUgPCB0ZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxheSgxMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBhbGxFbWJlZGRpbmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0JhdGNoIGVtYmVkZGluZyBnZW5lcmF0aW9uIGZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0ZXh0Q291bnQ6IHRleHRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBiYXRjaFNpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEJhdGNoIGVtYmVkZGluZyBnZW5lcmF0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGF2YWlsYWJsZSBlbWJlZGRpbmcgbW9kZWxzXG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlTW9kZWxzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0LWVtYmVkZGluZy0zLXNtYWxsJyxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiAxNTM2LFxuICAgICAgICAgICAgICAgIG1heFRva2VuczogODE5MSxcbiAgICAgICAgICAgICAgICBjb3N0UGVyMTAwMFRva2VuczogMC4wMDAwMixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ01vc3QgY2FwYWJsZSBzbWFsbCBlbWJlZGRpbmcgbW9kZWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0LWVtYmVkZGluZy0zLWxhcmdlJyxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiAzMDcyLFxuICAgICAgICAgICAgICAgIG1heFRva2VuczogODE5MSxcbiAgICAgICAgICAgICAgICBjb3N0UGVyMTAwMFRva2VuczogMC4wMDAxMyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ01vc3QgY2FwYWJsZSBsYXJnZSBlbWJlZGRpbmcgbW9kZWwnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXh0LWVtYmVkZGluZy1hZGEtMDAyJyxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiAxNTM2LFxuICAgICAgICAgICAgICAgIG1heFRva2VuczogODE5MSxcbiAgICAgICAgICAgICAgICBjb3N0UGVyMTAwMFRva2VuczogMC4wMDAxLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTGVnYWN5IGVtYmVkZGluZyBtb2RlbCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGRlZmF1bHQgbW9kZWwgbmFtZVxuICAgICAqL1xuICAgIGdldERlZmF1bHRNb2RlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdE1vZGVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc2ltaWxhcml0eSBiZXR3ZWVuIHR3byBlbWJlZGRpbmdzXG4gICAgICovXG4gICAgY2FsY3VsYXRlU2ltaWxhcml0eShlbWJlZGRpbmcxLCBlbWJlZGRpbmcyLCBtZXRob2QgPSAnY29zaW5lJykge1xuICAgICAgICBpZiAoZW1iZWRkaW5nMS5sZW5ndGggIT09IGVtYmVkZGluZzIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtYmVkZGluZyBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnY29zaW5lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb3NpbmVTaW1pbGFyaXR5KGVtYmVkZGluZzEsIGVtYmVkZGluZzIpO1xuICAgICAgICAgICAgY2FzZSAnZXVjbGlkZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldWNsaWRlYW5EaXN0YW5jZShlbWJlZGRpbmcxLCBlbWJlZGRpbmcyKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG90UHJvZHVjdChlbWJlZGRpbmcxLCBlbWJlZGRpbmcyKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpbWlsYXJpdHkgbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RpbWF0ZSB0b2tlbiBjb3VudCBmb3IgdGV4dFxuICAgICAqL1xuICAgIGVzdGltYXRlVG9rZW5zKHRleHQpIHtcbiAgICAgICAgLy8gUm91Z2ggZXN0aW1hdGlvbjogfjQgY2hhcmFjdGVycyBwZXIgdG9rZW4gZm9yIEVuZ2xpc2ggdGV4dFxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRleHQubGVuZ3RoIC8gNCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBzZXJ2aWNlIGlzIGhlYWx0aHlcbiAgICAgKi9cbiAgICBhc3luYyBpc0hlYWx0aHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUVtYmVkZGluZygnaGVhbHRoIGNoZWNrJyk7XG4gICAgICAgICAgICByZXR1cm4gdGVzdFJlc3VsdC5zdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0VtYmVkZGluZyBzZXJ2aWNlIGhlYWx0aCBjaGVjayBmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZXJ2aWNlIG5hbWUgZm9yIGhlYWx0aCBjaGVja3NcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdPcGVuQUkgRW1iZWRkaW5nIEdlbmVyYXRvcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1c2FnZSBzdGF0aXN0aWNzXG4gICAgICovXG4gICAgZ2V0VXNhZ2VTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMudXNhZ2VTdGF0cyxcbiAgICAgICAgICAgIGF2ZXJhZ2VQcm9jZXNzaW5nVGltZTogdGhpcy51c2FnZVN0YXRzLnRvdGFsUmVxdWVzdHMgPiAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLnVzYWdlU3RhdHMudG90YWxQcm9jZXNzaW5nVGltZSAvIHRoaXMudXNhZ2VTdGF0cy50b3RhbFJlcXVlc3RzXG4gICAgICAgICAgICAgICAgOiAwXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXVlIHJlcXVlc3Qgd2l0aCByYXRlIGxpbWl0aW5nXG4gICAgICovXG4gICAgYXN5bmMgcXVldWVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHJlcXVlc3QgcXVldWUgd2l0aCByYXRlIGxpbWl0aW5nXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc1F1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmdRdWV1ZSB8fCB0aGlzLnJlcXVlc3RRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZ1F1ZXVlID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVxdWVzdFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgLy8gRW5mb3JjZSBtaW5pbXVtIGludGVydmFsIGJldHdlZW4gcmVxdWVzdHNcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RSZXF1ZXN0ID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdFJlcXVlc3RUaW1lO1xuICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5taW5SZXF1ZXN0SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGF5KHRoaXMubWluUmVxdWVzdEludGVydmFsIC0gdGltZVNpbmNlTGFzdFJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgYXdhaXQgcmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsYXkgdXRpbGl0eVxuICAgICAqL1xuICAgIGRlbGF5KG1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGNvc2luZSBzaW1pbGFyaXR5XG4gICAgICovXG4gICAgY29zaW5lU2ltaWxhcml0eShhLCBiKSB7XG4gICAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBhLnJlZHVjZSgoc3VtLCB2YWwsIGkpID0+IHN1bSArIHZhbCAqIGJbaV0sIDApO1xuICAgICAgICBjb25zdCBtYWduaXR1ZGVBID0gTWF0aC5zcXJ0KGEucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsICogdmFsLCAwKSk7XG4gICAgICAgIGNvbnN0IG1hZ25pdHVkZUIgPSBNYXRoLnNxcnQoYi5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwgKiB2YWwsIDApKTtcbiAgICAgICAgaWYgKG1hZ25pdHVkZUEgPT09IDAgfHwgbWFnbml0dWRlQiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvdFByb2R1Y3QgLyAobWFnbml0dWRlQSAqIG1hZ25pdHVkZUIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZXVjbGlkZWFuIGRpc3RhbmNlXG4gICAgICovXG4gICAgZXVjbGlkZWFuRGlzdGFuY2UoYSwgYikge1xuICAgICAgICBjb25zdCBzcXVhcmVkRGlmZnMgPSBhLm1hcCgodmFsLCBpKSA9PiBNYXRoLnBvdyh2YWwgLSBiW2ldLCAyKSk7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZERpZmZzLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZG90IHByb2R1Y3RcbiAgICAgKi9cbiAgICBkb3RQcm9kdWN0KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucmVkdWNlKChzdW0sIHZhbCwgaSkgPT4gc3VtICsgdmFsICogYltpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgT3BlbkFJIEFQSSBmb3IgZW1iZWRkaW5nc1xuICAgICAqL1xuICAgIGFzeW5jIGNhbGxPcGVuQUlFbWJlZGRpbmdBUEkocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9lbWJlZGRpbmdzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcmFtcylcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBlcnJvcjogeyBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0IH0gfSkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVuQUkgQVBJIGVycm9yOiAke2Vycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBoZWFkZXJzIGZvciBPcGVuQUkgQVBJIHJlcXVlc3RzXG4gICAgICovXG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb25maWcub3JnYW5pemF0aW9uKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydPcGVuQUktT3JnYW5pemF0aW9uJ10gPSB0aGlzLmNvbmZpZy5vcmdhbml6YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5PcGVuQUlFbWJlZGRpbmdHZW5lcmF0b3IgPSBPcGVuQUlFbWJlZGRpbmdHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcGVuQUlFbWJlZGRpbmdHZW5lcmF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/OpenAIEmbeddingGenerator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Embedding Adapters Index\n// Exports all embedding adapter components\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmbeddingServiceFactory = exports.OpenAIEmbeddingGenerator = void 0;\nvar OpenAIEmbeddingGenerator_1 = __webpack_require__(/*! ./OpenAIEmbeddingGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/OpenAIEmbeddingGenerator.js\");\nObject.defineProperty(exports, \"OpenAIEmbeddingGenerator\", ({ enumerable: true, get: function () { return OpenAIEmbeddingGenerator_1.OpenAIEmbeddingGenerator; } }));\nvar EmbeddingServiceFactory_1 = __webpack_require__(/*! ./EmbeddingServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/EmbeddingServiceFactory.js\");\nObject.defineProperty(exports, \"EmbeddingServiceFactory\", ({ enumerable: true, get: function () { return EmbeddingServiceFactory_1.EmbeddingServiceFactory; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2VtYmVkZGluZ3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLGdDQUFnQztBQUNsRSxpQ0FBaUMsbUJBQU8sQ0FBQyxzSkFBNEI7QUFDckUsNERBQTJELEVBQUUscUNBQXFDLCtEQUErRCxFQUFDO0FBQ2xLLGdDQUFnQyxtQkFBTyxDQUFDLG9KQUEyQjtBQUNuRSwyREFBMEQsRUFBRSxxQ0FBcUMsNkRBQTZELEVBQUM7QUFDL0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2VtYmVkZGluZ3MvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFbWJlZGRpbmcgQWRhcHRlcnMgSW5kZXhcbi8vIEV4cG9ydHMgYWxsIGVtYmVkZGluZyBhZGFwdGVyIGNvbXBvbmVudHNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1iZWRkaW5nU2VydmljZUZhY3RvcnkgPSBleHBvcnRzLk9wZW5BSUVtYmVkZGluZ0dlbmVyYXRvciA9IHZvaWQgMDtcbnZhciBPcGVuQUlFbWJlZGRpbmdHZW5lcmF0b3JfMSA9IHJlcXVpcmUoXCIuL09wZW5BSUVtYmVkZGluZ0dlbmVyYXRvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9wZW5BSUVtYmVkZGluZ0dlbmVyYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yXzEuT3BlbkFJRW1iZWRkaW5nR2VuZXJhdG9yOyB9IH0pO1xudmFyIEVtYmVkZGluZ1NlcnZpY2VGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9FbWJlZGRpbmdTZXJ2aWNlRmFjdG9yeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtYmVkZGluZ1NlcnZpY2VGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFbWJlZGRpbmdTZXJ2aWNlRmFjdG9yeV8xLkVtYmVkZGluZ1NlcnZpY2VGYWN0b3J5OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/index.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Adapters Exports\n// Central exports for all framework adapters organized by category\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// OpenAI Adapters  \n__exportStar(__webpack_require__(/*! ./openai */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/index.js\"), exports);\n// Tavily Adapters\n__exportStar(__webpack_require__(/*! ./tavily */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/index.js\"), exports);\n// Screenshot Adapters\n__exportStar(__webpack_require__(/*! ./screenshot */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/index.js\"), exports);\n// Web Scraping Adapters\n__exportStar(__webpack_require__(/*! ./scraping */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/index.js\"), exports);\n// Crawling Adapters\n__exportStar(__webpack_require__(/*! ./crawling */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/index.js\"), exports);\n// Database Adapters\n__exportStar(__webpack_require__(/*! ./database */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/index.js\"), exports);\n// Embedding Adapters\n__exportStar(__webpack_require__(/*! ./embeddings */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/index.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw2R0FBVTtBQUMvQjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw2R0FBVTtBQUMvQjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxxSEFBYztBQUNuQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpSEFBWTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpSEFBWTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpSEFBWTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxxSEFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsK0dBQVc7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQWRhcHRlcnMgRXhwb3J0c1xuLy8gQ2VudHJhbCBleHBvcnRzIGZvciBhbGwgZnJhbWV3b3JrIGFkYXB0ZXJzIG9yZ2FuaXplZCBieSBjYXRlZ29yeVxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBPcGVuQUkgQWRhcHRlcnMgIFxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29wZW5haVwiKSwgZXhwb3J0cyk7XG4vLyBUYXZpbHkgQWRhcHRlcnNcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90YXZpbHlcIiksIGV4cG9ydHMpO1xuLy8gU2NyZWVuc2hvdCBBZGFwdGVyc1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjcmVlbnNob3RcIiksIGV4cG9ydHMpO1xuLy8gV2ViIFNjcmFwaW5nIEFkYXB0ZXJzXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NyYXBpbmdcIiksIGV4cG9ydHMpO1xuLy8gQ3Jhd2xpbmcgQWRhcHRlcnNcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jcmF3bGluZ1wiKSwgZXhwb3J0cyk7XG4vLyBEYXRhYmFzZSBBZGFwdGVyc1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RhdGFiYXNlXCIpLCBleHBvcnRzKTtcbi8vIEVtYmVkZGluZyBBZGFwdGVyc1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VtYmVkZGluZ3NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N0b3JhZ2VcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/EnhancedOpenAITextGenerator.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/EnhancedOpenAITextGenerator.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Enhanced OpenAI Text Generator with Responses API Support\n// Supports both traditional chat completions and new responses endpoint with conversation continuation\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EnhancedOpenAITextGenerator = void 0;\nconst ErrorTypes_1 = __webpack_require__(/*! ../../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass EnhancedOpenAITextGenerator {\n    constructor(config, logger, errorHandler) {\n        this.conversationSessions = new Map();\n        this.config = config;\n        this.logger = logger.child ? logger.child({ service: 'enhanced-openai-text' }) : logger;\n        this.errorHandler = errorHandler;\n        this.baseUrl = config.baseUrl || 'https://api.openai.com/v1';\n        this.validateConfig();\n    }\n    /**\n     * Generate text with automatic mode detection (traditional or responses API)\n     */\n    async generateText(request) {\n        const enhancedRequest = request;\n        const mode = enhancedRequest.mode || this.determineOptimalMode(enhancedRequest);\n        this.logger.info('Starting enhanced text generation', {\n            model: request.model,\n            mode,\n            hasPreviousResponseId: !!enhancedRequest.previousResponseId\n        });\n        try {\n            let response;\n            if (mode === 'responses') {\n                response = await this.generateWithResponsesAPI(enhancedRequest);\n            }\n            else {\n                response = await this.generateWithChatCompletions(enhancedRequest);\n            }\n            this.logger.info('Enhanced text generation completed', {\n                model: response.model,\n                mode,\n                responseId: response.responseId,\n                tokens: response.usage?.totalTokens\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'enhanced-openai', 'generateText');\n            this.logger.error('Enhanced text generation failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Generate text using the new Responses API\n     */\n    async generateWithResponsesAPI(request) {\n        const payload = this.buildResponsesAPIPayload(request);\n        this.logger.info('Calling OpenAI Responses API', {\n            endpoint: `${this.baseUrl}/responses`,\n            model: payload.model,\n            hasPreviousResponseId: !!payload.previous_response_id,\n            hasTools: !!(payload.tools && payload.tools.length > 0)\n        });\n        const response = await fetch(`${this.baseUrl}/responses`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 60000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        const data = await response.json();\n        return this.transformResponsesAPIResponse(data);\n    }\n    /**\n     * Generate text using traditional Chat Completions API\n     */\n    async generateWithChatCompletions(request) {\n        const payload = this.buildChatCompletionsPayload(request);\n        this.logger.info('Calling OpenAI Chat Completions API', {\n            endpoint: `${this.baseUrl}/chat/completions`,\n            model: payload.model,\n            messagesCount: payload.messages.length\n        });\n        const response = await fetch(`${this.baseUrl}/chat/completions`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 60000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        const data = await response.json();\n        return this.transformChatCompletionsResponse(data);\n    }\n    /**\n     * Stream text with automatic mode detection\n     */\n    async streamText(request, callback) {\n        const enhancedRequest = request;\n        const mode = enhancedRequest.mode || this.determineOptimalMode(enhancedRequest);\n        this.logger.info('Starting enhanced streaming text generation', {\n            model: request.model,\n            mode,\n            hasPreviousResponseId: !!enhancedRequest.previousResponseId\n        });\n        try {\n            let response;\n            if (mode === 'responses') {\n                response = await this.streamResponsesAPI(enhancedRequest, callback);\n            }\n            else {\n                response = await this.streamChatCompletions(enhancedRequest, callback);\n            }\n            this.logger.info('Enhanced streaming text generation completed', {\n                model: response.model,\n                mode,\n                responseId: response.responseId,\n                tokens: response.usage?.totalTokens\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'enhanced-openai', 'streamText');\n            this.logger.error('Enhanced streaming text generation failed', { error: frameworkError.message }, error);\n            callback({\n                type: 'error',\n                error: frameworkError.message\n            });\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Continue conversation with previous response ID\n     */\n    async continueConversation(sessionId, input, options) {\n        const session = this.conversationSessions.get(sessionId);\n        if (!session) {\n            return {\n                success: false,\n                error: `Conversation session '${sessionId}' not found`\n            };\n        }\n        const request = {\n            prompt: input,\n            mode: 'responses',\n            previousResponseId: session.lastResponseId,\n            ...options\n        };\n        const result = await this.generateText(request);\n        if (result.success && result.data) {\n            const response = result.data;\n            if (response.responseId) {\n                session.responseHistory.push(response.responseId);\n                session.lastResponseId = response.responseId;\n                session.updatedAt = new Date();\n            }\n        }\n        return result;\n    }\n    /**\n     * Create a new conversation session\n     */\n    createConversationSession(sessionId) {\n        const id = sessionId || `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        const session = {\n            sessionId: id,\n            responseHistory: [],\n            createdAt: new Date(),\n            updatedAt: new Date()\n        };\n        this.conversationSessions.set(id, session);\n        this.logger.info('Created conversation session', { sessionId: id });\n        return id;\n    }\n    /**\n     * Get conversation session details\n     */\n    getConversationSession(sessionId) {\n        return this.conversationSessions.get(sessionId);\n    }\n    /**\n     * Delete conversation session\n     */\n    deleteConversationSession(sessionId) {\n        const deleted = this.conversationSessions.delete(sessionId);\n        if (deleted) {\n            this.logger.info('Deleted conversation session', { sessionId });\n        }\n        return deleted;\n    }\n    /**\n     * Retrieve a previous response by ID\n     */\n    async retrieveResponse(responseId) {\n        try {\n            const response = await fetch(`${this.baseUrl}/responses/${responseId}`, {\n                method: 'GET',\n                headers: this.getHeaders(),\n                signal: AbortSignal.timeout(this.config.timeout || 30000)\n            });\n            if (!response.ok) {\n                throw await this.handleAPIError(response);\n            }\n            const data = await response.json();\n            return {\n                success: true,\n                data: this.transformResponsesAPIResponse(data)\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'enhanced-openai', 'retrieveResponse');\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    // Legacy interface support\n    async *generateTextStream(request) {\n        const enhancedRequest = request;\n        let fullText = '';\n        let finalResponse = null;\n        const callback = (chunk) => {\n            if (chunk.type === 'data' && chunk.data) {\n                // This will be yielded in the promise resolution\n            }\n            else if (chunk.type === 'end') {\n                // Final chunk\n            }\n            else if (chunk.type === 'error') {\n                throw new Error(chunk.error);\n            }\n        };\n        // This is a simplified implementation for legacy compatibility\n        // For full async generator support, more complex stream handling would be needed\n        const result = await this.streamText(request, callback);\n        if (!result.success) {\n            throw new Error(result.error);\n        }\n        // Yield final response as a single chunk for compatibility\n        const chunk = {\n            text: result.data?.text || '',\n            isComplete: true,\n            usage: result.data?.usage\n        };\n        yield chunk;\n        return result.data;\n    }\n    /**\n     * Health check implementation\n     */\n    async isHealthy() {\n        try {\n            const response = await fetch(`${this.baseUrl}/models`, {\n                method: 'GET',\n                headers: this.getHeaders(),\n                signal: AbortSignal.timeout(5000)\n            });\n            return response.ok;\n        }\n        catch (error) {\n            this.logger.warn('Health check failed', { error: error.message });\n            return false;\n        }\n    }\n    getServiceName() {\n        return 'enhanced-openai-text-generator';\n    }\n    async getAvailableModels() {\n        try {\n            const response = await fetch(`${this.baseUrl}/models`, {\n                method: 'GET',\n                headers: this.getHeaders()\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch models: ${response.statusText}`);\n            }\n            const data = await response.json();\n            return data.data\n                .filter((model) => model.id.startsWith('gpt-') || model.id.startsWith('o'))\n                .map((model) => model.id);\n        }\n        catch (error) {\n            this.logger.error('Failed to get available models', {}, error);\n            throw this.errorHandler.createFrameworkError(error, 'enhanced-openai', 'getAvailableModels');\n        }\n    }\n    // Private helper methods\n    determineOptimalMode(request) {\n        // Use responses API if:\n        // - Previous response ID is provided\n        // - Tools are specified\n        // - Background mode is requested\n        // - Explicitly requested\n        if (request.previousResponseId ||\n            (request.tools && request.tools.length > 0) ||\n            request.background ||\n            request.mode === 'responses') {\n            return 'responses';\n        }\n        return 'chat_completions';\n    }\n    buildResponsesAPIPayload(request) {\n        const model = request.model || this.config.model || 'gpt-4o';\n        const payload = {\n            model,\n            input: this.buildInputForResponsesAPI(request)\n        };\n        if (request.previousResponseId) {\n            payload.previous_response_id = request.previousResponseId;\n        }\n        if (request.instructions) {\n            payload.instructions = request.instructions;\n        }\n        if (request.tools && request.tools.length > 0) {\n            payload.tools = request.tools;\n        }\n        if (request.background) {\n            payload.background = request.background;\n        }\n        if (request.store !== undefined) {\n            payload.store = request.store;\n        }\n        // Handle model-specific parameters\n        if (request.maxTokens) {\n            if (model.startsWith('o3') || model.startsWith('o2') || model.startsWith('o1')) {\n                payload.max_completion_tokens = request.maxTokens;\n            }\n            else {\n                payload.max_output_tokens = request.maxTokens;\n            }\n        }\n        if (request.temperature !== undefined) {\n            if (model.startsWith('o3') || model.startsWith('o2') || model.startsWith('o1')) {\n                if (request.temperature === 1) {\n                    payload.temperature = request.temperature;\n                }\n            }\n            else {\n                payload.temperature = request.temperature;\n            }\n        }\n        return payload;\n    }\n    buildInputForResponsesAPI(request) {\n        // For responses API, input can be a string or message array\n        if (request.conversationHistory && request.conversationHistory.length > 0) {\n            const messages = [];\n            if (request.systemPrompt) {\n                messages.push({\n                    role: 'system',\n                    content: request.systemPrompt\n                });\n            }\n            messages.push(...request.conversationHistory);\n            messages.push({\n                role: 'user',\n                content: request.prompt\n            });\n            return messages;\n        }\n        // Simple string input\n        return request.prompt;\n    }\n    buildChatCompletionsPayload(request) {\n        const messages = [];\n        if (request.systemPrompt) {\n            messages.push({\n                role: 'system',\n                content: request.systemPrompt\n            });\n        }\n        if (request.conversationHistory && request.conversationHistory.length > 0) {\n            messages.push(...request.conversationHistory);\n        }\n        messages.push({\n            role: 'user',\n            content: request.prompt\n        });\n        const model = request.model || this.config.model || 'gpt-3.5-turbo';\n        const payload = {\n            model,\n            messages,\n            stream: false\n        };\n        if (request.maxTokens) {\n            if (model.startsWith('o3') || model.startsWith('o2') || model.startsWith('o1')) {\n                payload.max_completion_tokens = request.maxTokens;\n            }\n            else {\n                payload.max_tokens = request.maxTokens;\n            }\n        }\n        if (request.temperature !== undefined) {\n            if (model.startsWith('o3') || model.startsWith('o2') || model.startsWith('o1')) {\n                if (request.temperature === 1) {\n                    payload.temperature = request.temperature;\n                }\n            }\n            else {\n                payload.temperature = request.temperature;\n            }\n        }\n        return payload;\n    }\n    transformResponsesAPIResponse(data) {\n        const response = {\n            text: data.output_text || this.extractTextFromOutput(data.output),\n            model: data.model,\n            finishReason: data.status,\n            responseId: data.id,\n            status: data.status,\n            output: data.output,\n            usage: data.usage ? {\n                promptTokens: data.usage.input_tokens || data.usage.prompt_tokens || 0,\n                completionTokens: data.usage.output_tokens || data.usage.completion_tokens || 0,\n                totalTokens: data.usage.total_tokens || 0\n            } : undefined\n        };\n        return response;\n    }\n    transformChatCompletionsResponse(data) {\n        return {\n            text: data.choices[0].message.content,\n            model: data.model,\n            finishReason: data.choices[0].finish_reason,\n            usage: data.usage ? {\n                promptTokens: data.usage.prompt_tokens,\n                completionTokens: data.usage.completion_tokens,\n                totalTokens: data.usage.total_tokens\n            } : undefined\n        };\n    }\n    extractTextFromOutput(output) {\n        if (!output || !Array.isArray(output)) {\n            return '';\n        }\n        return output\n            .filter(item => item.type === 'message' && item.role === 'assistant')\n            .map(item => item.content)\n            .flat()\n            .filter(content => content.type === 'output_text')\n            .map(content => content.text)\n            .join('');\n    }\n    async streamResponsesAPI(request, callback) {\n        const payload = this.buildResponsesAPIPayload(request);\n        payload.stream = true;\n        const response = await fetch(`${this.baseUrl}/responses`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 60000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        return this.processResponsesStreamResponse(response, callback);\n    }\n    async streamChatCompletions(request, callback) {\n        const payload = this.buildChatCompletionsPayload(request);\n        payload.stream = true;\n        const response = await fetch(`${this.baseUrl}/chat/completions`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 60000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        return this.processChatCompletionsStreamResponse(response, callback);\n    }\n    async processResponsesStreamResponse(response, callback) {\n        const reader = response.body?.getReader();\n        if (!reader) {\n            throw new Error('No response body reader available');\n        }\n        const decoder = new TextDecoder();\n        let fullText = '';\n        let finalResponse = null;\n        let buffer = '';\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || '';\n                for (const line of lines) {\n                    if (line.trim() && line.startsWith('data: ')) {\n                        const data = line.slice(6).trim();\n                        if (data === '[DONE]') {\n                            callback({ type: 'end' });\n                            break;\n                        }\n                        if (data === '' || data === ':') {\n                            continue;\n                        }\n                        try {\n                            const parsed = JSON.parse(data);\n                            if (parsed.type === 'response.output_text.delta') {\n                                const content = parsed.delta;\n                                if (content) {\n                                    fullText += content;\n                                    callback({\n                                        type: 'data',\n                                        data: {\n                                            text: content,\n                                            isComplete: false\n                                        }\n                                    });\n                                }\n                            }\n                            else if (parsed.type === 'response.done') {\n                                finalResponse = this.transformResponsesAPIResponse(parsed.response);\n                            }\n                        }\n                        catch (parseError) {\n                            this.logger.debug('Skipping malformed JSON chunk in responses stream', { data: data.substring(0, 100) });\n                            continue;\n                        }\n                    }\n                }\n            }\n            if (!finalResponse) {\n                finalResponse = {\n                    text: fullText,\n                    model: this.config.model || 'gpt-4o',\n                    finishReason: 'stop'\n                };\n            }\n            callback({\n                type: 'data',\n                data: {\n                    text: '',\n                    isComplete: true,\n                    usage: finalResponse.usage\n                }\n            });\n            return finalResponse;\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    async processChatCompletionsStreamResponse(response, callback) {\n        const reader = response.body?.getReader();\n        if (!reader) {\n            throw new Error('No response body reader available');\n        }\n        const decoder = new TextDecoder();\n        let fullText = '';\n        let finalResponse = null;\n        let buffer = '';\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                buffer += decoder.decode(value, { stream: true });\n                const lines = buffer.split('\\n');\n                buffer = lines.pop() || '';\n                for (const line of lines) {\n                    if (line.trim() && line.startsWith('data: ')) {\n                        const data = line.slice(6).trim();\n                        if (data === '[DONE]') {\n                            callback({ type: 'end' });\n                            break;\n                        }\n                        if (data === '' || data === ':') {\n                            continue;\n                        }\n                        try {\n                            const parsed = JSON.parse(data);\n                            const content = parsed.choices?.[0]?.delta?.content;\n                            if (content) {\n                                fullText += content;\n                                callback({\n                                    type: 'data',\n                                    data: {\n                                        text: content,\n                                        isComplete: false\n                                    }\n                                });\n                            }\n                            if (parsed.choices?.[0]?.finish_reason) {\n                                finalResponse = {\n                                    text: fullText,\n                                    model: parsed.model,\n                                    finishReason: parsed.choices[0].finish_reason,\n                                    usage: parsed.usage ? {\n                                        promptTokens: parsed.usage.prompt_tokens,\n                                        completionTokens: parsed.usage.completion_tokens,\n                                        totalTokens: parsed.usage.total_tokens\n                                    } : undefined\n                                };\n                            }\n                        }\n                        catch (parseError) {\n                            this.logger.debug('Skipping malformed JSON chunk in chat completions stream', { data: data.substring(0, 100) });\n                            continue;\n                        }\n                    }\n                }\n            }\n            if (!finalResponse) {\n                finalResponse = {\n                    text: fullText,\n                    model: this.config.model || 'gpt-3.5-turbo',\n                    finishReason: 'stop'\n                };\n            }\n            callback({\n                type: 'data',\n                data: {\n                    text: '',\n                    isComplete: true,\n                    usage: finalResponse.usage\n                }\n            });\n            return finalResponse;\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    async handleAPIError(response) {\n        const errorBody = await response.text();\n        switch (response.status) {\n            case 401:\n                return new ErrorTypes_1.AuthenticationError('Invalid OpenAI API key', 'enhanced-openai');\n            case 429:\n                return new ErrorTypes_1.RateLimitError('OpenAI API rate limit exceeded', 'enhanced-openai');\n            case 400:\n                return new ErrorTypes_1.ValidationError(`OpenAI API validation error: ${errorBody}`);\n            default:\n                return new ErrorTypes_1.NetworkError(`OpenAI API error: ${response.status} ${errorBody}`, 'enhanced-openai');\n        }\n    }\n    getHeaders() {\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.config.apiKey}`\n        };\n        if (this.config.organization) {\n            headers['OpenAI-Organization'] = this.config.organization;\n        }\n        return headers;\n    }\n    validateConfig() {\n        if (!this.config.apiKey) {\n            throw new ErrorTypes_1.ValidationError('OpenAI API key is required');\n        }\n    }\n}\nexports.EnhancedOpenAITextGenerator = EnhancedOpenAITextGenerator;\n//# sourceMappingURL=EnhancedOpenAITextGenerator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL29wZW5haS9FbmhhbmNlZE9wZW5BSVRleHRHZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQztBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQyxnSUFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsK0JBQStCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EsU0FBUztBQUNULHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLCtCQUErQjtBQUM1RztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxHQUFHLHdDQUF3QztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxlQUFlO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWEsYUFBYSxXQUFXO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyREFBMkQsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyw4QkFBOEI7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryw4QkFBOEI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixVQUFVO0FBQ2xHO0FBQ0EsMEVBQTBFLGlCQUFpQixFQUFFLFVBQVU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9vcGVuYWkvRW5oYW5jZWRPcGVuQUlUZXh0R2VuZXJhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gRW5oYW5jZWQgT3BlbkFJIFRleHQgR2VuZXJhdG9yIHdpdGggUmVzcG9uc2VzIEFQSSBTdXBwb3J0XG4vLyBTdXBwb3J0cyBib3RoIHRyYWRpdGlvbmFsIGNoYXQgY29tcGxldGlvbnMgYW5kIG5ldyByZXNwb25zZXMgZW5kcG9pbnQgd2l0aCBjb252ZXJzYXRpb24gY29udGludWF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVuaGFuY2VkT3BlbkFJVGV4dEdlbmVyYXRvciA9IHZvaWQgMDtcbmNvbnN0IEVycm9yVHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3R5cGVzL0Vycm9yVHlwZXNcIik7XG5jbGFzcyBFbmhhbmNlZE9wZW5BSVRleHRHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgbG9nZ2VyLCBlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb25TZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLmNoaWxkID8gbG9nZ2VyLmNoaWxkKHsgc2VydmljZTogJ2VuaGFuY2VkLW9wZW5haS10ZXh0JyB9KSA6IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsIHx8ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxJztcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNvbmZpZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0ZXh0IHdpdGggYXV0b21hdGljIG1vZGUgZGV0ZWN0aW9uICh0cmFkaXRpb25hbCBvciByZXNwb25zZXMgQVBJKVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlVGV4dChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGVuaGFuY2VkUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBlbmhhbmNlZFJlcXVlc3QubW9kZSB8fCB0aGlzLmRldGVybWluZU9wdGltYWxNb2RlKGVuaGFuY2VkUmVxdWVzdCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGVuaGFuY2VkIHRleHQgZ2VuZXJhdGlvbicsIHtcbiAgICAgICAgICAgIG1vZGVsOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIGhhc1ByZXZpb3VzUmVzcG9uc2VJZDogISFlbmhhbmNlZFJlcXVlc3QucHJldmlvdXNSZXNwb25zZUlkXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZXNwb25zZXMnKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlV2l0aFJlc3BvbnNlc0FQSShlbmhhbmNlZFJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlV2l0aENoYXRDb21wbGV0aW9ucyhlbmhhbmNlZFJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnRW5oYW5jZWQgdGV4dCBnZW5lcmF0aW9uIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcmVzcG9uc2UubW9kZWwsXG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICByZXNwb25zZUlkOiByZXNwb25zZS5yZXNwb25zZUlkLFxuICAgICAgICAgICAgICAgIHRva2VuczogcmVzcG9uc2UudXNhZ2U/LnRvdGFsVG9rZW5zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1ld29ya0Vycm9yID0gdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLCAnZW5oYW5jZWQtb3BlbmFpJywgJ2dlbmVyYXRlVGV4dCcpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0VuaGFuY2VkIHRleHQgZ2VuZXJhdGlvbiBmYWlsZWQnLCB7IGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlIH0sIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGV4dCB1c2luZyB0aGUgbmV3IFJlc3BvbnNlcyBBUElcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVdpdGhSZXNwb25zZXNBUEkocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZFJlc3BvbnNlc0FQSVBheWxvYWQocmVxdWVzdCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NhbGxpbmcgT3BlbkFJIFJlc3BvbnNlcyBBUEknLCB7XG4gICAgICAgICAgICBlbmRwb2ludDogYCR7dGhpcy5iYXNlVXJsfS9yZXNwb25zZXNgLFxuICAgICAgICAgICAgbW9kZWw6IHBheWxvYWQubW9kZWwsXG4gICAgICAgICAgICBoYXNQcmV2aW91c1Jlc3BvbnNlSWQ6ICEhcGF5bG9hZC5wcmV2aW91c19yZXNwb25zZV9pZCxcbiAgICAgICAgICAgIGhhc1Rvb2xzOiAhIShwYXlsb2FkLnRvb2xzICYmIHBheWxvYWQudG9vbHMubGVuZ3RoID4gMClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9yZXNwb25zZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy5jb25maWcudGltZW91dCB8fCA2MDAwMClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuaGFuZGxlQVBJRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVJlc3BvbnNlc0FQSVJlc3BvbnNlKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0ZXh0IHVzaW5nIHRyYWRpdGlvbmFsIENoYXQgQ29tcGxldGlvbnMgQVBJXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVXaXRoQ2hhdENvbXBsZXRpb25zKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuYnVpbGRDaGF0Q29tcGxldGlvbnNQYXlsb2FkKHJlcXVlc3QpO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDYWxsaW5nIE9wZW5BSSBDaGF0IENvbXBsZXRpb25zIEFQSScsIHtcbiAgICAgICAgICAgIGVuZHBvaW50OiBgJHt0aGlzLmJhc2VVcmx9L2NoYXQvY29tcGxldGlvbnNgLFxuICAgICAgICAgICAgbW9kZWw6IHBheWxvYWQubW9kZWwsXG4gICAgICAgICAgICBtZXNzYWdlc0NvdW50OiBwYXlsb2FkLm1lc3NhZ2VzLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2NoYXQvY29tcGxldGlvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy5jb25maWcudGltZW91dCB8fCA2MDAwMClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuaGFuZGxlQVBJRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUNoYXRDb21wbGV0aW9uc1Jlc3BvbnNlKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gdGV4dCB3aXRoIGF1dG9tYXRpYyBtb2RlIGRldGVjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbVRleHQocmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZW5oYW5jZWRSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgY29uc3QgbW9kZSA9IGVuaGFuY2VkUmVxdWVzdC5tb2RlIHx8IHRoaXMuZGV0ZXJtaW5lT3B0aW1hbE1vZGUoZW5oYW5jZWRSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU3RhcnRpbmcgZW5oYW5jZWQgc3RyZWFtaW5nIHRleHQgZ2VuZXJhdGlvbicsIHtcbiAgICAgICAgICAgIG1vZGVsOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIGhhc1ByZXZpb3VzUmVzcG9uc2VJZDogISFlbmhhbmNlZFJlcXVlc3QucHJldmlvdXNSZXNwb25zZUlkXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZXNwb25zZXMnKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN0cmVhbVJlc3BvbnNlc0FQSShlbmhhbmNlZFJlcXVlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHJlYW1DaGF0Q29tcGxldGlvbnMoZW5oYW5jZWRSZXF1ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdFbmhhbmNlZCBzdHJlYW1pbmcgdGV4dCBnZW5lcmF0aW9uIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcmVzcG9uc2UubW9kZWwsXG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICByZXNwb25zZUlkOiByZXNwb25zZS5yZXNwb25zZUlkLFxuICAgICAgICAgICAgICAgIHRva2VuczogcmVzcG9uc2UudXNhZ2U/LnRvdGFsVG9rZW5zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1ld29ya0Vycm9yID0gdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLCAnZW5oYW5jZWQtb3BlbmFpJywgJ3N0cmVhbVRleHQnKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFbmhhbmNlZCBzdHJlYW1pbmcgdGV4dCBnZW5lcmF0aW9uIGZhaWxlZCcsIHsgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2UgfSwgZXJyb3IpO1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250aW51ZSBjb252ZXJzYXRpb24gd2l0aCBwcmV2aW91cyByZXNwb25zZSBJRFxuICAgICAqL1xuICAgIGFzeW5jIGNvbnRpbnVlQ29udmVyc2F0aW9uKHNlc3Npb25JZCwgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuY29udmVyc2F0aW9uU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYENvbnZlcnNhdGlvbiBzZXNzaW9uICcke3Nlc3Npb25JZH0nIG5vdCBmb3VuZGBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHByb21wdDogaW5wdXQsXG4gICAgICAgICAgICBtb2RlOiAncmVzcG9uc2VzJyxcbiAgICAgICAgICAgIHByZXZpb3VzUmVzcG9uc2VJZDogc2Vzc2lvbi5sYXN0UmVzcG9uc2VJZCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVRleHQocmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZXNwb25zZUlkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5yZXNwb25zZUhpc3RvcnkucHVzaChyZXNwb25zZS5yZXNwb25zZUlkKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmxhc3RSZXNwb25zZUlkID0gcmVzcG9uc2UucmVzcG9uc2VJZDtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbnZlcnNhdGlvbiBzZXNzaW9uXG4gICAgICovXG4gICAgY3JlYXRlQ29udmVyc2F0aW9uU2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgY29uc3QgaWQgPSBzZXNzaW9uSWQgfHwgYGNvbnZfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xuICAgICAgICBjb25zdCBzZXNzaW9uID0ge1xuICAgICAgICAgICAgc2Vzc2lvbklkOiBpZCxcbiAgICAgICAgICAgIHJlc3BvbnNlSGlzdG9yeTogW10sXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb25TZXNzaW9ucy5zZXQoaWQsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDcmVhdGVkIGNvbnZlcnNhdGlvbiBzZXNzaW9uJywgeyBzZXNzaW9uSWQ6IGlkIH0pO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjb252ZXJzYXRpb24gc2Vzc2lvbiBkZXRhaWxzXG4gICAgICovXG4gICAgZ2V0Q29udmVyc2F0aW9uU2Vzc2lvbihzZXNzaW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVyc2F0aW9uU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjb252ZXJzYXRpb24gc2Vzc2lvblxuICAgICAqL1xuICAgIGRlbGV0ZUNvbnZlcnNhdGlvblNlc3Npb24oc2Vzc2lvbklkKSB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLmNvbnZlcnNhdGlvblNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnRGVsZXRlZCBjb252ZXJzYXRpb24gc2Vzc2lvbicsIHsgc2Vzc2lvbklkIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIHByZXZpb3VzIHJlc3BvbnNlIGJ5IElEXG4gICAgICovXG4gICAgYXN5bmMgcmV0cmlldmVSZXNwb25zZShyZXNwb25zZUlkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vcmVzcG9uc2VzLyR7cmVzcG9uc2VJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy5jb25maWcudGltZW91dCB8fCAzMDAwMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuaGFuZGxlQVBJRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnRyYW5zZm9ybVJlc3BvbnNlc0FQSVJlc3BvbnNlKGRhdGEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZnJhbWV3b3JrRXJyb3IgPSB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGUoZXJyb3IsICdlbmhhbmNlZC1vcGVuYWknLCAncmV0cmlldmVSZXNwb25zZScpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBMZWdhY3kgaW50ZXJmYWNlIHN1cHBvcnRcbiAgICBhc3luYyAqZ2VuZXJhdGVUZXh0U3RyZWFtKHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgZW5oYW5jZWRSZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgbGV0IGZ1bGxUZXh0ID0gJyc7XG4gICAgICAgIGxldCBmaW5hbFJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSAnZGF0YScgJiYgY2h1bmsuZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB5aWVsZGVkIGluIHRoZSBwcm9taXNlIHJlc29sdXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rLnR5cGUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluYWwgY2h1bmtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gRm9yIGZ1bGwgYXN5bmMgZ2VuZXJhdG9yIHN1cHBvcnQsIG1vcmUgY29tcGxleCBzdHJlYW0gaGFuZGxpbmcgd291bGQgYmUgbmVlZGVkXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc3RyZWFtVGV4dChyZXF1ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFlpZWxkIGZpbmFsIHJlc3BvbnNlIGFzIGEgc2luZ2xlIGNodW5rIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IGNodW5rID0ge1xuICAgICAgICAgICAgdGV4dDogcmVzdWx0LmRhdGE/LnRleHQgfHwgJycsXG4gICAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgICAgdXNhZ2U6IHJlc3VsdC5kYXRhPy51c2FnZVxuICAgICAgICB9O1xuICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWFsdGggY2hlY2sgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBpc0hlYWx0aHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vbW9kZWxzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDUwMDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0hlYWx0aCBjaGVjayBmYWlsZWQnLCB7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ2VuaGFuY2VkLW9wZW5haS10ZXh0LWdlbmVyYXRvcic7XG4gICAgfVxuICAgIGFzeW5jIGdldEF2YWlsYWJsZU1vZGVscygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9tb2RlbHNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbW9kZWxzOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEuZGF0YVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG1vZGVsKSA9PiBtb2RlbC5pZC5zdGFydHNXaXRoKCdncHQtJykgfHwgbW9kZWwuaWQuc3RhcnRzV2l0aCgnbycpKVxuICAgICAgICAgICAgICAgIC5tYXAoKG1vZGVsKSA9PiBtb2RlbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGdldCBhdmFpbGFibGUgbW9kZWxzJywge30sIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUZyYW1ld29ya0Vycm9yKGVycm9yLCAnZW5oYW5jZWQtb3BlbmFpJywgJ2dldEF2YWlsYWJsZU1vZGVscycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFByaXZhdGUgaGVscGVyIG1ldGhvZHNcbiAgICBkZXRlcm1pbmVPcHRpbWFsTW9kZShyZXF1ZXN0KSB7XG4gICAgICAgIC8vIFVzZSByZXNwb25zZXMgQVBJIGlmOlxuICAgICAgICAvLyAtIFByZXZpb3VzIHJlc3BvbnNlIElEIGlzIHByb3ZpZGVkXG4gICAgICAgIC8vIC0gVG9vbHMgYXJlIHNwZWNpZmllZFxuICAgICAgICAvLyAtIEJhY2tncm91bmQgbW9kZSBpcyByZXF1ZXN0ZWRcbiAgICAgICAgLy8gLSBFeHBsaWNpdGx5IHJlcXVlc3RlZFxuICAgICAgICBpZiAocmVxdWVzdC5wcmV2aW91c1Jlc3BvbnNlSWQgfHxcbiAgICAgICAgICAgIChyZXF1ZXN0LnRvb2xzICYmIHJlcXVlc3QudG9vbHMubGVuZ3RoID4gMCkgfHxcbiAgICAgICAgICAgIHJlcXVlc3QuYmFja2dyb3VuZCB8fFxuICAgICAgICAgICAgcmVxdWVzdC5tb2RlID09PSAncmVzcG9uc2VzJykge1xuICAgICAgICAgICAgcmV0dXJuICdyZXNwb25zZXMnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnY2hhdF9jb21wbGV0aW9ucyc7XG4gICAgfVxuICAgIGJ1aWxkUmVzcG9uc2VzQVBJUGF5bG9hZChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gcmVxdWVzdC5tb2RlbCB8fCB0aGlzLmNvbmZpZy5tb2RlbCB8fCAnZ3B0LTRvJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuYnVpbGRJbnB1dEZvclJlc3BvbnNlc0FQSShyZXF1ZXN0KVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxdWVzdC5wcmV2aW91c1Jlc3BvbnNlSWQpIHtcbiAgICAgICAgICAgIHBheWxvYWQucHJldmlvdXNfcmVzcG9uc2VfaWQgPSByZXF1ZXN0LnByZXZpb3VzUmVzcG9uc2VJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5pbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaW5zdHJ1Y3Rpb25zID0gcmVxdWVzdC5pbnN0cnVjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QudG9vbHMgJiYgcmVxdWVzdC50b29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnRvb2xzID0gcmVxdWVzdC50b29scztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5iYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmJhY2tncm91bmQgPSByZXF1ZXN0LmJhY2tncm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3Quc3RvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF5bG9hZC5zdG9yZSA9IHJlcXVlc3Quc3RvcmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG1vZGVsLXNwZWNpZmljIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKHJlcXVlc3QubWF4VG9rZW5zKSB7XG4gICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgnbzMnKSB8fCBtb2RlbC5zdGFydHNXaXRoKCdvMicpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ28xJykpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLm1heF9jb21wbGV0aW9uX3Rva2VucyA9IHJlcXVlc3QubWF4VG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5tYXhfb3V0cHV0X3Rva2VucyA9IHJlcXVlc3QubWF4VG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LnRlbXBlcmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdvMycpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ28yJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgnbzEnKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRlbXBlcmF0dXJlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQudGVtcGVyYXR1cmUgPSByZXF1ZXN0LnRlbXBlcmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudGVtcGVyYXR1cmUgPSByZXF1ZXN0LnRlbXBlcmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBidWlsZElucHV0Rm9yUmVzcG9uc2VzQVBJKHJlcXVlc3QpIHtcbiAgICAgICAgLy8gRm9yIHJlc3BvbnNlcyBBUEksIGlucHV0IGNhbiBiZSBhIHN0cmluZyBvciBtZXNzYWdlIGFycmF5XG4gICAgICAgIGlmIChyZXF1ZXN0LmNvbnZlcnNhdGlvbkhpc3RvcnkgJiYgcmVxdWVzdC5jb252ZXJzYXRpb25IaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zeXN0ZW1Qcm9tcHQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlcXVlc3Quc3lzdGVtUHJvbXB0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKC4uLnJlcXVlc3QuY29udmVyc2F0aW9uSGlzdG9yeSk7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgY29udGVudDogcmVxdWVzdC5wcm9tcHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbXBsZSBzdHJpbmcgaW5wdXRcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QucHJvbXB0O1xuICAgIH1cbiAgICBidWlsZENoYXRDb21wbGV0aW9uc1BheWxvYWQocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAocmVxdWVzdC5zeXN0ZW1Qcm9tcHQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlcXVlc3Quc3lzdGVtUHJvbXB0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5jb252ZXJzYXRpb25IaXN0b3J5ICYmIHJlcXVlc3QuY29udmVyc2F0aW9uSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKC4uLnJlcXVlc3QuY29udmVyc2F0aW9uSGlzdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICBjb250ZW50OiByZXF1ZXN0LnByb21wdFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSByZXF1ZXN0Lm1vZGVsIHx8IHRoaXMuY29uZmlnLm1vZGVsIHx8ICdncHQtMy41LXR1cmJvJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgICAgICBzdHJlYW06IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXF1ZXN0Lm1heFRva2Vucykge1xuICAgICAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ28zJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgnbzInKSB8fCBtb2RlbC5zdGFydHNXaXRoKCdvMScpKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5tYXhfY29tcGxldGlvbl90b2tlbnMgPSByZXF1ZXN0Lm1heFRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBheWxvYWQubWF4X3Rva2VucyA9IHJlcXVlc3QubWF4VG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LnRlbXBlcmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdvMycpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ28yJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgnbzEnKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRlbXBlcmF0dXJlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQudGVtcGVyYXR1cmUgPSByZXF1ZXN0LnRlbXBlcmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudGVtcGVyYXR1cmUgPSByZXF1ZXN0LnRlbXBlcmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1SZXNwb25zZXNBUElSZXNwb25zZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdGV4dDogZGF0YS5vdXRwdXRfdGV4dCB8fCB0aGlzLmV4dHJhY3RUZXh0RnJvbU91dHB1dChkYXRhLm91dHB1dCksXG4gICAgICAgICAgICBtb2RlbDogZGF0YS5tb2RlbCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogZGF0YS5zdGF0dXMsXG4gICAgICAgICAgICByZXNwb25zZUlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgc3RhdHVzOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgICAgIG91dHB1dDogZGF0YS5vdXRwdXQsXG4gICAgICAgICAgICB1c2FnZTogZGF0YS51c2FnZSA/IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGRhdGEudXNhZ2UuaW5wdXRfdG9rZW5zIHx8IGRhdGEudXNhZ2UucHJvbXB0X3Rva2VucyB8fCAwLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGRhdGEudXNhZ2Uub3V0cHV0X3Rva2VucyB8fCBkYXRhLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zIHx8IDAsXG4gICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IGRhdGEudXNhZ2UudG90YWxfdG9rZW5zIHx8IDBcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1DaGF0Q29tcGxldGlvbnNSZXNwb25zZShkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgICAgbW9kZWw6IGRhdGEubW9kZWwsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGRhdGEuY2hvaWNlc1swXS5maW5pc2hfcmVhc29uLFxuICAgICAgICAgICAgdXNhZ2U6IGRhdGEudXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBkYXRhLnVzYWdlLnByb21wdF90b2tlbnMsXG4gICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogZGF0YS51c2FnZS5jb21wbGV0aW9uX3Rva2VucyxcbiAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogZGF0YS51c2FnZS50b3RhbF90b2tlbnNcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXh0cmFjdFRleHRGcm9tT3V0cHV0KG91dHB1dCkge1xuICAgICAgICBpZiAoIW91dHB1dCB8fCAhQXJyYXkuaXNBcnJheShvdXRwdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gJ21lc3NhZ2UnICYmIGl0ZW0ucm9sZSA9PT0gJ2Fzc2lzdGFudCcpXG4gICAgICAgICAgICAubWFwKGl0ZW0gPT4gaXRlbS5jb250ZW50KVxuICAgICAgICAgICAgLmZsYXQoKVxuICAgICAgICAgICAgLmZpbHRlcihjb250ZW50ID0+IGNvbnRlbnQudHlwZSA9PT0gJ291dHB1dF90ZXh0JylcbiAgICAgICAgICAgIC5tYXAoY29udGVudCA9PiBjb250ZW50LnRleHQpXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbVJlc3BvbnNlc0FQSShyZXF1ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZFJlc3BvbnNlc0FQSVBheWxvYWQocmVxdWVzdCk7XG4gICAgICAgIHBheWxvYWQuc3RyZWFtID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L3Jlc3BvbnNlc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLmNvbmZpZy50aW1lb3V0IHx8IDYwMDAwKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5oYW5kbGVBUElFcnJvcihyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Jlc3BvbnNlc1N0cmVhbVJlc3BvbnNlKHJlc3BvbnNlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbUNoYXRDb21wbGV0aW9ucyhyZXF1ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZENoYXRDb21wbGV0aW9uc1BheWxvYWQocmVxdWVzdCk7XG4gICAgICAgIHBheWxvYWQuc3RyZWFtID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2NoYXQvY29tcGxldGlvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy5jb25maWcudGltZW91dCB8fCA2MDAwMClcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuaGFuZGxlQVBJRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NDaGF0Q29tcGxldGlvbnNTdHJlYW1SZXNwb25zZShyZXNwb25zZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUmVzcG9uc2VzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IHJlYWRlciBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGxldCBmdWxsVGV4dCA9ICcnO1xuICAgICAgICBsZXQgZmluYWxSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSAmJiBsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6ICcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ1tET05FXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7IHR5cGU6ICdlbmQnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICcnIHx8IGRhdGEgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQudHlwZSA9PT0gJ3Jlc3BvbnNlLm91dHB1dF90ZXh0LmRlbHRhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcGFyc2VkLmRlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFRleHQgKz0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlZC50eXBlID09PSAncmVzcG9uc2UuZG9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxSZXNwb25zZSA9IHRoaXMudHJhbnNmb3JtUmVzcG9uc2VzQVBJUmVzcG9uc2UocGFyc2VkLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTa2lwcGluZyBtYWxmb3JtZWQgSlNPTiBjaHVuayBpbiByZXNwb25zZXMgc3RyZWFtJywgeyBkYXRhOiBkYXRhLnN1YnN0cmluZygwLCAxMDApIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmaW5hbFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgZmluYWxSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogZnVsbFRleHQsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLmNvbmZpZy5tb2RlbCB8fCAnZ3B0LTRvJyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiAnc3RvcCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxSZXNwb25zZS51c2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQ2hhdENvbXBsZXRpb25zU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IHJlYWRlciBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGxldCBmdWxsVGV4dCA9ICcnO1xuICAgICAgICBsZXQgZmluYWxSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSAmJiBsaW5lLnN0YXJ0c1dpdGgoJ2RhdGE6ICcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ1tET05FXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7IHR5cGU6ICdlbmQnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICcnIHx8IGRhdGEgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZWQuY2hvaWNlcz8uWzBdPy5kZWx0YT8uY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsVGV4dCArPSBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5jaG9pY2VzPy5bMF0/LmZpbmlzaF9yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZ1bGxUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHBhcnNlZC5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcGFyc2VkLmNob2ljZXNbMF0uZmluaXNoX3JlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBwYXJzZWQudXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBwYXJzZWQudXNhZ2UucHJvbXB0X3Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBwYXJzZWQudXNhZ2UuY29tcGxldGlvbl90b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IHBhcnNlZC51c2FnZS50b3RhbF90b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTa2lwcGluZyBtYWxmb3JtZWQgSlNPTiBjaHVuayBpbiBjaGF0IGNvbXBsZXRpb25zIHN0cmVhbScsIHsgZGF0YTogZGF0YS5zdWJzdHJpbmcoMCwgMTAwKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmluYWxSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGZpbmFsUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGZ1bGxUZXh0LFxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5jb25maWcubW9kZWwgfHwgJ2dwdC0zLjUtdHVyYm8nLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246ICdzdG9wJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgIGlzQ29tcGxldGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVzYWdlOiBmaW5hbFJlc3BvbnNlLnVzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFQSUVycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JUeXBlc18xLkF1dGhlbnRpY2F0aW9uRXJyb3IoJ0ludmFsaWQgT3BlbkFJIEFQSSBrZXknLCAnZW5oYW5jZWQtb3BlbmFpJyk7XG4gICAgICAgICAgICBjYXNlIDQyOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5SYXRlTGltaXRFcnJvcignT3BlbkFJIEFQSSByYXRlIGxpbWl0IGV4Y2VlZGVkJywgJ2VuaGFuY2VkLW9wZW5haScpO1xuICAgICAgICAgICAgY2FzZSA0MDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclR5cGVzXzEuVmFsaWRhdGlvbkVycm9yKGBPcGVuQUkgQVBJIHZhbGlkYXRpb24gZXJyb3I6ICR7ZXJyb3JCb2R5fWApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5OZXR3b3JrRXJyb3IoYE9wZW5BSSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke2Vycm9yQm9keX1gLCAnZW5oYW5jZWQtb3BlbmFpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb25maWcub3JnYW5pemF0aW9uKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydPcGVuQUktT3JnYW5pemF0aW9uJ10gPSB0aGlzLmNvbmZpZy5vcmdhbml6YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHZhbGlkYXRlQ29uZmlnKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yVHlwZXNfMS5WYWxpZGF0aW9uRXJyb3IoJ09wZW5BSSBBUEkga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVuaGFuY2VkT3BlbkFJVGV4dEdlbmVyYXRvciA9IEVuaGFuY2VkT3BlbkFJVGV4dEdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVuaGFuY2VkT3BlbkFJVGV4dEdlbmVyYXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/EnhancedOpenAITextGenerator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIImageGenerator.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIImageGenerator.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// OpenAI Image Generator Adapter\n// Implements IImageGenerator using DALL-E for AI image generation\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OpenAIImageGenerator = void 0;\nconst ErrorTypes_1 = __webpack_require__(/*! ../../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass OpenAIImageGenerator {\n    constructor(config, logger, errorHandler) {\n        this.config = config;\n        this.logger = logger;\n        this.errorHandler = errorHandler;\n        this.baseUrl = config.baseUrl || 'https://api.openai.com/v1';\n        this.validateConfig();\n    }\n    /**\n     * Generate images based on text prompt\n     */\n    async generateImage(request) {\n        this.logger.info('Starting image generation', {\n            prompt: request.prompt.substring(0, 100),\n            size: request.size,\n            n: request.n\n        });\n        try {\n            const response = await this.errorHandler.executeWithRetry(() => this.callDallEAPI(request), { service: 'openai', operation: 'generateImage' });\n            this.logger.info('Image generation completed', {\n                imageCount: response.images.length\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'openai', 'generateImage');\n            this.logger.error('Image generation failed', { error: frameworkError.message });\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Generate multiple variations of an image\n     */\n    async generateImageVariations(request) {\n        this.logger.info('Starting image variations generation', {\n            prompt: request.prompt.substring(0, 100),\n            variations: request.n\n        });\n        const variationRequest = {\n            ...request,\n            n: request.n\n        };\n        return this.generateImage(variationRequest);\n    }\n    /**\n     * Edit an existing image with a prompt (using DALL-E 2 edit endpoint)\n     */\n    async editImage(imageUrl, prompt, maskUrl) {\n        this.logger.info('Starting image editing', {\n            prompt: prompt.substring(0, 100),\n            hasMask: !!maskUrl\n        });\n        try {\n            const response = await this.errorHandler.executeWithRetry(() => this.callDallEEditAPI(imageUrl, prompt, maskUrl), { service: 'openai', operation: 'editImage' });\n            this.logger.info('Image editing completed');\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'openai', 'editImage');\n            this.logger.error('Image editing failed', { error: frameworkError.message });\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Check if the service is available and configured properly\n     */\n    async isHealthy() {\n        try {\n            // Test with a simple image generation to verify the service\n            const testResponse = await fetch(`${this.baseUrl}/models`, {\n                method: 'GET',\n                headers: this.getHeaders(),\n                signal: AbortSignal.timeout(5000) // 5 second timeout\n            });\n            return testResponse.ok;\n        }\n        catch (error) {\n            this.logger.warn('Health check failed');\n            return false;\n        }\n    }\n    /**\n     * Get service name for health checks\n     */\n    getServiceName() {\n        return 'openai-image-generator';\n    }\n    /**\n     * Get available image models and their capabilities\n     */\n    async getAvailableModels() {\n        // DALL-E models and their capabilities\n        return [\n            {\n                id: 'dall-e-3',\n                name: 'DALL-E 3',\n                maxResolution: '1792x1024',\n                supportedFormats: ['png']\n            },\n            {\n                id: 'dall-e-2',\n                name: 'DALL-E 2',\n                maxResolution: '1024x1024',\n                supportedFormats: ['png']\n            }\n        ];\n    }\n    /**\n     * Call DALL-E API for image generation\n     */\n    async callDallEAPI(request) {\n        const payload = {\n            prompt: request.prompt,\n            model: 'dall-e-3', // Default to DALL-E 3\n            n: request.n || 1,\n            size: request.size || '1024x1024',\n            quality: request.quality || 'standard',\n            style: request.style || 'vivid'\n        };\n        const response = await fetch(`${this.baseUrl}/images/generations`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 120000) // 2 minutes for image generation\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        const data = await response.json();\n        return this.transformResponse(data);\n    }\n    /**\n     * Call DALL-E edit API for image editing\n     */\n    async callDallEEditAPI(imageUrl, prompt, maskUrl) {\n        // For image editing, we need to create a FormData\n        const formData = new FormData();\n        // Fetch the image and convert to File/Blob\n        const imageResponse = await fetch(imageUrl);\n        const imageBlob = await imageResponse.blob();\n        formData.append('image', imageBlob, 'image.png');\n        formData.append('prompt', prompt);\n        formData.append('model', 'dall-e-2'); // Only DALL-E 2 supports editing\n        formData.append('n', '1');\n        formData.append('size', '1024x1024');\n        if (maskUrl) {\n            const maskResponse = await fetch(maskUrl);\n            const maskBlob = await maskResponse.blob();\n            formData.append('mask', maskBlob, 'mask.png');\n        }\n        const headers = this.getHeaders();\n        delete headers['Content-Type']; // Let browser set Content-Type for FormData\n        const response = await fetch(`${this.baseUrl}/images/edits`, {\n            method: 'POST',\n            headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.config.timeout || 120000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        const data = await response.json();\n        return this.transformResponse(data);\n    }\n    /**\n     * Transform OpenAI API response to framework format\n     */\n    transformResponse(data) {\n        return {\n            images: data.data.map((item) => ({\n                url: item.url,\n                b64_json: item.b64_json,\n                revisedPrompt: item.revised_prompt\n            }))\n        };\n    }\n    /**\n     * Handle API errors and convert to framework errors\n     */\n    async handleAPIError(response) {\n        const errorBody = await response.text();\n        switch (response.status) {\n            case 401:\n                return new ErrorTypes_1.AuthenticationError('Invalid OpenAI API key', 'openai');\n            case 429:\n                return new ErrorTypes_1.RateLimitError('OpenAI API rate limit exceeded', 'openai');\n            case 400:\n                return new ErrorTypes_1.ValidationError(`OpenAI API validation error: ${errorBody}`);\n            default:\n                return new ErrorTypes_1.NetworkError(`OpenAI API error: ${response.status} ${errorBody}`, 'openai');\n        }\n    }\n    /**\n     * Get HTTP headers for API requests\n     */\n    getHeaders() {\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.config.apiKey}`\n        };\n        if (this.config.organization) {\n            headers['OpenAI-Organization'] = this.config.organization;\n        }\n        return headers;\n    }\n    /**\n     * Validate configuration\n     */\n    validateConfig() {\n        if (!this.config.apiKey) {\n            throw new ErrorTypes_1.ValidationError('OpenAI API key is required');\n        }\n    }\n}\nexports.OpenAIImageGenerator = OpenAIImageGenerator;\n//# sourceMappingURL=OpenAIImageGenerator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL29wZW5haS9PcGVuQUlJbWFnZUdlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLHFCQUFxQixtQkFBTyxDQUFDLGdJQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBHQUEwRywrQ0FBK0M7QUFDeko7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwrQkFBK0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnSUFBZ0ksMkNBQTJDO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsK0JBQStCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsVUFBVTtBQUNsRztBQUNBLDBFQUEwRSxpQkFBaUIsRUFBRSxVQUFVO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvb3BlbmFpL09wZW5BSUltYWdlR2VuZXJhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gT3BlbkFJIEltYWdlIEdlbmVyYXRvciBBZGFwdGVyXG4vLyBJbXBsZW1lbnRzIElJbWFnZUdlbmVyYXRvciB1c2luZyBEQUxMLUUgZm9yIEFJIGltYWdlIGdlbmVyYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3BlbkFJSW1hZ2VHZW5lcmF0b3IgPSB2b2lkIDA7XG5jb25zdCBFcnJvclR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS90eXBlcy9FcnJvclR5cGVzXCIpO1xuY2xhc3MgT3BlbkFJSW1hZ2VHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgbG9nZ2VyLCBlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gY29uZmlnLmJhc2VVcmwgfHwgJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEnO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZmlnKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGltYWdlcyBiYXNlZCBvbiB0ZXh0IHByb21wdFxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlSW1hZ2UocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyBpbWFnZSBnZW5lcmF0aW9uJywge1xuICAgICAgICAgICAgcHJvbXB0OiByZXF1ZXN0LnByb21wdC5zdWJzdHJpbmcoMCwgMTAwKSxcbiAgICAgICAgICAgIHNpemU6IHJlcXVlc3Quc2l6ZSxcbiAgICAgICAgICAgIG46IHJlcXVlc3QublxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5lcnJvckhhbmRsZXIuZXhlY3V0ZVdpdGhSZXRyeSgoKSA9PiB0aGlzLmNhbGxEYWxsRUFQSShyZXF1ZXN0KSwgeyBzZXJ2aWNlOiAnb3BlbmFpJywgb3BlcmF0aW9uOiAnZ2VuZXJhdGVJbWFnZScgfSk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJbWFnZSBnZW5lcmF0aW9uIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgICAgICAgICBpbWFnZUNvdW50OiByZXNwb25zZS5pbWFnZXMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1ld29ya0Vycm9yID0gdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLCAnb3BlbmFpJywgJ2dlbmVyYXRlSW1hZ2UnKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdJbWFnZSBnZW5lcmF0aW9uIGZhaWxlZCcsIHsgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG11bHRpcGxlIHZhcmlhdGlvbnMgb2YgYW4gaW1hZ2VcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUltYWdlVmFyaWF0aW9ucyhyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGltYWdlIHZhcmlhdGlvbnMgZ2VuZXJhdGlvbicsIHtcbiAgICAgICAgICAgIHByb21wdDogcmVxdWVzdC5wcm9tcHQuc3Vic3RyaW5nKDAsIDEwMCksXG4gICAgICAgICAgICB2YXJpYXRpb25zOiByZXF1ZXN0Lm5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHZhcmlhdGlvblJlcXVlc3QgPSB7XG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICAgICAgbjogcmVxdWVzdC5uXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSW1hZ2UodmFyaWF0aW9uUmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVkaXQgYW4gZXhpc3RpbmcgaW1hZ2Ugd2l0aCBhIHByb21wdCAodXNpbmcgREFMTC1FIDIgZWRpdCBlbmRwb2ludClcbiAgICAgKi9cbiAgICBhc3luYyBlZGl0SW1hZ2UoaW1hZ2VVcmwsIHByb21wdCwgbWFza1VybCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyBpbWFnZSBlZGl0aW5nJywge1xuICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHQuc3Vic3RyaW5nKDAsIDEwMCksXG4gICAgICAgICAgICBoYXNNYXNrOiAhIW1hc2tVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXJyb3JIYW5kbGVyLmV4ZWN1dGVXaXRoUmV0cnkoKCkgPT4gdGhpcy5jYWxsRGFsbEVFZGl0QVBJKGltYWdlVXJsLCBwcm9tcHQsIG1hc2tVcmwpLCB7IHNlcnZpY2U6ICdvcGVuYWknLCBvcGVyYXRpb246ICdlZGl0SW1hZ2UnIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnSW1hZ2UgZWRpdGluZyBjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1ld29ya0Vycm9yID0gdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLCAnb3BlbmFpJywgJ2VkaXRJbWFnZScpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ltYWdlIGVkaXRpbmcgZmFpbGVkJywgeyBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHNlcnZpY2UgaXMgYXZhaWxhYmxlIGFuZCBjb25maWd1cmVkIHByb3Blcmx5XG4gICAgICovXG4gICAgYXN5bmMgaXNIZWFsdGh5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGVzdCB3aXRoIGEgc2ltcGxlIGltYWdlIGdlbmVyYXRpb24gdG8gdmVyaWZ5IHRoZSBzZXJ2aWNlXG4gICAgICAgICAgICBjb25zdCB0ZXN0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L21vZGVsc2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCg1MDAwKSAvLyA1IHNlY29uZCB0aW1lb3V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0UmVzcG9uc2Uub2s7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdIZWFsdGggY2hlY2sgZmFpbGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlcnZpY2UgbmFtZSBmb3IgaGVhbHRoIGNoZWNrc1xuICAgICAqL1xuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ29wZW5haS1pbWFnZS1nZW5lcmF0b3InO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXZhaWxhYmxlIGltYWdlIG1vZGVscyBhbmQgdGhlaXIgY2FwYWJpbGl0aWVzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXZhaWxhYmxlTW9kZWxzKCkge1xuICAgICAgICAvLyBEQUxMLUUgbW9kZWxzIGFuZCB0aGVpciBjYXBhYmlsaXRpZXNcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogJ2RhbGwtZS0zJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnREFMTC1FIDMnLFxuICAgICAgICAgICAgICAgIG1heFJlc29sdXRpb246ICcxNzkyeDEwMjQnLFxuICAgICAgICAgICAgICAgIHN1cHBvcnRlZEZvcm1hdHM6IFsncG5nJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6ICdkYWxsLWUtMicsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0RBTEwtRSAyJyxcbiAgICAgICAgICAgICAgICBtYXhSZXNvbHV0aW9uOiAnMTAyNHgxMDI0JyxcbiAgICAgICAgICAgICAgICBzdXBwb3J0ZWRGb3JtYXRzOiBbJ3BuZyddXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgREFMTC1FIEFQSSBmb3IgaW1hZ2UgZ2VuZXJhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGNhbGxEYWxsRUFQSShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBwcm9tcHQ6IHJlcXVlc3QucHJvbXB0LFxuICAgICAgICAgICAgbW9kZWw6ICdkYWxsLWUtMycsIC8vIERlZmF1bHQgdG8gREFMTC1FIDNcbiAgICAgICAgICAgIG46IHJlcXVlc3QubiB8fCAxLFxuICAgICAgICAgICAgc2l6ZTogcmVxdWVzdC5zaXplIHx8ICcxMDI0eDEwMjQnLFxuICAgICAgICAgICAgcXVhbGl0eTogcmVxdWVzdC5xdWFsaXR5IHx8ICdzdGFuZGFyZCcsXG4gICAgICAgICAgICBzdHlsZTogcmVxdWVzdC5zdHlsZSB8fCAndml2aWQnXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9pbWFnZXMvZ2VuZXJhdGlvbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy5jb25maWcudGltZW91dCB8fCAxMjAwMDApIC8vIDIgbWludXRlcyBmb3IgaW1hZ2UgZ2VuZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5oYW5kbGVBUElFcnJvcihyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUmVzcG9uc2UoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgREFMTC1FIGVkaXQgQVBJIGZvciBpbWFnZSBlZGl0aW5nXG4gICAgICovXG4gICAgYXN5bmMgY2FsbERhbGxFRWRpdEFQSShpbWFnZVVybCwgcHJvbXB0LCBtYXNrVXJsKSB7XG4gICAgICAgIC8vIEZvciBpbWFnZSBlZGl0aW5nLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIEZvcm1EYXRhXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIC8vIEZldGNoIHRoZSBpbWFnZSBhbmQgY29udmVydCB0byBGaWxlL0Jsb2JcbiAgICAgICAgY29uc3QgaW1hZ2VSZXNwb25zZSA9IGF3YWl0IGZldGNoKGltYWdlVXJsKTtcbiAgICAgICAgY29uc3QgaW1hZ2VCbG9iID0gYXdhaXQgaW1hZ2VSZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnaW1hZ2UnLCBpbWFnZUJsb2IsICdpbWFnZS5wbmcnKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdwcm9tcHQnLCBwcm9tcHQpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ21vZGVsJywgJ2RhbGwtZS0yJyk7IC8vIE9ubHkgREFMTC1FIDIgc3VwcG9ydHMgZWRpdGluZ1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ24nLCAnMScpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3NpemUnLCAnMTAyNHgxMDI0Jyk7XG4gICAgICAgIGlmIChtYXNrVXJsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXNrUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChtYXNrVXJsKTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2tCbG9iID0gYXdhaXQgbWFza1Jlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnbWFzaycsIG1hc2tCbG9iLCAnbWFzay5wbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKCk7XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IGJyb3dzZXIgc2V0IENvbnRlbnQtVHlwZSBmb3IgRm9ybURhdGFcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2ltYWdlcy9lZGl0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMuY29uZmlnLnRpbWVvdXQgfHwgMTIwMDAwKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5oYW5kbGVBUElFcnJvcihyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtUmVzcG9uc2UoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBPcGVuQUkgQVBJIHJlc3BvbnNlIHRvIGZyYW1ld29yayBmb3JtYXRcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZXM6IGRhdGEuZGF0YS5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAgICAgdXJsOiBpdGVtLnVybCxcbiAgICAgICAgICAgICAgICBiNjRfanNvbjogaXRlbS5iNjRfanNvbixcbiAgICAgICAgICAgICAgICByZXZpc2VkUHJvbXB0OiBpdGVtLnJldmlzZWRfcHJvbXB0XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIEFQSSBlcnJvcnMgYW5kIGNvbnZlcnQgdG8gZnJhbWV3b3JrIGVycm9yc1xuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZUFQSUVycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JUeXBlc18xLkF1dGhlbnRpY2F0aW9uRXJyb3IoJ0ludmFsaWQgT3BlbkFJIEFQSSBrZXknLCAnb3BlbmFpJyk7XG4gICAgICAgICAgICBjYXNlIDQyOTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5SYXRlTGltaXRFcnJvcignT3BlbkFJIEFQSSByYXRlIGxpbWl0IGV4Y2VlZGVkJywgJ29wZW5haScpO1xuICAgICAgICAgICAgY2FzZSA0MDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclR5cGVzXzEuVmFsaWRhdGlvbkVycm9yKGBPcGVuQUkgQVBJIHZhbGlkYXRpb24gZXJyb3I6ICR7ZXJyb3JCb2R5fWApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5OZXR3b3JrRXJyb3IoYE9wZW5BSSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke2Vycm9yQm9keX1gLCAnb3BlbmFpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEhUVFAgaGVhZGVycyBmb3IgQVBJIHJlcXVlc3RzXG4gICAgICovXG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb25maWcub3JnYW5pemF0aW9uKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydPcGVuQUktT3JnYW5pemF0aW9uJ10gPSB0aGlzLmNvbmZpZy5vcmdhbml6YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUNvbmZpZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvclR5cGVzXzEuVmFsaWRhdGlvbkVycm9yKCdPcGVuQUkgQVBJIGtleSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5PcGVuQUlJbWFnZUdlbmVyYXRvciA9IE9wZW5BSUltYWdlR2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3BlbkFJSW1hZ2VHZW5lcmF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIImageGenerator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIServiceFactory.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIServiceFactory.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// OpenAI Service Factory\n// Creates OpenAI adapters with proper configuration and dependencies\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OpenAIImageGeneratorFactory = exports.OpenAITextGeneratorFactory = void 0;\nexports.createOpenAIServiceFactories = createOpenAIServiceFactories;\nconst OpenAITextGenerator_1 = __webpack_require__(/*! ./OpenAITextGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAITextGenerator.js\");\nconst OpenAIImageGenerator_1 = __webpack_require__(/*! ./OpenAIImageGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIImageGenerator.js\");\nconst ErrorHandler_1 = __webpack_require__(/*! ../../utils/ErrorHandler */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js\");\nconst ErrorTypes_1 = __webpack_require__(/*! ../../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass OpenAITextGeneratorFactory {\n    create(config, logger) {\n        if (!config.services.openai) {\n            throw new ErrorTypes_1.ValidationError('OpenAI configuration is required for text generation');\n        }\n        const errorHandler = new ErrorHandler_1.FrameworkErrorHandler(config.retry);\n        return new OpenAITextGenerator_1.OpenAITextGenerator(config.services.openai, logger, errorHandler);\n    }\n    getServiceName() {\n        return 'textGenerator';\n    }\n}\nexports.OpenAITextGeneratorFactory = OpenAITextGeneratorFactory;\nclass OpenAIImageGeneratorFactory {\n    create(config, logger) {\n        if (!config.services.openai) {\n            throw new ErrorTypes_1.ValidationError('OpenAI configuration is required for image generation');\n        }\n        const errorHandler = new ErrorHandler_1.FrameworkErrorHandler(config.retry);\n        return new OpenAIImageGenerator_1.OpenAIImageGenerator(config.services.openai, logger, errorHandler);\n    }\n    getServiceName() {\n        return 'imageGenerator';\n    }\n}\nexports.OpenAIImageGeneratorFactory = OpenAIImageGeneratorFactory;\n// Helper function to create both OpenAI service factories\nfunction createOpenAIServiceFactories() {\n    return [\n        new OpenAITextGeneratorFactory(),\n        new OpenAIImageGeneratorFactory()\n    ];\n}\n//# sourceMappingURL=OpenAIServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL29wZW5haS9PcGVuQUlTZXJ2aWNlRmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsa0NBQWtDO0FBQ3hFLG9DQUFvQztBQUNwQyw4QkFBOEIsbUJBQU8sQ0FBQyx3SUFBdUI7QUFDN0QsK0JBQStCLG1CQUFPLENBQUMsMElBQXdCO0FBQy9ELHVCQUF1QixtQkFBTyxDQUFDLDBIQUEwQjtBQUN6RCxxQkFBcUIsbUJBQU8sQ0FBQyxnSUFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9vcGVuYWkvT3BlbkFJU2VydmljZUZhY3RvcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBPcGVuQUkgU2VydmljZSBGYWN0b3J5XG4vLyBDcmVhdGVzIE9wZW5BSSBhZGFwdGVycyB3aXRoIHByb3BlciBjb25maWd1cmF0aW9uIGFuZCBkZXBlbmRlbmNpZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3BlbkFJSW1hZ2VHZW5lcmF0b3JGYWN0b3J5ID0gZXhwb3J0cy5PcGVuQUlUZXh0R2VuZXJhdG9yRmFjdG9yeSA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlT3BlbkFJU2VydmljZUZhY3RvcmllcyA9IGNyZWF0ZU9wZW5BSVNlcnZpY2VGYWN0b3JpZXM7XG5jb25zdCBPcGVuQUlUZXh0R2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9PcGVuQUlUZXh0R2VuZXJhdG9yXCIpO1xuY29uc3QgT3BlbkFJSW1hZ2VHZW5lcmF0b3JfMSA9IHJlcXVpcmUoXCIuL09wZW5BSUltYWdlR2VuZXJhdG9yXCIpO1xuY29uc3QgRXJyb3JIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRXJyb3JIYW5kbGVyXCIpO1xuY29uc3QgRXJyb3JUeXBlc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdHlwZXMvRXJyb3JUeXBlc1wiKTtcbmNsYXNzIE9wZW5BSVRleHRHZW5lcmF0b3JGYWN0b3J5IHtcbiAgICBjcmVhdGUoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgaWYgKCFjb25maWcuc2VydmljZXMub3BlbmFpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JUeXBlc18xLlZhbGlkYXRpb25FcnJvcignT3BlbkFJIGNvbmZpZ3VyYXRpb24gaXMgcmVxdWlyZWQgZm9yIHRleHQgZ2VuZXJhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IG5ldyBFcnJvckhhbmRsZXJfMS5GcmFtZXdvcmtFcnJvckhhbmRsZXIoY29uZmlnLnJldHJ5KTtcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVuQUlUZXh0R2VuZXJhdG9yXzEuT3BlbkFJVGV4dEdlbmVyYXRvcihjb25maWcuc2VydmljZXMub3BlbmFpLCBsb2dnZXIsIGVycm9ySGFuZGxlcik7XG4gICAgfVxuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RleHRHZW5lcmF0b3InO1xuICAgIH1cbn1cbmV4cG9ydHMuT3BlbkFJVGV4dEdlbmVyYXRvckZhY3RvcnkgPSBPcGVuQUlUZXh0R2VuZXJhdG9yRmFjdG9yeTtcbmNsYXNzIE9wZW5BSUltYWdlR2VuZXJhdG9yRmFjdG9yeSB7XG4gICAgY3JlYXRlKGNvbmZpZywgbG9nZ2VyKSB7XG4gICAgICAgIGlmICghY29uZmlnLnNlcnZpY2VzLm9wZW5haSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yVHlwZXNfMS5WYWxpZGF0aW9uRXJyb3IoJ09wZW5BSSBjb25maWd1cmF0aW9uIGlzIHJlcXVpcmVkIGZvciBpbWFnZSBnZW5lcmF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcl8xLkZyYW1ld29ya0Vycm9ySGFuZGxlcihjb25maWcucmV0cnkpO1xuICAgICAgICByZXR1cm4gbmV3IE9wZW5BSUltYWdlR2VuZXJhdG9yXzEuT3BlbkFJSW1hZ2VHZW5lcmF0b3IoY29uZmlnLnNlcnZpY2VzLm9wZW5haSwgbG9nZ2VyLCBlcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdpbWFnZUdlbmVyYXRvcic7XG4gICAgfVxufVxuZXhwb3J0cy5PcGVuQUlJbWFnZUdlbmVyYXRvckZhY3RvcnkgPSBPcGVuQUlJbWFnZUdlbmVyYXRvckZhY3Rvcnk7XG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGJvdGggT3BlbkFJIHNlcnZpY2UgZmFjdG9yaWVzXG5mdW5jdGlvbiBjcmVhdGVPcGVuQUlTZXJ2aWNlRmFjdG9yaWVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBPcGVuQUlUZXh0R2VuZXJhdG9yRmFjdG9yeSgpLFxuICAgICAgICBuZXcgT3BlbkFJSW1hZ2VHZW5lcmF0b3JGYWN0b3J5KClcbiAgICBdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3BlbkFJU2VydmljZUZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAITextGenerator.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAITextGenerator.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// OpenAI Text Generator Adapter\n// Implements ITextGenerator with both synchronous and streaming text generation\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OpenAITextGenerator = void 0;\nconst ErrorTypes_1 = __webpack_require__(/*! ../../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass OpenAITextGenerator {\n    constructor(config, logger, errorHandler) {\n        this.config = config;\n        this.logger = logger.child ? logger.child({ service: 'openai-text' }) : logger;\n        this.errorHandler = errorHandler;\n        this.baseUrl = config.baseUrl || 'https://api.openai.com/v1';\n        this.validateConfig();\n    }\n    /**\n     * Generate text synchronously - waits for complete response\n     */\n    async generateText(request) {\n        this.logger.info('Starting text generation', { model: request.model });\n        try {\n            const response = await this.errorHandler.executeWithRetry(() => this.callOpenAIAPI(request, false), { service: 'openai', operation: 'generateText' });\n            this.logger.info('Text generation completed', {\n                model: response.model,\n                tokens: response.usage?.totalTokens\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'openai', 'generateText');\n            this.logger.error('Text generation failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Generate text with streaming - real-time incremental delivery\n     */\n    async streamText(request, callback) {\n        this.logger.info('Starting text generation with streaming', { model: request.model });\n        try {\n            const response = await this.errorHandler.executeWithRetry(() => this.streamOpenAIAPI(request, callback), { service: 'openai', operation: 'streamText' });\n            this.logger.info('Streaming text generation completed', {\n                model: response.model,\n                tokens: response.usage?.totalTokens\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'openai', 'streamText');\n            this.logger.error('Streaming text generation failed', { error: frameworkError.message }, error);\n            callback({\n                type: 'error',\n                error: frameworkError.message\n            });\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Generate text with async generator - alternative streaming approach\n     */\n    async *generateTextStream(request) {\n        this.logger.info('Starting text generation with async generator', { model: request.model });\n        try {\n            const stream = await this.createOpenAIStream(request);\n            let fullText = '';\n            let finalResponse = null;\n            for await (const chunk of stream) {\n                if (chunk.type === 'data') {\n                    fullText += chunk.data.text;\n                    yield chunk.data;\n                }\n                else if (chunk.type === 'end' && chunk.data) {\n                    finalResponse = chunk.data;\n                }\n                else if (chunk.type === 'error') {\n                    throw new Error(chunk.error || 'Streaming error');\n                }\n            }\n            if (!finalResponse) {\n                finalResponse = {\n                    text: fullText,\n                    model: request.model || this.config.model || 'gpt-3.5-turbo',\n                    finishReason: 'stop'\n                };\n            }\n            return finalResponse;\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'openai', 'generateTextStream');\n            this.logger.error('Async generator text generation failed', { error: frameworkError.message }, error);\n            throw frameworkError;\n        }\n    }\n    /**\n     * Check if the service is available and configured properly\n     */\n    async isHealthy() {\n        try {\n            const response = await fetch(`${this.baseUrl}/models`, {\n                method: 'GET',\n                headers: this.getHeaders(),\n                signal: AbortSignal.timeout(5000) // 5 second timeout\n            });\n            return response.ok;\n        }\n        catch (error) {\n            this.logger.warn('Health check failed', { error: error.message });\n            return false;\n        }\n    }\n    /**\n     * Get service name for health checks\n     */\n    getServiceName() {\n        return 'openai-text-generator';\n    }\n    /**\n     * Get available models for text generation\n     */\n    async getAvailableModels() {\n        try {\n            const response = await fetch(`${this.baseUrl}/models`, {\n                method: 'GET',\n                headers: this.getHeaders()\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch models: ${response.statusText}`);\n            }\n            const data = await response.json();\n            return data.data\n                .filter((model) => model.id.startsWith('gpt-'))\n                .map((model) => model.id);\n        }\n        catch (error) {\n            this.logger.error('Failed to get available models', {}, error);\n            throw this.errorHandler.createFrameworkError(error, 'openai', 'getAvailableModels');\n        }\n    }\n    /**\n     * Call OpenAI API for text completion\n     */\n    async callOpenAIAPI(request, stream) {\n        const payload = this.buildAPIPayload(request, stream);\n        // ð DETAILED API REQUEST LOGGING\n        console.log('\\n=== ð OPENAI API REQUEST ===');\n        console.log('ð¡ Endpoint:', `${this.baseUrl}/chat/completions`);\n        console.log('ð¤ Model:', payload.model);\n        console.log('ð Stream:', payload.stream);\n        console.log('ð¬ Messages Count:', payload.messages.length);\n        // Log message structure\n        console.log('\\nð Message Structure:');\n        payload.messages.forEach((msg, index) => {\n            console.log(`  ${index + 1}. ${msg.role}: ${msg.content.substring(0, 100)}${msg.content.length > 100 ? '...' : ''}`);\n        });\n        // Log full payload (with content truncated for readability)\n        console.log('\\nð Complete JSON Payload:');\n        const logPayload = {\n            ...payload,\n            messages: payload.messages.map(msg => ({\n                ...msg,\n                content: msg.content.length > 200 ?\n                    `${msg.content.substring(0, 200)}... [TRUNCATED - Total: ${msg.content.length} chars]` :\n                    msg.content\n            }))\n        };\n        console.log(JSON.stringify(logPayload, null, 2));\n        // Log headers (mask sensitive data)\n        const headers = this.getHeaders();\n        const maskedHeaders = {\n            ...headers,\n            'Authorization': headers.Authorization ? `Bearer ${headers.Authorization.slice(-8)}` : undefined\n        };\n        console.log('\\nð Headers:', maskedHeaders);\n        console.log('=== END REQUEST ===\\n');\n        const response = await fetch(`${this.baseUrl}/chat/completions`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 60000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        const data = await response.json();\n        // ð RESPONSE LOGGING\n        console.log('\\n=== ð¨ OPENAI API RESPONSE ===');\n        console.log('â Status:', response.status);\n        console.log('ð¤ Model Used:', data.model);\n        console.log('ð¯ Finish Reason:', data.choices?.[0]?.finish_reason);\n        if (data.usage) {\n            console.log('ð Token Usage:', {\n                prompt: data.usage.prompt_tokens,\n                completion: data.usage.completion_tokens,\n                total: data.usage.total_tokens\n            });\n        }\n        console.log('ð¬ Response Preview:', data.choices?.[0]?.message?.content?.substring(0, 200) + '...');\n        console.log('=== END RESPONSE ===\\n');\n        return this.transformResponse(data);\n    }\n    /**\n     * Stream OpenAI API response\n     */\n    async streamOpenAIAPI(request, callback) {\n        const payload = this.buildAPIPayload(request, true);\n        const response = await fetch(`${this.baseUrl}/chat/completions`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 60000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        return this.processStreamResponse(response, callback);\n    }\n    /**\n     * Create async generator stream for OpenAI API\n     */\n    async createOpenAIStream(request) {\n        const payload = this.buildAPIPayload(request, true);\n        const response = await fetch(`${this.baseUrl}/chat/completions`, {\n            method: 'POST',\n            headers: this.getHeaders(),\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.config.timeout || 60000)\n        });\n        if (!response.ok) {\n            throw await this.handleAPIError(response);\n        }\n        return this.createStreamGenerator(response);\n    }\n    /**\n     * Process streaming response\n     */\n    async processStreamResponse(response, callback) {\n        const reader = response.body?.getReader();\n        if (!reader) {\n            throw new Error('No response body reader available');\n        }\n        const decoder = new TextDecoder();\n        let fullText = '';\n        let finalResponse = null;\n        let buffer = ''; // Buffer for incomplete lines\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                // Add new chunk to buffer\n                buffer += decoder.decode(value, { stream: true });\n                // Process complete lines\n                const lines = buffer.split('\\n');\n                // Keep the last potentially incomplete line in the buffer\n                buffer = lines.pop() || '';\n                // Process complete lines\n                for (const line of lines) {\n                    if (line.trim() && line.startsWith('data: ')) {\n                        const data = line.slice(6).trim();\n                        if (data === '[DONE]') {\n                            callback({ type: 'end' });\n                            break;\n                        }\n                        if (data === '' || data === ':') {\n                            continue; // Skip empty data or heartbeat\n                        }\n                        try {\n                            const parsed = JSON.parse(data);\n                            const content = parsed.choices?.[0]?.delta?.content;\n                            if (content) {\n                                fullText += content;\n                                const streamChunk = {\n                                    text: content,\n                                    isComplete: false\n                                };\n                                callback({\n                                    type: 'data',\n                                    data: streamChunk\n                                });\n                            }\n                            // Check if this is the final chunk\n                            if (parsed.choices?.[0]?.finish_reason) {\n                                finalResponse = {\n                                    text: fullText,\n                                    model: parsed.model,\n                                    finishReason: parsed.choices[0].finish_reason,\n                                    usage: parsed.usage\n                                };\n                            }\n                        }\n                        catch (parseError) {\n                            // Log but don't break streaming for individual chunk parse failures\n                            this.logger.debug('Skipping malformed JSON chunk in callback stream', { data: data.substring(0, 100) });\n                            continue;\n                        }\n                    }\n                }\n            }\n            // Process any remaining data in buffer\n            if (buffer.trim() && buffer.startsWith('data: ')) {\n                const data = buffer.slice(6).trim();\n                if (data !== '[DONE]' && data !== '' && data !== ':') {\n                    try {\n                        const parsed = JSON.parse(data);\n                        const content = parsed.choices?.[0]?.delta?.content;\n                        if (content) {\n                            fullText += content;\n                            const streamChunk = {\n                                text: content,\n                                isComplete: false\n                            };\n                            callback({\n                                type: 'data',\n                                data: streamChunk\n                            });\n                        }\n                        // Check if this is the final chunk\n                        if (parsed.choices?.[0]?.finish_reason) {\n                            finalResponse = {\n                                text: fullText,\n                                model: parsed.model,\n                                finishReason: parsed.choices[0].finish_reason,\n                                usage: parsed.usage\n                            };\n                        }\n                    }\n                    catch (parseError) {\n                        this.logger.debug('Skipping final malformed JSON chunk in callback stream', { data: data.substring(0, 100) });\n                    }\n                }\n            }\n            if (!finalResponse) {\n                finalResponse = {\n                    text: fullText,\n                    model: this.config.model || 'gpt-3.5-turbo',\n                    finishReason: 'stop'\n                };\n            }\n            // Send final chunk\n            callback({\n                type: 'data',\n                data: {\n                    text: '',\n                    isComplete: true,\n                    usage: finalResponse.usage\n                }\n            });\n            return finalResponse;\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    /**\n     * Create async generator for streaming\n     */\n    async *createStreamGenerator(response) {\n        const reader = response.body?.getReader();\n        if (!reader) {\n            throw new Error('No response body reader available');\n        }\n        const decoder = new TextDecoder();\n        let fullText = '';\n        let buffer = ''; // Buffer for incomplete lines\n        try {\n            while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                    break;\n                // Add new chunk to buffer\n                buffer += decoder.decode(value, { stream: true });\n                // Process complete lines\n                const lines = buffer.split('\\n');\n                // Keep the last potentially incomplete line in the buffer\n                buffer = lines.pop() || '';\n                // Process complete lines\n                for (const line of lines) {\n                    if (line.trim() && line.startsWith('data: ')) {\n                        const data = line.slice(6).trim();\n                        if (data === '[DONE]') {\n                            yield {\n                                type: 'end',\n                                data: {\n                                    text: fullText,\n                                    model: 'gpt-3.5-turbo',\n                                    finishReason: 'stop'\n                                }\n                            };\n                            return;\n                        }\n                        if (data === '' || data === ':') {\n                            continue; // Skip empty data or heartbeat\n                        }\n                        try {\n                            const parsed = JSON.parse(data);\n                            const content = parsed.choices?.[0]?.delta?.content;\n                            if (content) {\n                                fullText += content;\n                                yield {\n                                    type: 'data',\n                                    data: {\n                                        text: content,\n                                        isComplete: false\n                                    }\n                                };\n                            }\n                        }\n                        catch (parseError) {\n                            // Log but don't yield error for individual chunk parse failures\n                            // as they might be due to incomplete chunks\n                            this.logger.debug('Skipping malformed JSON chunk', { data: data.substring(0, 100) });\n                            continue;\n                        }\n                    }\n                }\n            }\n            // Process any remaining data in buffer\n            if (buffer.trim() && buffer.startsWith('data: ')) {\n                const data = buffer.slice(6).trim();\n                if (data !== '[DONE]' && data !== '' && data !== ':') {\n                    try {\n                        const parsed = JSON.parse(data);\n                        const content = parsed.choices?.[0]?.delta?.content;\n                        if (content) {\n                            fullText += content;\n                            yield {\n                                type: 'data',\n                                data: {\n                                    text: content,\n                                    isComplete: false\n                                }\n                            };\n                        }\n                    }\n                    catch (parseError) {\n                        this.logger.debug('Skipping final malformed JSON chunk', { data: data.substring(0, 100) });\n                    }\n                }\n            }\n        }\n        finally {\n            reader.releaseLock();\n        }\n    }\n    /**\n     * Build API payload for OpenAI\n     */\n    buildAPIPayload(request, stream) {\n        const messages = [];\n        // Add system prompt if provided\n        if (request.systemPrompt) {\n            messages.push({\n                role: 'system',\n                content: request.systemPrompt\n            });\n        }\n        // Add conversation history if provided\n        if (request.conversationHistory && request.conversationHistory.length > 0) {\n            messages.push(...request.conversationHistory);\n        }\n        // Add the current user message\n        messages.push({\n            role: 'user',\n            content: request.prompt\n        });\n        const model = request.model || this.config.model || 'gpt-3.5-turbo';\n        // Log the model being used for debugging\n        this.logger.info('Using model for API request', {\n            requestedModel: request.model,\n            configModel: this.config.model,\n            finalModel: model\n        });\n        const payload = {\n            model,\n            messages,\n            stream\n        };\n        // Use the correct parameter name based on the model\n        if (request.maxTokens) {\n            if (model.startsWith('o3') || model.startsWith('o2') || model.startsWith('o1')) {\n                // Newer models use max_completion_tokens\n                payload.max_completion_tokens = request.maxTokens;\n            }\n            else {\n                // Older models use max_tokens\n                payload.max_tokens = request.maxTokens;\n            }\n        }\n        // Handle temperature parameter\n        if (request.temperature !== undefined) {\n            if (model.startsWith('o3') || model.startsWith('o2') || model.startsWith('o1')) {\n                // o3 models only support temperature = 1 (default)\n                if (request.temperature === 1) {\n                    payload.temperature = request.temperature;\n                }\n                // If temperature is not 1, don't include it (use default)\n            }\n            else {\n                // Older models support any temperature value\n                payload.temperature = request.temperature;\n            }\n        }\n        return payload;\n    }\n    /**\n     * Transform OpenAI API response to framework format\n     */\n    transformResponse(data) {\n        return {\n            text: data.choices[0].message.content,\n            model: data.model,\n            finishReason: data.choices[0].finish_reason,\n            usage: data.usage ? {\n                promptTokens: data.usage.prompt_tokens,\n                completionTokens: data.usage.completion_tokens,\n                totalTokens: data.usage.total_tokens\n            } : undefined\n        };\n    }\n    /**\n     * Handle API errors and convert to framework errors\n     */\n    async handleAPIError(response) {\n        const errorBody = await response.text();\n        switch (response.status) {\n            case 401:\n                return new ErrorTypes_1.AuthenticationError('Invalid OpenAI API key', 'openai');\n            case 429:\n                return new ErrorTypes_1.RateLimitError('OpenAI API rate limit exceeded', 'openai');\n            case 400:\n                return new ErrorTypes_1.ValidationError(`OpenAI API validation error: ${errorBody}`);\n            default:\n                return new ErrorTypes_1.NetworkError(`OpenAI API error: ${response.status} ${errorBody}`, 'openai');\n        }\n    }\n    /**\n     * Get HTTP headers for API requests\n     */\n    getHeaders() {\n        const headers = {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.config.apiKey}`\n        };\n        if (this.config.organization) {\n            headers['OpenAI-Organization'] = this.config.organization;\n        }\n        return headers;\n    }\n    /**\n     * Validate configuration\n     */\n    validateConfig() {\n        if (!this.config.apiKey) {\n            throw new ErrorTypes_1.ValidationError('OpenAI API key is required');\n        }\n    }\n}\nexports.OpenAITextGenerator = OpenAITextGenerator;\n//# sourceMappingURL=OpenAITextGenerator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL29wZW5haS9PcGVuQUlUZXh0R2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IscUJBQXFCLG1CQUFPLENBQUMsZ0lBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxzQkFBc0I7QUFDN0U7QUFDQSxrSEFBa0gsOENBQThDO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrQkFBK0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usc0JBQXNCO0FBQzVGO0FBQ0EsdUhBQXVILDRDQUE0QztBQUNuSztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsK0JBQStCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxzQkFBc0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLCtCQUErQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyREFBMkQsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVUsSUFBSSxTQUFTLElBQUksOEJBQThCLEVBQUUsc0NBQXNDO0FBQzlILFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEIsMEJBQTBCLG9CQUFvQjtBQUNuRztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZ0NBQWdDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csOEJBQThCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csOEJBQThCO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsOEJBQThCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw4QkFBOEI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixVQUFVO0FBQ2xHO0FBQ0EsMEVBQTBFLGlCQUFpQixFQUFFLFVBQVU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9vcGVuYWkvT3BlbkFJVGV4dEdlbmVyYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIE9wZW5BSSBUZXh0IEdlbmVyYXRvciBBZGFwdGVyXG4vLyBJbXBsZW1lbnRzIElUZXh0R2VuZXJhdG9yIHdpdGggYm90aCBzeW5jaHJvbm91cyBhbmQgc3RyZWFtaW5nIHRleHQgZ2VuZXJhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcGVuQUlUZXh0R2VuZXJhdG9yID0gdm9pZCAwO1xuY29uc3QgRXJyb3JUeXBlc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdHlwZXMvRXJyb3JUeXBlc1wiKTtcbmNsYXNzIE9wZW5BSVRleHRHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgbG9nZ2VyLCBlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLmNoaWxkID8gbG9nZ2VyLmNoaWxkKHsgc2VydmljZTogJ29wZW5haS10ZXh0JyB9KSA6IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsIHx8ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxJztcbiAgICAgICAgdGhpcy52YWxpZGF0ZUNvbmZpZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0ZXh0IHN5bmNocm9ub3VzbHkgLSB3YWl0cyBmb3IgY29tcGxldGUgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVRleHQocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyB0ZXh0IGdlbmVyYXRpb24nLCB7IG1vZGVsOiByZXF1ZXN0Lm1vZGVsIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmVycm9ySGFuZGxlci5leGVjdXRlV2l0aFJldHJ5KCgpID0+IHRoaXMuY2FsbE9wZW5BSUFQSShyZXF1ZXN0LCBmYWxzZSksIHsgc2VydmljZTogJ29wZW5haScsIG9wZXJhdGlvbjogJ2dlbmVyYXRlVGV4dCcgfSk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdUZXh0IGdlbmVyYXRpb24gY29tcGxldGVkJywge1xuICAgICAgICAgICAgICAgIG1vZGVsOiByZXNwb25zZS5tb2RlbCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHJlc3BvbnNlLnVzYWdlPy50b3RhbFRva2Vuc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXdvcmtFcnJvciA9IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgJ29wZW5haScsICdnZW5lcmF0ZVRleHQnKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdUZXh0IGdlbmVyYXRpb24gZmFpbGVkJywgeyBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZSB9LCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRleHQgd2l0aCBzdHJlYW1pbmcgLSByZWFsLXRpbWUgaW5jcmVtZW50YWwgZGVsaXZlcnlcbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW1UZXh0KHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIHRleHQgZ2VuZXJhdGlvbiB3aXRoIHN0cmVhbWluZycsIHsgbW9kZWw6IHJlcXVlc3QubW9kZWwgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZXJyb3JIYW5kbGVyLmV4ZWN1dGVXaXRoUmV0cnkoKCkgPT4gdGhpcy5zdHJlYW1PcGVuQUlBUEkocmVxdWVzdCwgY2FsbGJhY2spLCB7IHNlcnZpY2U6ICdvcGVuYWknLCBvcGVyYXRpb246ICdzdHJlYW1UZXh0JyB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0cmVhbWluZyB0ZXh0IGdlbmVyYXRpb24gY29tcGxldGVkJywge1xuICAgICAgICAgICAgICAgIG1vZGVsOiByZXNwb25zZS5tb2RlbCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHJlc3BvbnNlLnVzYWdlPy50b3RhbFRva2Vuc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXdvcmtFcnJvciA9IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgJ29wZW5haScsICdzdHJlYW1UZXh0Jyk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignU3RyZWFtaW5nIHRleHQgZ2VuZXJhdGlvbiBmYWlsZWQnLCB7IGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlIH0sIGVycm9yKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGV4dCB3aXRoIGFzeW5jIGdlbmVyYXRvciAtIGFsdGVybmF0aXZlIHN0cmVhbWluZyBhcHByb2FjaFxuICAgICAqL1xuICAgIGFzeW5jICpnZW5lcmF0ZVRleHRTdHJlYW0ocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyB0ZXh0IGdlbmVyYXRpb24gd2l0aCBhc3luYyBnZW5lcmF0b3InLCB7IG1vZGVsOiByZXF1ZXN0Lm1vZGVsIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgdGhpcy5jcmVhdGVPcGVuQUlTdHJlYW0ocmVxdWVzdCk7XG4gICAgICAgICAgICBsZXQgZnVsbFRleHQgPSAnJztcbiAgICAgICAgICAgIGxldCBmaW5hbFJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBmdWxsVGV4dCArPSBjaHVuay5kYXRhLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rLnR5cGUgPT09ICdlbmQnICYmIGNodW5rLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxSZXNwb25zZSA9IGNodW5rLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNodW5rLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNodW5rLmVycm9yIHx8ICdTdHJlYW1pbmcgZXJyb3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmdWxsVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHJlcXVlc3QubW9kZWwgfHwgdGhpcy5jb25maWcubW9kZWwgfHwgJ2dwdC0zLjUtdHVyYm8nLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246ICdzdG9wJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluYWxSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1ld29ya0Vycm9yID0gdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLCAnb3BlbmFpJywgJ2dlbmVyYXRlVGV4dFN0cmVhbScpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0FzeW5jIGdlbmVyYXRvciB0ZXh0IGdlbmVyYXRpb24gZmFpbGVkJywgeyBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZSB9LCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBmcmFtZXdvcmtFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc2VydmljZSBpcyBhdmFpbGFibGUgYW5kIGNvbmZpZ3VyZWQgcHJvcGVybHlcbiAgICAgKi9cbiAgICBhc3luYyBpc0hlYWx0aHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vbW9kZWxzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDUwMDApIC8vIDUgc2Vjb25kIHRpbWVvdXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignSGVhbHRoIGNoZWNrIGZhaWxlZCcsIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlcnZpY2UgbmFtZSBmb3IgaGVhbHRoIGNoZWNrc1xuICAgICAqL1xuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ29wZW5haS10ZXh0LWdlbmVyYXRvcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhdmFpbGFibGUgbW9kZWxzIGZvciB0ZXh0IGdlbmVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBdmFpbGFibGVNb2RlbHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vbW9kZWxzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG1vZGVsczogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmRhdGFcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChtb2RlbCkgPT4gbW9kZWwuaWQuc3RhcnRzV2l0aCgnZ3B0LScpKVxuICAgICAgICAgICAgICAgIC5tYXAoKG1vZGVsKSA9PiBtb2RlbC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGdldCBhdmFpbGFibGUgbW9kZWxzJywge30sIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3JIYW5kbGVyLmNyZWF0ZUZyYW1ld29ya0Vycm9yKGVycm9yLCAnb3BlbmFpJywgJ2dldEF2YWlsYWJsZU1vZGVscycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgT3BlbkFJIEFQSSBmb3IgdGV4dCBjb21wbGV0aW9uXG4gICAgICovXG4gICAgYXN5bmMgY2FsbE9wZW5BSUFQSShyZXF1ZXN0LCBzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuYnVpbGRBUElQYXlsb2FkKHJlcXVlc3QsIHN0cmVhbSk7XG4gICAgICAgIC8vIPCflI0gREVUQUlMRUQgQVBJIFJFUVVFU1QgTE9HR0lOR1xuICAgICAgICBjb25zb2xlLmxvZygnXFxuPT09IPCfmoAgT1BFTkFJIEFQSSBSRVFVRVNUID09PScpO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+ToSBFbmRwb2ludDonLCBgJHt0aGlzLmJhc2VVcmx9L2NoYXQvY29tcGxldGlvbnNgKTtcbiAgICAgICAgY29uc29sZS5sb2coJ/CfpJYgTW9kZWw6JywgcGF5bG9hZC5tb2RlbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFN0cmVhbTonLCBwYXlsb2FkLnN0cmVhbSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5KsIE1lc3NhZ2VzIENvdW50OicsIHBheWxvYWQubWVzc2FnZXMubGVuZ3RoKTtcbiAgICAgICAgLy8gTG9nIG1lc3NhZ2Ugc3RydWN0dXJlXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXG7wn5OdIE1lc3NhZ2UgU3RydWN0dXJlOicpO1xuICAgICAgICBwYXlsb2FkLm1lc3NhZ2VzLmZvckVhY2goKG1zZywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICR7aW5kZXggKyAxfS4gJHttc2cucm9sZX06ICR7bXNnLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCl9JHttc2cuY29udGVudC5sZW5ndGggPiAxMDAgPyAnLi4uJyA6ICcnfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTG9nIGZ1bGwgcGF5bG9hZCAod2l0aCBjb250ZW50IHRydW5jYXRlZCBmb3IgcmVhZGFiaWxpdHkpXG4gICAgICAgIGNvbnNvbGUubG9nKCdcXG7wn5OLIENvbXBsZXRlIEpTT04gUGF5bG9hZDonKTtcbiAgICAgICAgY29uc3QgbG9nUGF5bG9hZCA9IHtcbiAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICBtZXNzYWdlczogcGF5bG9hZC5tZXNzYWdlcy5tYXAobXNnID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ubXNnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1zZy5jb250ZW50Lmxlbmd0aCA+IDIwMCA/XG4gICAgICAgICAgICAgICAgICAgIGAke21zZy5jb250ZW50LnN1YnN0cmluZygwLCAyMDApfS4uLiBbVFJVTkNBVEVEIC0gVG90YWw6ICR7bXNnLmNvbnRlbnQubGVuZ3RofSBjaGFyc11gIDpcbiAgICAgICAgICAgICAgICAgICAgbXNnLmNvbnRlbnRcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShsb2dQYXlsb2FkLCBudWxsLCAyKSk7XG4gICAgICAgIC8vIExvZyBoZWFkZXJzIChtYXNrIHNlbnNpdGl2ZSBkYXRhKVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKCk7XG4gICAgICAgIGNvbnN0IG1hc2tlZEhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBoZWFkZXJzLkF1dGhvcml6YXRpb24gPyBgQmVhcmVyICR7aGVhZGVycy5BdXRob3JpemF0aW9uLnNsaWNlKC04KX1gIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKCdcXG7wn5SQIEhlYWRlcnM6JywgbWFza2VkSGVhZGVycyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCc9PT0gRU5EIFJFUVVFU1QgPT09XFxuJyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMuY29uZmlnLnRpbWVvdXQgfHwgNjAwMDApXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLmhhbmRsZUFQSUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAvLyDwn5SNIFJFU1BPTlNFIExPR0dJTkdcbiAgICAgICAgY29uc29sZS5sb2coJ1xcbj09PSDwn5OoIE9QRU5BSSBBUEkgUkVTUE9OU0UgPT09Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgU3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn6SWIE1vZGVsIFVzZWQ6JywgZGF0YS5tb2RlbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn46vIEZpbmlzaCBSZWFzb246JywgZGF0YS5jaG9pY2VzPy5bMF0/LmZpbmlzaF9yZWFzb24pO1xuICAgICAgICBpZiAoZGF0YS51c2FnZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogVG9rZW4gVXNhZ2U6Jywge1xuICAgICAgICAgICAgICAgIHByb21wdDogZGF0YS51c2FnZS5wcm9tcHRfdG9rZW5zLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb246IGRhdGEudXNhZ2UuY29tcGxldGlvbl90b2tlbnMsXG4gICAgICAgICAgICAgICAgdG90YWw6IGRhdGEudXNhZ2UudG90YWxfdG9rZW5zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygn8J+SrCBSZXNwb25zZSBQcmV2aWV3OicsIGRhdGEuY2hvaWNlcz8uWzBdPy5tZXNzYWdlPy5jb250ZW50Py5zdWJzdHJpbmcoMCwgMjAwKSArICcuLi4nKTtcbiAgICAgICAgY29uc29sZS5sb2coJz09PSBFTkQgUkVTUE9OU0UgPT09XFxuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gT3BlbkFJIEFQSSByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbU9wZW5BSUFQSShyZXF1ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZEFQSVBheWxvYWQocmVxdWVzdCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMuY29uZmlnLnRpbWVvdXQgfHwgNjAwMDApXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLmhhbmRsZUFQSUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFzeW5jIGdlbmVyYXRvciBzdHJlYW0gZm9yIE9wZW5BSSBBUElcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVPcGVuQUlTdHJlYW0ocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5idWlsZEFQSVBheWxvYWQocmVxdWVzdCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9jaGF0L2NvbXBsZXRpb25zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnMoKSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMuY29uZmlnLnRpbWVvdXQgfHwgNjAwMDApXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLmhhbmRsZUFQSUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdHJlYW1HZW5lcmF0b3IocmVzcG9uc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHN0cmVhbWluZyByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHkgcmVhZGVyIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgbGV0IGZ1bGxUZXh0ID0gJyc7XG4gICAgICAgIGxldCBmaW5hbFJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnOyAvLyBCdWZmZXIgZm9yIGluY29tcGxldGUgbGluZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5ldyBjaHVuayB0byBidWZmZXJcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgY29tcGxldGUgbGluZXNcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgbGFzdCBwb3RlbnRpYWxseSBpbmNvbXBsZXRlIGxpbmUgaW4gdGhlIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGxpbmVzLnBvcCgpIHx8ICcnO1xuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgY29tcGxldGUgbGluZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUudHJpbSgpICYmIGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBsaW5lLnNsaWNlKDYpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHsgdHlwZTogJ2VuZCcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJycgfHwgZGF0YSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgZW1wdHkgZGF0YSBvciBoZWFydGJlYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcGFyc2VkLmNob2ljZXM/LlswXT8uZGVsdGE/LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFRleHQgKz0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtQ2h1bmsgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc3RyZWFtQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGZpbmFsIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5jaG9pY2VzPy5bMF0/LmZpbmlzaF9yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGZ1bGxUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHBhcnNlZC5tb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcGFyc2VkLmNob2ljZXNbMF0uZmluaXNoX3JlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBwYXJzZWQudXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvZyBidXQgZG9uJ3QgYnJlYWsgc3RyZWFtaW5nIGZvciBpbmRpdmlkdWFsIGNodW5rIHBhcnNlIGZhaWx1cmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1NraXBwaW5nIG1hbGZvcm1lZCBKU09OIGNodW5rIGluIGNhbGxiYWNrIHN0cmVhbScsIHsgZGF0YTogZGF0YS5zdWJzdHJpbmcoMCwgMTAwKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYW55IHJlbWFpbmluZyBkYXRhIGluIGJ1ZmZlclxuICAgICAgICAgICAgaWYgKGJ1ZmZlci50cmltKCkgJiYgYnVmZmVyLnN0YXJ0c1dpdGgoJ2RhdGE6ICcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlci5zbGljZSg2KS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09ICdbRE9ORV0nICYmIGRhdGEgIT09ICcnICYmIGRhdGEgIT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwYXJzZWQuY2hvaWNlcz8uWzBdPy5kZWx0YT8uY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFRleHQgKz0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1DaHVuayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wbGV0ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzdHJlYW1DaHVua1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgZmluYWwgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuY2hvaWNlcz8uWzBdPy5maW5pc2hfcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZnVsbFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJzZWQubW9kZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcGFyc2VkLmNob2ljZXNbMF0uZmluaXNoX3JlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2U6IHBhcnNlZC51c2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTa2lwcGluZyBmaW5hbCBtYWxmb3JtZWQgSlNPTiBjaHVuayBpbiBjYWxsYmFjayBzdHJlYW0nLCB7IGRhdGE6IGRhdGEuc3Vic3RyaW5nKDAsIDEwMCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZpbmFsUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBmaW5hbFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmdWxsVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMuY29uZmlnLm1vZGVsIHx8ICdncHQtMy41LXR1cmJvJyxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiAnc3RvcCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VuZCBmaW5hbCBjaHVua1xuICAgICAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZTogZmluYWxSZXNwb25zZS51c2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYXN5bmMgZ2VuZXJhdG9yIGZvciBzdHJlYW1pbmdcbiAgICAgKi9cbiAgICBhc3luYyAqY3JlYXRlU3RyZWFtR2VuZXJhdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXNwb25zZSBib2R5IHJlYWRlciBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGxldCBmdWxsVGV4dCA9ICcnO1xuICAgICAgICBsZXQgYnVmZmVyID0gJyc7IC8vIEJ1ZmZlciBmb3IgaW5jb21wbGV0ZSBsaW5lc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IGNodW5rIHRvIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBjb21wbGV0ZSBsaW5lc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBsYXN0IHBvdGVudGlhbGx5IGluY29tcGxldGUgbGluZSBpbiB0aGUgYnVmZmVyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBjb21wbGV0ZSBsaW5lc1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS50cmltKCkgJiYgbGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICdbRE9ORV0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZnVsbFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiAnc3RvcCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09ICcnIHx8IGRhdGEgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIGVtcHR5IGRhdGEgb3IgaGVhcnRiZWF0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHBhcnNlZC5jaG9pY2VzPy5bMF0/LmRlbHRhPy5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxUZXh0ICs9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGxldGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2cgYnV0IGRvbid0IHlpZWxkIGVycm9yIGZvciBpbmRpdmlkdWFsIGNodW5rIHBhcnNlIGZhaWx1cmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhleSBtaWdodCBiZSBkdWUgdG8gaW5jb21wbGV0ZSBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnU2tpcHBpbmcgbWFsZm9ybWVkIEpTT04gY2h1bmsnLCB7IGRhdGE6IGRhdGEuc3Vic3RyaW5nKDAsIDEwMCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGFueSByZW1haW5pbmcgZGF0YSBpbiBidWZmZXJcbiAgICAgICAgICAgIGlmIChidWZmZXIudHJpbSgpICYmIGJ1ZmZlci5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuc2xpY2UoNikudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSAnW0RPTkVdJyAmJiBkYXRhICE9PSAnJyAmJiBkYXRhICE9PSAnOicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcGFyc2VkLmNob2ljZXM/LlswXT8uZGVsdGE/LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxUZXh0ICs9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBsZXRlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1NraXBwaW5nIGZpbmFsIG1hbGZvcm1lZCBKU09OIGNodW5rJywgeyBkYXRhOiBkYXRhLnN1YnN0cmluZygwLCAxMDApIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgQVBJIHBheWxvYWQgZm9yIE9wZW5BSVxuICAgICAqL1xuICAgIGJ1aWxkQVBJUGF5bG9hZChyZXF1ZXN0LCBzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgLy8gQWRkIHN5c3RlbSBwcm9tcHQgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHJlcXVlc3Quc3lzdGVtUHJvbXB0KSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiByZXF1ZXN0LnN5c3RlbVByb21wdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNvbnZlcnNhdGlvbiBoaXN0b3J5IGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChyZXF1ZXN0LmNvbnZlcnNhdGlvbkhpc3RvcnkgJiYgcmVxdWVzdC5jb252ZXJzYXRpb25IaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goLi4ucmVxdWVzdC5jb252ZXJzYXRpb25IaXN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGN1cnJlbnQgdXNlciBtZXNzYWdlXG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgY29udGVudDogcmVxdWVzdC5wcm9tcHRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gcmVxdWVzdC5tb2RlbCB8fCB0aGlzLmNvbmZpZy5tb2RlbCB8fCAnZ3B0LTMuNS10dXJibyc7XG4gICAgICAgIC8vIExvZyB0aGUgbW9kZWwgYmVpbmcgdXNlZCBmb3IgZGVidWdnaW5nXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1VzaW5nIG1vZGVsIGZvciBBUEkgcmVxdWVzdCcsIHtcbiAgICAgICAgICAgIHJlcXVlc3RlZE1vZGVsOiByZXF1ZXN0Lm1vZGVsLFxuICAgICAgICAgICAgY29uZmlnTW9kZWw6IHRoaXMuY29uZmlnLm1vZGVsLFxuICAgICAgICAgICAgZmluYWxNb2RlbDogbW9kZWxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgc3RyZWFtXG4gICAgICAgIH07XG4gICAgICAgIC8vIFVzZSB0aGUgY29ycmVjdCBwYXJhbWV0ZXIgbmFtZSBiYXNlZCBvbiB0aGUgbW9kZWxcbiAgICAgICAgaWYgKHJlcXVlc3QubWF4VG9rZW5zKSB7XG4gICAgICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgnbzMnKSB8fCBtb2RlbC5zdGFydHNXaXRoKCdvMicpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ28xJykpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXdlciBtb2RlbHMgdXNlIG1heF9jb21wbGV0aW9uX3Rva2Vuc1xuICAgICAgICAgICAgICAgIHBheWxvYWQubWF4X2NvbXBsZXRpb25fdG9rZW5zID0gcmVxdWVzdC5tYXhUb2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbGRlciBtb2RlbHMgdXNlIG1heF90b2tlbnNcbiAgICAgICAgICAgICAgICBwYXlsb2FkLm1heF90b2tlbnMgPSByZXF1ZXN0Lm1heFRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGVtcGVyYXR1cmUgcGFyYW1ldGVyXG4gICAgICAgIGlmIChyZXF1ZXN0LnRlbXBlcmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdvMycpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ28yJykgfHwgbW9kZWwuc3RhcnRzV2l0aCgnbzEnKSkge1xuICAgICAgICAgICAgICAgIC8vIG8zIG1vZGVscyBvbmx5IHN1cHBvcnQgdGVtcGVyYXR1cmUgPSAxIChkZWZhdWx0KVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRlbXBlcmF0dXJlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQudGVtcGVyYXR1cmUgPSByZXF1ZXN0LnRlbXBlcmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0ZW1wZXJhdHVyZSBpcyBub3QgMSwgZG9uJ3QgaW5jbHVkZSBpdCAodXNlIGRlZmF1bHQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbGRlciBtb2RlbHMgc3VwcG9ydCBhbnkgdGVtcGVyYXR1cmUgdmFsdWVcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnRlbXBlcmF0dXJlID0gcmVxdWVzdC50ZW1wZXJhdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIE9wZW5BSSBBUEkgcmVzcG9uc2UgdG8gZnJhbWV3b3JrIGZvcm1hdFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGEuY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICBtb2RlbDogZGF0YS5tb2RlbCxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogZGF0YS5jaG9pY2VzWzBdLmZpbmlzaF9yZWFzb24sXG4gICAgICAgICAgICB1c2FnZTogZGF0YS51c2FnZSA/IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGRhdGEudXNhZ2UucHJvbXB0X3Rva2VucyxcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBkYXRhLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zLFxuICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBkYXRhLnVzYWdlLnRvdGFsX3Rva2Vuc1xuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgQVBJIGVycm9ycyBhbmQgY29udmVydCB0byBmcmFtZXdvcmsgZXJyb3JzXG4gICAgICovXG4gICAgYXN5bmMgaGFuZGxlQVBJRXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclR5cGVzXzEuQXV0aGVudGljYXRpb25FcnJvcignSW52YWxpZCBPcGVuQUkgQVBJIGtleScsICdvcGVuYWknKTtcbiAgICAgICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JUeXBlc18xLlJhdGVMaW1pdEVycm9yKCdPcGVuQUkgQVBJIHJhdGUgbGltaXQgZXhjZWVkZWQnLCAnb3BlbmFpJyk7XG4gICAgICAgICAgICBjYXNlIDQwMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5WYWxpZGF0aW9uRXJyb3IoYE9wZW5BSSBBUEkgdmFsaWRhdGlvbiBlcnJvcjogJHtlcnJvckJvZHl9YCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JUeXBlc18xLk5ldHdvcmtFcnJvcihgT3BlbkFJIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7ZXJyb3JCb2R5fWAsICdvcGVuYWknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgSFRUUCBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHNcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaUtleX1gXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5vcmdhbml6YXRpb24pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ09wZW5BSS1Pcmdhbml6YXRpb24nXSA9IHRoaXMuY29uZmlnLm9yZ2FuaXphdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIHZhbGlkYXRlQ29uZmlnKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yVHlwZXNfMS5WYWxpZGF0aW9uRXJyb3IoJ09wZW5BSSBBUEkga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk9wZW5BSVRleHRHZW5lcmF0b3IgPSBPcGVuQUlUZXh0R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3BlbkFJVGV4dEdlbmVyYXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAITextGenerator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// OpenAI Adapter Module\n// Exports all OpenAI-related adapters and factories\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createOpenAIServiceFactories = exports.OpenAIImageGeneratorFactory = exports.OpenAITextGeneratorFactory = exports.OpenAIImageGenerator = exports.OpenAITextGenerator = void 0;\nvar OpenAITextGenerator_1 = __webpack_require__(/*! ./OpenAITextGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAITextGenerator.js\");\nObject.defineProperty(exports, \"OpenAITextGenerator\", ({ enumerable: true, get: function () { return OpenAITextGenerator_1.OpenAITextGenerator; } }));\nvar OpenAIImageGenerator_1 = __webpack_require__(/*! ./OpenAIImageGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIImageGenerator.js\");\nObject.defineProperty(exports, \"OpenAIImageGenerator\", ({ enumerable: true, get: function () { return OpenAIImageGenerator_1.OpenAIImageGenerator; } }));\nvar OpenAIServiceFactory_1 = __webpack_require__(/*! ./OpenAIServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/OpenAIServiceFactory.js\");\nObject.defineProperty(exports, \"OpenAITextGeneratorFactory\", ({ enumerable: true, get: function () { return OpenAIServiceFactory_1.OpenAITextGeneratorFactory; } }));\nObject.defineProperty(exports, \"OpenAIImageGeneratorFactory\", ({ enumerable: true, get: function () { return OpenAIServiceFactory_1.OpenAIImageGeneratorFactory; } }));\nObject.defineProperty(exports, \"createOpenAIServiceFactories\", ({ enumerable: true, get: function () { return OpenAIServiceFactory_1.createOpenAIServiceFactories; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL29wZW5haS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0NBQW9DLEdBQUcsbUNBQW1DLEdBQUcsa0NBQWtDLEdBQUcsNEJBQTRCLEdBQUcsMkJBQTJCO0FBQzVLLDRCQUE0QixtQkFBTyxDQUFDLHdJQUF1QjtBQUMzRCx1REFBc0QsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDbkosNkJBQTZCLG1CQUFPLENBQUMsMElBQXdCO0FBQzdELHdEQUF1RCxFQUFFLHFDQUFxQyx1REFBdUQsRUFBQztBQUN0Siw2QkFBNkIsbUJBQU8sQ0FBQywwSUFBd0I7QUFDN0QsOERBQTZELEVBQUUscUNBQXFDLDZEQUE2RCxFQUFDO0FBQ2xLLCtEQUE4RCxFQUFFLHFDQUFxQyw4REFBOEQsRUFBQztBQUNwSyxnRUFBK0QsRUFBRSxxQ0FBcUMsK0RBQStELEVBQUM7QUFDdEsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL29wZW5haS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIE9wZW5BSSBBZGFwdGVyIE1vZHVsZVxuLy8gRXhwb3J0cyBhbGwgT3BlbkFJLXJlbGF0ZWQgYWRhcHRlcnMgYW5kIGZhY3Rvcmllc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVPcGVuQUlTZXJ2aWNlRmFjdG9yaWVzID0gZXhwb3J0cy5PcGVuQUlJbWFnZUdlbmVyYXRvckZhY3RvcnkgPSBleHBvcnRzLk9wZW5BSVRleHRHZW5lcmF0b3JGYWN0b3J5ID0gZXhwb3J0cy5PcGVuQUlJbWFnZUdlbmVyYXRvciA9IGV4cG9ydHMuT3BlbkFJVGV4dEdlbmVyYXRvciA9IHZvaWQgMDtcbnZhciBPcGVuQUlUZXh0R2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9PcGVuQUlUZXh0R2VuZXJhdG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3BlbkFJVGV4dEdlbmVyYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT3BlbkFJVGV4dEdlbmVyYXRvcl8xLk9wZW5BSVRleHRHZW5lcmF0b3I7IH0gfSk7XG52YXIgT3BlbkFJSW1hZ2VHZW5lcmF0b3JfMSA9IHJlcXVpcmUoXCIuL09wZW5BSUltYWdlR2VuZXJhdG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3BlbkFJSW1hZ2VHZW5lcmF0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9wZW5BSUltYWdlR2VuZXJhdG9yXzEuT3BlbkFJSW1hZ2VHZW5lcmF0b3I7IH0gfSk7XG52YXIgT3BlbkFJU2VydmljZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL09wZW5BSVNlcnZpY2VGYWN0b3J5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3BlbkFJVGV4dEdlbmVyYXRvckZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9wZW5BSVNlcnZpY2VGYWN0b3J5XzEuT3BlbkFJVGV4dEdlbmVyYXRvckZhY3Rvcnk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPcGVuQUlJbWFnZUdlbmVyYXRvckZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9wZW5BSVNlcnZpY2VGYWN0b3J5XzEuT3BlbkFJSW1hZ2VHZW5lcmF0b3JGYWN0b3J5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlT3BlbkFJU2VydmljZUZhY3Rvcmllc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT3BlbkFJU2VydmljZUZhY3RvcnlfMS5jcmVhdGVPcGVuQUlTZXJ2aWNlRmFjdG9yaWVzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/PuppeteerWebScraper.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/PuppeteerWebScraper.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Puppeteer Web Scraper Adapter\n// Implements the IWebScraper interface using Puppeteer for web scraping\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PuppeteerWebScraper = void 0;\nclass PuppeteerWebScraper {\n    constructor() {\n        this.browser = null;\n        this.visitedUrls = new Set();\n        this.baseUrl = '';\n    }\n    async getBrowser() {\n        if (!this.browser) {\n            const puppeteer = await Promise.resolve().then(() => __importStar(__webpack_require__(/*! puppeteer */ \"puppeteer\")));\n            this.browser = await puppeteer.default.launch({\n                headless: true,\n                args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-web-security']\n            });\n        }\n        return this.browser;\n    }\n    async closeBrowser() {\n        if (this.browser) {\n            await this.browser.close();\n            this.browser = null;\n        }\n    }\n    isInternalLink(url, baseUrl) {\n        try {\n            const urlObj = new URL(url);\n            const baseUrlObj = new URL(baseUrl);\n            // Same hostname check\n            if (urlObj.hostname !== baseUrlObj.hostname) {\n                return false;\n            }\n            // Skip if it's just a hash fragment of the same page\n            if (urlObj.pathname === baseUrlObj.pathname && urlObj.hash && !urlObj.search) {\n                return false;\n            }\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    normalizeUrl(url) {\n        try {\n            const urlObj = new URL(url);\n            // Remove hash fragments to avoid treating #section as different page\n            urlObj.hash = '';\n            // Remove trailing slashes for consistency\n            if (urlObj.pathname.endsWith('/') && urlObj.pathname.length > 1) {\n                urlObj.pathname = urlObj.pathname.slice(0, -1);\n            }\n            return urlObj.toString();\n        }\n        catch {\n            return url;\n        }\n    }\n    async scrapeSinglePage(url, options) {\n        try {\n            const browser = await this.getBrowser();\n            const page = await browser.newPage();\n            // Set user agent to avoid being blocked\n            await page.evaluateOnNewDocument(() => {\n                Object.defineProperty(navigator, 'webdriver', {\n                    get: () => undefined,\n                });\n            });\n            // Navigate to the page\n            await page.goto(url, {\n                waitUntil: 'networkidle2',\n                timeout: 30000\n            });\n            // Wait for specific selector if provided\n            if (options?.selector) {\n                try {\n                    await page.waitForSelector(options.selector, { timeout: 10000 });\n                }\n                catch (error) {\n                    // Continue even if selector is not found\n                }\n            }\n            // Wait for specified time if provided\n            if (options?.waitFor) {\n                await new Promise(resolve => setTimeout(resolve, options.waitFor));\n            }\n            // Extract content\n            const content = await page.content();\n            const title = await page.title();\n            // Extract images if requested\n            let images = [];\n            if (options?.includeImages) {\n                images = await page.evaluate(() => {\n                    const imgElements = document.querySelectorAll('img');\n                    return Array.from(imgElements)\n                        .map(img => img.src)\n                        .filter(src => src && src.startsWith('http'))\n                        .slice(0, 10); // Limit to first 10 images\n                });\n            }\n            // Extract links if requested\n            let links = [];\n            if (options?.followLinks) {\n                links = await page.evaluate((currentUrl) => {\n                    const linkElements = document.querySelectorAll('a[href]');\n                    const allLinks = Array.from(linkElements)\n                        .map(link => {\n                        const href = link.getAttribute('href');\n                        if (!href)\n                            return null;\n                        // Skip hash-only links, mailto, tel, javascript links\n                        if (href.startsWith('#') || href.startsWith('mailto:') ||\n                            href.startsWith('tel:') || href.startsWith('javascript:')) {\n                            return null;\n                        }\n                        // Resolve relative URLs to absolute URLs\n                        try {\n                            return new URL(href, currentUrl).toString();\n                        }\n                        catch {\n                            return null;\n                        }\n                    })\n                        .filter(href => href !== null);\n                    // Remove duplicates and return all links (not just first 20)\n                    return Array.from(new Set(allLinks));\n                }, url);\n                // Prioritize navigation and content links over footer/utility links\n                const prioritizedLinks = links.filter(link => {\n                    try {\n                        const linkUrl = new URL(link);\n                        const pathname = linkUrl.pathname.toLowerCase();\n                        // Skip common utility pages that rarely contain useful content\n                        const skipPatterns = [\n                            '/privacy', '/terms', '/cookie', '/legal', '/disclaimer',\n                            '/sitemap.xml', '/robots.txt', '/wp-admin', '/admin',\n                            '.pdf', '.doc', '.zip', '.exe', '.dmg'\n                        ];\n                        return !skipPatterns.some(pattern => pathname.includes(pattern));\n                    }\n                    catch {\n                        return false;\n                    }\n                });\n                links = prioritizedLinks;\n            }\n            // Extract metadata\n            const metadata = await page.evaluate(() => {\n                const meta = {};\n                const metaElements = document.querySelectorAll('meta');\n                metaElements.forEach(element => {\n                    const name = element.getAttribute('name') || element.getAttribute('property');\n                    const content = element.getAttribute('content');\n                    if (name && content) {\n                        meta[name] = content;\n                    }\n                });\n                return meta;\n            });\n            await page.close();\n            return {\n                url,\n                title,\n                content,\n                images,\n                links,\n                metadata,\n                scrapedAt: new Date(),\n                depth: options?.depth || 1,\n                parentUrl: options?.parentUrl\n            };\n        }\n        catch (error) {\n            console.error(`Failed to scrape ${url}:`, error);\n            return null;\n        }\n    }\n    /**\n     * Scrape content from a single webpage\n     */\n    async scrapePage(request) {\n        try {\n            const result = await this.scrapeSinglePage(request.url, {\n                selector: request.selector,\n                waitFor: request.waitFor,\n                includeImages: request.includeImages,\n                followLinks: request.followLinks,\n                depth: 1\n            });\n            if (!result) {\n                return {\n                    success: false,\n                    error: 'Failed to scrape the page'\n                };\n            }\n            const response = {\n                url: result.url,\n                title: result.title,\n                content: result.content,\n                images: result.images,\n                links: result.links,\n                metadata: result.metadata,\n                scrapedAt: result.scrapedAt\n            };\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            await this.closeBrowser();\n            return {\n                success: false,\n                error: `Web scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    }\n    /**\n     * Scrape multiple pages in batch\n     */\n    async scrapePages(requests) {\n        try {\n            const results = [];\n            for (const request of requests) {\n                const result = await this.scrapePage(request);\n                if (result.success && result.data) {\n                    results.push(result.data);\n                }\n            }\n            return {\n                success: true,\n                data: results\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Batch web scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    }\n    /**\n     * Scrape a website with multiple pages (following links) - NEW METHOD\n     */\n    async scrapeSite(baseUrl, options) {\n        try {\n            console.log(`Scraping single page: ${baseUrl.toString()}`);\n            // Simply scrape the single page provided\n            const result = await this.scrapeSinglePage(baseUrl.toString(), {\n                includeImages: true,\n                followLinks: false, // Disable link following for single page mode\n                depth: 1\n            });\n            if (!result) {\n                return {\n                    success: false,\n                    error: 'Failed to scrape the page'\n                };\n            }\n            // Convert to response format\n            const response = {\n                url: result.url,\n                title: result.title,\n                content: result.content,\n                images: result.images,\n                links: result.links,\n                metadata: result.metadata,\n                scrapedAt: result.scrapedAt\n            };\n            console.log(`Successfully scraped: ${response.url}`);\n            console.log(`Content length: ${response.content?.length || 0} characters`);\n            return {\n                success: true,\n                data: [response] // Return single page as array for consistency\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Page scraping failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    }\n    /**\n     * Extract specific data using CSS selectors\n     */\n    async extractData(url, selectors) {\n        try {\n            const browser = await this.getBrowser();\n            const page = await browser.newPage();\n            await page.goto(url, {\n                waitUntil: 'networkidle2',\n                timeout: 30000\n            });\n            const extractedData = await page.evaluate((sel) => {\n                const data = {};\n                for (const [fieldName, selector] of Object.entries(sel)) {\n                    const elements = document.querySelectorAll(selector);\n                    if (elements.length === 1) {\n                        data[fieldName] = elements[0].textContent?.trim() || '';\n                    }\n                    else if (elements.length > 1) {\n                        data[fieldName] = Array.from(elements).map(el => el.textContent?.trim() || '');\n                    }\n                    else {\n                        data[fieldName] = '';\n                    }\n                }\n                return data;\n            }, selectors);\n            await page.close();\n            return {\n                success: true,\n                data: extractedData\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Data extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    }\n    /**\n     * Check if a webpage is scrapable\n     */\n    async isScrapable(url) {\n        try {\n            const browser = await this.getBrowser();\n            const page = await browser.newPage();\n            const startTime = Date.now();\n            const response = await page.goto(url, {\n                waitUntil: 'domcontentloaded',\n                timeout: 10000\n            });\n            const responseTime = Date.now() - startTime;\n            const statusCode = response?.status() || 0;\n            const accessible = statusCode >= 200 && statusCode < 400;\n            // Check robots.txt (simplified check)\n            let robotsAllowed = true;\n            try {\n                const robotsUrl = new URL('/robots.txt', url).toString();\n                const robotsResponse = await page.goto(robotsUrl, { timeout: 5000 });\n                if (robotsResponse?.ok()) {\n                    const robotsContent = await robotsResponse.text();\n                    robotsAllowed = !robotsContent.includes('User-agent: *') ||\n                        !robotsContent.includes('Disallow: /');\n                }\n            }\n            catch (error) {\n                // If robots.txt is not accessible, assume it's allowed\n                robotsAllowed = true;\n            }\n            await page.close();\n            return {\n                success: true,\n                data: {\n                    accessible,\n                    robotsAllowed,\n                    responseTime,\n                    statusCode\n                }\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Scrapability check failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    }\n    /**\n     * Get page metadata without full scraping\n     */\n    async getPageMetadata(url) {\n        try {\n            const browser = await this.getBrowser();\n            const page = await browser.newPage();\n            await page.goto(url, {\n                waitUntil: 'domcontentloaded',\n                timeout: 15000\n            });\n            const metadata = await page.evaluate(() => {\n                const meta = {};\n                // Basic metadata\n                meta.title = document.title;\n                meta.description = document.querySelector('meta[name=\"description\"]')?.getAttribute('content') || '';\n                meta.keywords = document.querySelector('meta[name=\"keywords\"]')?.getAttribute('content')?.split(',').map(k => k.trim()) || [];\n                meta.author = document.querySelector('meta[name=\"author\"]')?.getAttribute('content') || '';\n                // Social media tags\n                meta.socialMediaTags = {};\n                const socialSelectors = [\n                    'meta[property=\"og:title\"]',\n                    'meta[property=\"og:description\"]',\n                    'meta[property=\"og:image\"]',\n                    'meta[property=\"og:url\"]',\n                    'meta[name=\"twitter:title\"]',\n                    'meta[name=\"twitter:description\"]',\n                    'meta[name=\"twitter:image\"]'\n                ];\n                socialSelectors.forEach(selector => {\n                    const element = document.querySelector(selector);\n                    if (element) {\n                        const property = element.getAttribute('property') || element.getAttribute('name');\n                        const content = element.getAttribute('content');\n                        if (property && content) {\n                            meta.socialMediaTags[property] = content;\n                        }\n                    }\n                });\n                return meta;\n            });\n            await page.close();\n            return {\n                success: true,\n                data: metadata\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Metadata extraction failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n            };\n        }\n    }\n    /**\n     * Check if the service is healthy\n     */\n    async isHealthy() {\n        try {\n            const browser = await this.getBrowser();\n            const page = await browser.newPage();\n            await page.goto('https://example.com', { timeout: 5000 });\n            await page.close();\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Cleanup resources\n     */\n    async cleanup() {\n        await this.closeBrowser();\n    }\n}\nexports.PuppeteerWebScraper = PuppeteerWebScraper;\n//# sourceMappingURL=PuppeteerWebScraper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmFwaW5nL1B1cHBldGVlcldlYlNjcmFwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLG1CQUFPLENBQUMsNEJBQVc7QUFDakc7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxnQkFBZ0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5REFBeUQ7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx5REFBeUQ7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlELDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5REFBeUQ7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx5REFBeUQ7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxlQUFlO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCx5REFBeUQ7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5REFBeUQ7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9zY3JhcGluZy9QdXBwZXRlZXJXZWJTY3JhcGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gUHVwcGV0ZWVyIFdlYiBTY3JhcGVyIEFkYXB0ZXJcbi8vIEltcGxlbWVudHMgdGhlIElXZWJTY3JhcGVyIGludGVyZmFjZSB1c2luZyBQdXBwZXRlZXIgZm9yIHdlYiBzY3JhcGluZ1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB1cHBldGVlcldlYlNjcmFwZXIgPSB2b2lkIDA7XG5jbGFzcyBQdXBwZXRlZXJXZWJTY3JhcGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5icm93c2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpdGVkVXJscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gJyc7XG4gICAgfVxuICAgIGFzeW5jIGdldEJyb3dzZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5icm93c2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwdXBwZXRlZXIgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKCdwdXBwZXRlZXInKSkpO1xuICAgICAgICAgICAgdGhpcy5icm93c2VyID0gYXdhaXQgcHVwcGV0ZWVyLmRlZmF1bHQubGF1bmNoKHtcbiAgICAgICAgICAgICAgICBoZWFkbGVzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJy0tbm8tc2FuZGJveCcsICctLWRpc2FibGUtc2V0dWlkLXNhbmRib3gnLCAnLS1kaXNhYmxlLXdlYi1zZWN1cml0eSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZUJyb3dzZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmJyb3dzZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYnJvd3Nlci5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5icm93c2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0ludGVybmFsTGluayh1cmwsIGJhc2VVcmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VVcmxPYmogPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgICAgICAgLy8gU2FtZSBob3N0bmFtZSBjaGVja1xuICAgICAgICAgICAgaWYgKHVybE9iai5ob3N0bmFtZSAhPT0gYmFzZVVybE9iai5ob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgaWYgaXQncyBqdXN0IGEgaGFzaCBmcmFnbWVudCBvZiB0aGUgc2FtZSBwYWdlXG4gICAgICAgICAgICBpZiAodXJsT2JqLnBhdGhuYW1lID09PSBiYXNlVXJsT2JqLnBhdGhuYW1lICYmIHVybE9iai5oYXNoICYmICF1cmxPYmouc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vcm1hbGl6ZVVybCh1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBoYXNoIGZyYWdtZW50cyB0byBhdm9pZCB0cmVhdGluZyAjc2VjdGlvbiBhcyBkaWZmZXJlbnQgcGFnZVxuICAgICAgICAgICAgdXJsT2JqLmhhc2ggPSAnJztcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzIGZvciBjb25zaXN0ZW5jeVxuICAgICAgICAgICAgaWYgKHVybE9iai5wYXRobmFtZS5lbmRzV2l0aCgnLycpICYmIHVybE9iai5wYXRobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdXJsT2JqLnBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmxPYmoudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNjcmFwZVNpbmdsZVBhZ2UodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBicm93c2VyID0gYXdhaXQgdGhpcy5nZXRCcm93c2VyKCk7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgYnJvd3Nlci5uZXdQYWdlKCk7XG4gICAgICAgICAgICAvLyBTZXQgdXNlciBhZ2VudCB0byBhdm9pZCBiZWluZyBibG9ja2VkXG4gICAgICAgICAgICBhd2FpdCBwYWdlLmV2YWx1YXRlT25OZXdEb2N1bWVudCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgJ3dlYmRyaXZlcicsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRvIHRoZSBwYWdlXG4gICAgICAgICAgICBhd2FpdCBwYWdlLmdvdG8odXJsLCB7XG4gICAgICAgICAgICAgICAgd2FpdFVudGlsOiAnbmV0d29ya2lkbGUyJyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiAzMDAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBzcGVjaWZpYyBzZWxlY3RvciBpZiBwcm92aWRlZFxuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGFnZS53YWl0Rm9yU2VsZWN0b3Iob3B0aW9ucy5zZWxlY3RvciwgeyB0aW1lb3V0OiAxMDAwMCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgc2VsZWN0b3IgaXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FpdCBmb3Igc3BlY2lmaWVkIHRpbWUgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy53YWl0Rm9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG9wdGlvbnMud2FpdEZvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXh0cmFjdCBjb250ZW50XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcGFnZS5jb250ZW50KCk7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGF3YWl0IHBhZ2UudGl0bGUoKTtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgaW1hZ2VzIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgbGV0IGltYWdlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LmluY2x1ZGVJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICBpbWFnZXMgPSBhd2FpdCBwYWdlLmV2YWx1YXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaW1nRWxlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGltZyA9PiBpbWcuc3JjKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihzcmMgPT4gc3JjICYmIHNyYy5zdGFydHNXaXRoKCdodHRwJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgMTApOyAvLyBMaW1pdCB0byBmaXJzdCAxMCBpbWFnZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgbGlua3MgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBsZXQgbGlua3MgPSBbXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5mb2xsb3dMaW5rcykge1xuICAgICAgICAgICAgICAgIGxpbmtzID0gYXdhaXQgcGFnZS5ldmFsdWF0ZSgoY3VycmVudFVybCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW2hyZWZdJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbExpbmtzID0gQXJyYXkuZnJvbShsaW5rRWxlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhyZWYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGhhc2gtb25seSBsaW5rcywgbWFpbHRvLCB0ZWwsIGphdmFzY3JpcHQgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChocmVmLnN0YXJ0c1dpdGgoJyMnKSB8fCBocmVmLnN0YXJ0c1dpdGgoJ21haWx0bzonKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWYuc3RhcnRzV2l0aCgndGVsOicpIHx8IGhyZWYuc3RhcnRzV2l0aCgnamF2YXNjcmlwdDonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSByZWxhdGl2ZSBVUkxzIHRvIGFic29sdXRlIFVSTHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgY3VycmVudFVybCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaHJlZiA9PiBocmVmICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIHJldHVybiBhbGwgbGlua3MgKG5vdCBqdXN0IGZpcnN0IDIwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFsbExpbmtzKSk7XG4gICAgICAgICAgICAgICAgfSwgdXJsKTtcbiAgICAgICAgICAgICAgICAvLyBQcmlvcml0aXplIG5hdmlnYXRpb24gYW5kIGNvbnRlbnQgbGlua3Mgb3ZlciBmb290ZXIvdXRpbGl0eSBsaW5rc1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW9yaXRpemVkTGlua3MgPSBsaW5rcy5maWx0ZXIobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rVXJsID0gbmV3IFVSTChsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gbGlua1VybC5wYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBjb21tb24gdXRpbGl0eSBwYWdlcyB0aGF0IHJhcmVseSBjb250YWluIHVzZWZ1bCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lwUGF0dGVybnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wcml2YWN5JywgJy90ZXJtcycsICcvY29va2llJywgJy9sZWdhbCcsICcvZGlzY2xhaW1lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9zaXRlbWFwLnhtbCcsICcvcm9ib3RzLnR4dCcsICcvd3AtYWRtaW4nLCAnL2FkbWluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLnBkZicsICcuZG9jJywgJy56aXAnLCAnLmV4ZScsICcuZG1nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2tpcFBhdHRlcm5zLnNvbWUocGF0dGVybiA9PiBwYXRobmFtZS5pbmNsdWRlcyhwYXR0ZXJuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlua3MgPSBwcmlvcml0aXplZExpbmtzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXh0cmFjdCBtZXRhZGF0YVxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBwYWdlLmV2YWx1YXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbWV0YScpO1xuICAgICAgICAgICAgICAgIG1ldGFFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJvcGVydHknKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFbbmFtZV0gPSBjb250ZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgaW1hZ2VzLFxuICAgICAgICAgICAgICAgIGxpbmtzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHNjcmFwZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBkZXB0aDogb3B0aW9ucz8uZGVwdGggfHwgMSxcbiAgICAgICAgICAgICAgICBwYXJlbnRVcmw6IG9wdGlvbnM/LnBhcmVudFVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzY3JhcGUgJHt1cmx9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcmFwZSBjb250ZW50IGZyb20gYSBzaW5nbGUgd2VicGFnZVxuICAgICAqL1xuICAgIGFzeW5jIHNjcmFwZVBhZ2UocmVxdWVzdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zY3JhcGVTaW5nbGVQYWdlKHJlcXVlc3QudXJsLCB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IHJlcXVlc3Quc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgd2FpdEZvcjogcmVxdWVzdC53YWl0Rm9yLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVJbWFnZXM6IHJlcXVlc3QuaW5jbHVkZUltYWdlcyxcbiAgICAgICAgICAgICAgICBmb2xsb3dMaW5rczogcmVxdWVzdC5mb2xsb3dMaW5rcyxcbiAgICAgICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBzY3JhcGUgdGhlIHBhZ2UnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHVybDogcmVzdWx0LnVybCxcbiAgICAgICAgICAgICAgICB0aXRsZTogcmVzdWx0LnRpdGxlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3VsdC5jb250ZW50LFxuICAgICAgICAgICAgICAgIGltYWdlczogcmVzdWx0LmltYWdlcyxcbiAgICAgICAgICAgICAgICBsaW5rczogcmVzdWx0LmxpbmtzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByZXN1bHQubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgc2NyYXBlZEF0OiByZXN1bHQuc2NyYXBlZEF0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbG9zZUJyb3dzZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBXZWIgc2NyYXBpbmcgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NyYXBlIG11bHRpcGxlIHBhZ2VzIGluIGJhdGNoXG4gICAgICovXG4gICAgYXN5bmMgc2NyYXBlUGFnZXMocmVxdWVzdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2NyYXBlUGFnZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBCYXRjaCB3ZWIgc2NyYXBpbmcgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NyYXBlIGEgd2Vic2l0ZSB3aXRoIG11bHRpcGxlIHBhZ2VzIChmb2xsb3dpbmcgbGlua3MpIC0gTkVXIE1FVEhPRFxuICAgICAqL1xuICAgIGFzeW5jIHNjcmFwZVNpdGUoYmFzZVVybCwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFNjcmFwaW5nIHNpbmdsZSBwYWdlOiAke2Jhc2VVcmwudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIC8vIFNpbXBseSBzY3JhcGUgdGhlIHNpbmdsZSBwYWdlIHByb3ZpZGVkXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNjcmFwZVNpbmdsZVBhZ2UoYmFzZVVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZUltYWdlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmb2xsb3dMaW5rczogZmFsc2UsIC8vIERpc2FibGUgbGluayBmb2xsb3dpbmcgZm9yIHNpbmdsZSBwYWdlIG1vZGVcbiAgICAgICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBzY3JhcGUgdGhlIHBhZ2UnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcmVzcG9uc2UgZm9ybWF0XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHJlc3VsdC51cmwsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHJlc3VsdC50aXRsZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiByZXN1bHQuY29udGVudCxcbiAgICAgICAgICAgICAgICBpbWFnZXM6IHJlc3VsdC5pbWFnZXMsXG4gICAgICAgICAgICAgICAgbGlua3M6IHJlc3VsdC5saW5rcyxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogcmVzdWx0Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHNjcmFwZWRBdDogcmVzdWx0LnNjcmFwZWRBdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgc2NyYXBlZDogJHtyZXNwb25zZS51cmx9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQ29udGVudCBsZW5ndGg6ICR7cmVzcG9uc2UuY29udGVudD8ubGVuZ3RoIHx8IDB9IGNoYXJhY3RlcnNgKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBbcmVzcG9uc2VdIC8vIFJldHVybiBzaW5nbGUgcGFnZSBhcyBhcnJheSBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgUGFnZSBzY3JhcGluZyBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHNwZWNpZmljIGRhdGEgdXNpbmcgQ1NTIHNlbGVjdG9yc1xuICAgICAqL1xuICAgIGFzeW5jIGV4dHJhY3REYXRhKHVybCwgc2VsZWN0b3JzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBicm93c2VyID0gYXdhaXQgdGhpcy5nZXRCcm93c2VyKCk7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgYnJvd3Nlci5uZXdQYWdlKCk7XG4gICAgICAgICAgICBhd2FpdCBwYWdlLmdvdG8odXJsLCB7XG4gICAgICAgICAgICAgICAgd2FpdFVudGlsOiAnbmV0d29ya2lkbGUyJyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiAzMDAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBleHRyYWN0ZWREYXRhID0gYXdhaXQgcGFnZS5ldmFsdWF0ZSgoc2VsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgc2VsZWN0b3JdIG9mIE9iamVjdC5lbnRyaWVzKHNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtmaWVsZE5hbWVdID0gZWxlbWVudHNbMF0udGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gPSBBcnJheS5mcm9tKGVsZW1lbnRzKS5tYXAoZWwgPT4gZWwudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkTmFtZV0gPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH0sIHNlbGVjdG9ycyk7XG4gICAgICAgICAgICBhd2FpdCBwYWdlLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZXh0cmFjdGVkRGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBEYXRhIGV4dHJhY3Rpb24gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB3ZWJwYWdlIGlzIHNjcmFwYWJsZVxuICAgICAqL1xuICAgIGFzeW5jIGlzU2NyYXBhYmxlKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHRoaXMuZ2V0QnJvd3NlcigpO1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcGFnZS5nb3RvKHVybCwge1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogJ2RvbWNvbnRlbnRsb2FkZWQnLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDEwMDAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzcG9uc2U/LnN0YXR1cygpIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NpYmxlID0gc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDQwMDtcbiAgICAgICAgICAgIC8vIENoZWNrIHJvYm90cy50eHQgKHNpbXBsaWZpZWQgY2hlY2spXG4gICAgICAgICAgICBsZXQgcm9ib3RzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvYm90c1VybCA9IG5ldyBVUkwoJy9yb2JvdHMudHh0JywgdXJsKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvYm90c1Jlc3BvbnNlID0gYXdhaXQgcGFnZS5nb3RvKHJvYm90c1VybCwgeyB0aW1lb3V0OiA1MDAwIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyb2JvdHNSZXNwb25zZT8ub2soKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb2JvdHNDb250ZW50ID0gYXdhaXQgcm9ib3RzUmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByb2JvdHNBbGxvd2VkID0gIXJvYm90c0NvbnRlbnQuaW5jbHVkZXMoJ1VzZXItYWdlbnQ6IConKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXJvYm90c0NvbnRlbnQuaW5jbHVkZXMoJ0Rpc2FsbG93OiAvJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcm9ib3RzLnR4dCBpcyBub3QgYWNjZXNzaWJsZSwgYXNzdW1lIGl0J3MgYWxsb3dlZFxuICAgICAgICAgICAgICAgIHJvYm90c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgcGFnZS5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzaWJsZSxcbiAgICAgICAgICAgICAgICAgICAgcm9ib3RzQWxsb3dlZCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBTY3JhcGFiaWxpdHkgY2hlY2sgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHBhZ2UgbWV0YWRhdGEgd2l0aG91dCBmdWxsIHNjcmFwaW5nXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGFnZU1ldGFkYXRhKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHRoaXMuZ2V0QnJvd3NlcigpO1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICAgICAgICAgICAgYXdhaXQgcGFnZS5nb3RvKHVybCwge1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogJ2RvbWNvbnRlbnRsb2FkZWQnLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDE1MDAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgcGFnZS5ldmFsdWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIEJhc2ljIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgbWV0YS50aXRsZSA9IGRvY3VtZW50LnRpdGxlO1xuICAgICAgICAgICAgICAgIG1ldGEuZGVzY3JpcHRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJkZXNjcmlwdGlvblwiXScpPy5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSB8fCAnJztcbiAgICAgICAgICAgICAgICBtZXRhLmtleXdvcmRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwia2V5d29yZHNcIl0nKT8uZ2V0QXR0cmlidXRlKCdjb250ZW50Jyk/LnNwbGl0KCcsJykubWFwKGsgPT4gay50cmltKCkpIHx8IFtdO1xuICAgICAgICAgICAgICAgIG1ldGEuYXV0aG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiYXV0aG9yXCJdJyk/LmdldEF0dHJpYnV0ZSgnY29udGVudCcpIHx8ICcnO1xuICAgICAgICAgICAgICAgIC8vIFNvY2lhbCBtZWRpYSB0YWdzXG4gICAgICAgICAgICAgICAgbWV0YS5zb2NpYWxNZWRpYVRhZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb2NpYWxTZWxlY3RvcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICdtZXRhW3Byb3BlcnR5PVwib2c6dGl0bGVcIl0nLFxuICAgICAgICAgICAgICAgICAgICAnbWV0YVtwcm9wZXJ0eT1cIm9nOmRlc2NyaXB0aW9uXCJdJyxcbiAgICAgICAgICAgICAgICAgICAgJ21ldGFbcHJvcGVydHk9XCJvZzppbWFnZVwiXScsXG4gICAgICAgICAgICAgICAgICAgICdtZXRhW3Byb3BlcnR5PVwib2c6dXJsXCJdJyxcbiAgICAgICAgICAgICAgICAgICAgJ21ldGFbbmFtZT1cInR3aXR0ZXI6dGl0bGVcIl0nLFxuICAgICAgICAgICAgICAgICAgICAnbWV0YVtuYW1lPVwidHdpdHRlcjpkZXNjcmlwdGlvblwiXScsXG4gICAgICAgICAgICAgICAgICAgICdtZXRhW25hbWU9XCJ0d2l0dGVyOmltYWdlXCJdJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgc29jaWFsU2VsZWN0b3JzLmZvckVhY2goc2VsZWN0b3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwcm9wZXJ0eScpIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAmJiBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YS5zb2NpYWxNZWRpYVRhZ3NbcHJvcGVydHldID0gY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBwYWdlLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogbWV0YWRhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgTWV0YWRhdGEgZXh0cmFjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc2VydmljZSBpcyBoZWFsdGh5XG4gICAgICovXG4gICAgYXN5bmMgaXNIZWFsdGh5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHRoaXMuZ2V0QnJvd3NlcigpO1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IGF3YWl0IGJyb3dzZXIubmV3UGFnZSgpO1xuICAgICAgICAgICAgYXdhaXQgcGFnZS5nb3RvKCdodHRwczovL2V4YW1wbGUuY29tJywgeyB0aW1lb3V0OiA1MDAwIH0pO1xuICAgICAgICAgICAgYXdhaXQgcGFnZS5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW51cCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBhc3luYyBjbGVhbnVwKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmNsb3NlQnJvd3NlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHVwcGV0ZWVyV2ViU2NyYXBlciA9IFB1cHBldGVlcldlYlNjcmFwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QdXBwZXRlZXJXZWJTY3JhcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/PuppeteerWebScraper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/WebScrapingServiceFactory.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/WebScrapingServiceFactory.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WebScrapingServiceFactory = void 0;\nexports.createWebScrapingServiceFactory = createWebScrapingServiceFactory;\nconst PuppeteerWebScraper_1 = __webpack_require__(/*! ./PuppeteerWebScraper */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/PuppeteerWebScraper.js\");\nclass WebScrapingServiceFactory {\n    create(config, logger) {\n        return new PuppeteerWebScraper_1.PuppeteerWebScraper();\n    }\n    getServiceName() {\n        return 'webScraper';\n    }\n}\nexports.WebScrapingServiceFactory = WebScrapingServiceFactory;\n// Helper function to create web scraping service factory\nfunction createWebScrapingServiceFactory() {\n    return new WebScrapingServiceFactory();\n}\n//# sourceMappingURL=WebScrapingServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmFwaW5nL1dlYlNjcmFwaW5nU2VydmljZUZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDO0FBQ2pDLHVDQUF1QztBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQywwSUFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9zY3JhcGluZy9XZWJTY3JhcGluZ1NlcnZpY2VGYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJTY3JhcGluZ1NlcnZpY2VGYWN0b3J5ID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVXZWJTY3JhcGluZ1NlcnZpY2VGYWN0b3J5ID0gY3JlYXRlV2ViU2NyYXBpbmdTZXJ2aWNlRmFjdG9yeTtcbmNvbnN0IFB1cHBldGVlcldlYlNjcmFwZXJfMSA9IHJlcXVpcmUoXCIuL1B1cHBldGVlcldlYlNjcmFwZXJcIik7XG5jbGFzcyBXZWJTY3JhcGluZ1NlcnZpY2VGYWN0b3J5IHtcbiAgICBjcmVhdGUoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQdXBwZXRlZXJXZWJTY3JhcGVyXzEuUHVwcGV0ZWVyV2ViU2NyYXBlcigpO1xuICAgIH1cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd3ZWJTY3JhcGVyJztcbiAgICB9XG59XG5leHBvcnRzLldlYlNjcmFwaW5nU2VydmljZUZhY3RvcnkgPSBXZWJTY3JhcGluZ1NlcnZpY2VGYWN0b3J5O1xuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSB3ZWIgc2NyYXBpbmcgc2VydmljZSBmYWN0b3J5XG5mdW5jdGlvbiBjcmVhdGVXZWJTY3JhcGluZ1NlcnZpY2VGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgV2ViU2NyYXBpbmdTZXJ2aWNlRmFjdG9yeSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2ViU2NyYXBpbmdTZXJ2aWNlRmFjdG9yeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/WebScrapingServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/index.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Scraping Adapters\n// Web scraping implementations for the hexagonal framework\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./PuppeteerWebScraper */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/PuppeteerWebScraper.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WebScrapingServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/WebScrapingServiceFactory.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmFwaW5nL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsMElBQXVCO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQyxzSkFBNkI7QUFDbEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmFwaW5nL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gU2NyYXBpbmcgQWRhcHRlcnNcbi8vIFdlYiBzY3JhcGluZyBpbXBsZW1lbnRhdGlvbnMgZm9yIHRoZSBoZXhhZ29uYWwgZnJhbWV3b3JrXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9QdXBwZXRlZXJXZWJTY3JhcGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9XZWJTY3JhcGluZ1NlcnZpY2VGYWN0b3J5XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/PuppeteerScreenshotCapture.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/PuppeteerScreenshotCapture.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Puppeteer Screenshot Capture Adapter\n// Implements IScreenshotCapture using Puppeteer for full page screenshots\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PuppeteerScreenshotCapture = void 0;\nconst ErrorTypes_1 = __webpack_require__(/*! ../../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass PuppeteerScreenshotCapture {\n    constructor(config, logger, errorHandler) {\n        this.puppeteer = null;\n        this.browser = null;\n        this.config = config;\n        this.logger = logger.child ? logger.child({ service: 'puppeteer-screenshot' }) : logger;\n        this.errorHandler = errorHandler;\n        this.validateConfig();\n    }\n    /**\n     * Capture a full page screenshot\n     */\n    async captureScreenshot(request) {\n        this.logger.info('Starting screenshot capture', { url: request.url });\n        try {\n            const response = await this.errorHandler.executeWithRetry(() => this.performScreenshot(request), { service: 'puppeteer', operation: 'captureScreenshot' });\n            this.logger.info('Screenshot capture completed', {\n                url: request.url,\n                dimensions: response.dimensions\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'puppeteer', 'captureScreenshot');\n            this.logger.error('Screenshot capture failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Capture multiple screenshots in batch\n     */\n    async captureScreenshots(requests) {\n        this.logger.info('Starting batch screenshot capture', { count: requests.length });\n        try {\n            const results = [];\n            for (const request of requests) {\n                const result = await this.captureScreenshot(request);\n                if (result.success && result.data) {\n                    results.push(result.data);\n                }\n                else {\n                    this.logger.warn('Screenshot failed in batch', { url: request.url, error: result.error });\n                }\n            }\n            this.logger.info('Batch screenshot capture completed', {\n                successful: results.length,\n                total: requests.length\n            });\n            return {\n                success: true,\n                data: results\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'puppeteer', 'captureScreenshots');\n            this.logger.error('Batch screenshot capture failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Capture screenshot of a specific element on the page\n     */\n    async captureElement(url, selector, options) {\n        this.logger.info('Starting element screenshot capture', { url, selector });\n        try {\n            const request = {\n                url,\n                ...options\n            };\n            const response = await this.errorHandler.executeWithRetry(() => this.performElementScreenshot(request, selector), { service: 'puppeteer', operation: 'captureElement' });\n            this.logger.info('Element screenshot capture completed', {\n                url,\n                selector,\n                dimensions: response.dimensions\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'puppeteer', 'captureElement');\n            this.logger.error('Element screenshot capture failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Capture screenshot with custom viewport size\n     */\n    async captureWithViewport(url, viewport, options) {\n        this.logger.info('Starting viewport screenshot capture', { url, viewport });\n        try {\n            const request = {\n                url,\n                width: viewport.width,\n                height: viewport.height,\n                ...options\n            };\n            const response = await this.errorHandler.executeWithRetry(() => this.performScreenshot(request), { service: 'puppeteer', operation: 'captureWithViewport' });\n            this.logger.info('Viewport screenshot capture completed', {\n                url,\n                viewport,\n                dimensions: response.dimensions\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'puppeteer', 'captureWithViewport');\n            this.logger.error('Viewport screenshot capture failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Capture screenshot after waiting for specific content\n     */\n    async captureAfterCondition(url, waitCondition, options) {\n        this.logger.info('Starting conditional screenshot capture', { url, waitCondition });\n        try {\n            const request = {\n                url,\n                waitFor: typeof waitCondition.value === 'number' ? waitCondition.value : undefined,\n                ...options\n            };\n            const response = await this.errorHandler.executeWithRetry(() => this.performConditionalScreenshot(request, waitCondition), { service: 'puppeteer', operation: 'captureAfterCondition' });\n            this.logger.info('Conditional screenshot capture completed', {\n                url,\n                waitCondition,\n                dimensions: response.dimensions\n            });\n            return {\n                success: true,\n                data: response\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'puppeteer', 'captureAfterCondition');\n            this.logger.error('Conditional screenshot capture failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Get supported screenshot formats and options\n     */\n    async getSupportedFormats() {\n        return {\n            formats: [\n                { format: 'png', mimeType: 'image/png', supportsQuality: false },\n                { format: 'jpeg', mimeType: 'image/jpeg', supportsQuality: true },\n                { format: 'webp', mimeType: 'image/webp', supportsQuality: true }\n            ],\n            maxWidth: 3840, // 4K width\n            maxHeight: 2160 // 4K height\n        };\n    }\n    /**\n     * Check if the service is available and configured properly\n     */\n    async isHealthy() {\n        try {\n            // Try to launch a browser instance to test if Puppeteer is working\n            const browser = await this.getBrowser();\n            const page = await browser.newPage();\n            await page.goto('data:text/html,<html><body>Test</body></html>');\n            await page.close();\n            return true;\n        }\n        catch (error) {\n            this.logger.warn('Health check failed', { error: error.message });\n            return false;\n        }\n    }\n    /**\n     * Get service name for health checks\n     */\n    getServiceName() {\n        return 'puppeteer-screenshot-capture';\n    }\n    /**\n     * Perform the actual screenshot capture\n     */\n    async performScreenshot(request) {\n        const browser = await this.getBrowser();\n        const page = await browser.newPage();\n        try {\n            // Set viewport if specified\n            if (request.width && request.height) {\n                await page.setViewport({ width: request.width, height: request.height });\n            }\n            else if (this.config.viewport) {\n                await page.setViewport(this.config.viewport);\n            }\n            // Set user agent if configured\n            if (this.config.userAgent) {\n                await page.setUserAgent(this.config.userAgent);\n            }\n            // Navigate to the URL\n            await page.goto(request.url, {\n                waitUntil: 'networkidle2',\n                timeout: this.config.timeout || 30000\n            });\n            // Wait if specified\n            if (request.waitFor) {\n                await new Promise(resolve => setTimeout(resolve, request.waitFor));\n            }\n            // Take screenshot\n            const screenshotOptions = {\n                type: request.format || 'png',\n                fullPage: request.fullPage !== false // Default to full page\n            };\n            if (request.quality && (request.format === 'jpeg' || request.format === 'webp')) {\n                screenshotOptions.quality = request.quality;\n            }\n            const buffer = await page.screenshot(screenshotOptions);\n            // Get page dimensions\n            const dimensions = await page.evaluate(() => ({\n                width: document.documentElement.scrollWidth,\n                height: document.documentElement.scrollHeight\n            }));\n            return {\n                image: {\n                    id: `screenshot_${Date.now()}`,\n                    name: `screenshot_${Date.now()}.${request.format || 'png'}`,\n                    buffer: buffer,\n                    mimeType: this.getMimeType(request.format || 'png'),\n                    size: buffer.length,\n                    createdAt: new Date()\n                },\n                url: request.url,\n                dimensions\n            };\n        }\n        finally {\n            await page.close();\n        }\n    }\n    /**\n     * Perform element-specific screenshot\n     */\n    async performElementScreenshot(request, selector) {\n        const browser = await this.getBrowser();\n        const page = await browser.newPage();\n        try {\n            // Set viewport if specified\n            if (request.width && request.height) {\n                await page.setViewport({ width: request.width, height: request.height });\n            }\n            else if (this.config.viewport) {\n                await page.setViewport(this.config.viewport);\n            }\n            // Navigate to the URL\n            await page.goto(request.url, {\n                waitUntil: 'networkidle2',\n                timeout: this.config.timeout || 30000\n            });\n            // Wait for the element to be present\n            await page.waitForSelector(selector, { timeout: this.config.timeout || 30000 });\n            // Take screenshot of the element\n            const element = await page.$(selector);\n            if (!element) {\n                throw new Error(`Element with selector \"${selector}\" not found`);\n            }\n            const screenshotOptions = {\n                type: request.format || 'png'\n            };\n            if (request.quality && (request.format === 'jpeg' || request.format === 'webp')) {\n                screenshotOptions.quality = request.quality;\n            }\n            const buffer = await element.screenshot(screenshotOptions);\n            // Get element dimensions\n            const dimensions = await element.boundingBox();\n            if (!dimensions) {\n                throw new Error('Could not get element dimensions');\n            }\n            return {\n                image: {\n                    id: `element_screenshot_${Date.now()}`,\n                    name: `element_screenshot_${Date.now()}.${request.format || 'png'}`,\n                    buffer: buffer,\n                    mimeType: this.getMimeType(request.format || 'png'),\n                    size: buffer.length,\n                    createdAt: new Date()\n                },\n                url: request.url,\n                dimensions: {\n                    width: Math.round(dimensions.width),\n                    height: Math.round(dimensions.height)\n                }\n            };\n        }\n        finally {\n            await page.close();\n        }\n    }\n    /**\n     * Perform conditional screenshot capture\n     */\n    async performConditionalScreenshot(request, waitCondition) {\n        const browser = await this.getBrowser();\n        const page = await browser.newPage();\n        try {\n            // Set viewport if specified\n            if (request.width && request.height) {\n                await page.setViewport({ width: request.width, height: request.height });\n            }\n            else if (this.config.viewport) {\n                await page.setViewport(this.config.viewport);\n            }\n            // Navigate to the URL\n            await page.goto(request.url, {\n                waitUntil: 'networkidle2',\n                timeout: this.config.timeout || 30000\n            });\n            // Wait based on condition type\n            switch (waitCondition.type) {\n                case 'selector':\n                    await page.waitForSelector(waitCondition.value, {\n                        timeout: this.config.timeout || 30000\n                    });\n                    break;\n                case 'timeout':\n                    await new Promise(resolve => setTimeout(resolve, waitCondition.value));\n                    break;\n                case 'networkIdle':\n                    await page.waitForNetworkIdle({\n                        idleTime: waitCondition.value,\n                        timeout: this.config.timeout || 30000\n                    });\n                    break;\n            }\n            // Take screenshot\n            const screenshotOptions = {\n                type: request.format || 'png',\n                fullPage: request.fullPage !== false\n            };\n            if (request.quality && (request.format === 'jpeg' || request.format === 'webp')) {\n                screenshotOptions.quality = request.quality;\n            }\n            const buffer = await page.screenshot(screenshotOptions);\n            // Get page dimensions\n            const dimensions = await page.evaluate(() => ({\n                width: document.documentElement.scrollWidth,\n                height: document.documentElement.scrollHeight\n            }));\n            return {\n                image: {\n                    id: `conditional_screenshot_${Date.now()}`,\n                    name: `conditional_screenshot_${Date.now()}.${request.format || 'png'}`,\n                    buffer: buffer,\n                    mimeType: this.getMimeType(request.format || 'png'),\n                    size: buffer.length,\n                    createdAt: new Date()\n                },\n                url: request.url,\n                dimensions\n            };\n        }\n        finally {\n            await page.close();\n        }\n    }\n    /**\n     * Get or create browser instance\n     */\n    async getBrowser() {\n        if (!this.browser) {\n            if (!this.puppeteer) {\n                // Dynamically import puppeteer\n                this.puppeteer = await Promise.resolve().then(() => __importStar(__webpack_require__(/*! puppeteer */ \"puppeteer\")));\n            }\n            this.browser = await this.puppeteer.launch({\n                headless: this.config.headless !== false, // Default to headless\n                args: [\n                    '--no-sandbox',\n                    '--disable-setuid-sandbox',\n                    '--disable-dev-shm-usage',\n                    '--disable-accelerated-2d-canvas',\n                    '--no-first-run',\n                    '--no-zygote',\n                    '--disable-gpu'\n                ]\n            });\n        }\n        return this.browser;\n    }\n    /**\n     * Get MIME type for image format\n     */\n    getMimeType(format) {\n        switch (format) {\n            case 'png': return 'image/png';\n            case 'jpeg': return 'image/jpeg';\n            case 'webp': return 'image/webp';\n            default: return 'image/png';\n        }\n    }\n    /**\n     * Validate configuration\n     */\n    validateConfig() {\n        if (!this.config) {\n            throw new ErrorTypes_1.ValidationError('Screenshot configuration is required');\n        }\n        if (this.config.viewport) {\n            if (this.config.viewport.width <= 0 || this.config.viewport.height <= 0) {\n                throw new ErrorTypes_1.ValidationError('Viewport dimensions must be positive numbers');\n            }\n        }\n        if (this.config.timeout && this.config.timeout <= 0) {\n            throw new ErrorTypes_1.ValidationError('Timeout must be a positive number');\n        }\n    }\n    /**\n     * Cleanup resources\n     */\n    async dispose() {\n        if (this.browser) {\n            await this.browser.close();\n            this.browser = null;\n        }\n    }\n}\nexports.PuppeteerScreenshotCapture = PuppeteerScreenshotCapture;\n//# sourceMappingURL=PuppeteerScreenshotCapture.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmVlbnNob3QvUHVwcGV0ZWVyU2NyZWVuc2hvdENhcHR1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQztBQUNsQyxxQkFBcUIsbUJBQU8sQ0FBQyxnSUFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxpQ0FBaUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0EsK0dBQStHLHNEQUFzRDtBQUNySztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsK0JBQStCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHVDQUF1QztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLCtCQUErQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxlQUFlO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0ksbURBQW1EO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLCtCQUErQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxlQUFlO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLHdEQUF3RDtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwrQkFBK0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0JBQW9CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlJQUF5SSwwREFBMEQ7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsK0JBQStCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBOEQ7QUFDaEYsa0JBQWtCLCtEQUErRDtBQUNqRixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHNCQUFzQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOENBQThDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRCx3Q0FBd0MsV0FBVyxHQUFHLHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhDQUE4QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbURBQW1ELHVDQUF1QztBQUMxRjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RCxnREFBZ0QsV0FBVyxHQUFHLHdCQUF3QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDhDQUE4QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdELG9EQUFvRCxXQUFXLEdBQUcsd0JBQXdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixtQkFBTyxDQUFDLDRCQUFXO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvc2NyZWVuc2hvdC9QdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFB1cHBldGVlciBTY3JlZW5zaG90IENhcHR1cmUgQWRhcHRlclxuLy8gSW1wbGVtZW50cyBJU2NyZWVuc2hvdENhcHR1cmUgdXNpbmcgUHVwcGV0ZWVyIGZvciBmdWxsIHBhZ2Ugc2NyZWVuc2hvdHNcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZSA9IHZvaWQgMDtcbmNvbnN0IEVycm9yVHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3R5cGVzL0Vycm9yVHlwZXNcIik7XG5jbGFzcyBQdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBsb2dnZXIsIGVycm9ySGFuZGxlcikge1xuICAgICAgICB0aGlzLnB1cHBldGVlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJvd3NlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlci5jaGlsZCA/IGxvZ2dlci5jaGlsZCh7IHNlcnZpY2U6ICdwdXBwZXRlZXItc2NyZWVuc2hvdCcgfSkgOiBsb2dnZXI7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZmlnKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcHR1cmUgYSBmdWxsIHBhZ2Ugc2NyZWVuc2hvdFxuICAgICAqL1xuICAgIGFzeW5jIGNhcHR1cmVTY3JlZW5zaG90KHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU3RhcnRpbmcgc2NyZWVuc2hvdCBjYXB0dXJlJywgeyB1cmw6IHJlcXVlc3QudXJsIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmVycm9ySGFuZGxlci5leGVjdXRlV2l0aFJldHJ5KCgpID0+IHRoaXMucGVyZm9ybVNjcmVlbnNob3QocmVxdWVzdCksIHsgc2VydmljZTogJ3B1cHBldGVlcicsIG9wZXJhdGlvbjogJ2NhcHR1cmVTY3JlZW5zaG90JyB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1NjcmVlbnNob3QgY2FwdHVyZSBjb21wbGV0ZWQnLCB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiByZXNwb25zZS5kaW1lbnNpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1ld29ya0Vycm9yID0gdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLCAncHVwcGV0ZWVyJywgJ2NhcHR1cmVTY3JlZW5zaG90Jyk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignU2NyZWVuc2hvdCBjYXB0dXJlIGZhaWxlZCcsIHsgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2UgfSwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIG11bHRpcGxlIHNjcmVlbnNob3RzIGluIGJhdGNoXG4gICAgICovXG4gICAgYXN5bmMgY2FwdHVyZVNjcmVlbnNob3RzKHJlcXVlc3RzKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGJhdGNoIHNjcmVlbnNob3QgY2FwdHVyZScsIHsgY291bnQ6IHJlcXVlc3RzLmxlbmd0aCB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FwdHVyZVNjcmVlbnNob3QocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdTY3JlZW5zaG90IGZhaWxlZCBpbiBiYXRjaCcsIHsgdXJsOiByZXF1ZXN0LnVybCwgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdCYXRjaCBzY3JlZW5zaG90IGNhcHR1cmUgY29tcGxldGVkJywge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NmdWw6IHJlc3VsdHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRvdGFsOiByZXF1ZXN0cy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXdvcmtFcnJvciA9IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgJ3B1cHBldGVlcicsICdjYXB0dXJlU2NyZWVuc2hvdHMnKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdCYXRjaCBzY3JlZW5zaG90IGNhcHR1cmUgZmFpbGVkJywgeyBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZSB9LCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcHR1cmUgc2NyZWVuc2hvdCBvZiBhIHNwZWNpZmljIGVsZW1lbnQgb24gdGhlIHBhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBjYXB0dXJlRWxlbWVudCh1cmwsIHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGVsZW1lbnQgc2NyZWVuc2hvdCBjYXB0dXJlJywgeyB1cmwsIHNlbGVjdG9yIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5lcnJvckhhbmRsZXIuZXhlY3V0ZVdpdGhSZXRyeSgoKSA9PiB0aGlzLnBlcmZvcm1FbGVtZW50U2NyZWVuc2hvdChyZXF1ZXN0LCBzZWxlY3RvciksIHsgc2VydmljZTogJ3B1cHBldGVlcicsIG9wZXJhdGlvbjogJ2NhcHR1cmVFbGVtZW50JyB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0VsZW1lbnQgc2NyZWVuc2hvdCBjYXB0dXJlIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcmVzcG9uc2UuZGltZW5zaW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXdvcmtFcnJvciA9IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgJ3B1cHBldGVlcicsICdjYXB0dXJlRWxlbWVudCcpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0VsZW1lbnQgc2NyZWVuc2hvdCBjYXB0dXJlIGZhaWxlZCcsIHsgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2UgfSwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIHNjcmVlbnNob3Qgd2l0aCBjdXN0b20gdmlld3BvcnQgc2l6ZVxuICAgICAqL1xuICAgIGFzeW5jIGNhcHR1cmVXaXRoVmlld3BvcnQodXJsLCB2aWV3cG9ydCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyB2aWV3cG9ydCBzY3JlZW5zaG90IGNhcHR1cmUnLCB7IHVybCwgdmlld3BvcnQgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5lcnJvckhhbmRsZXIuZXhlY3V0ZVdpdGhSZXRyeSgoKSA9PiB0aGlzLnBlcmZvcm1TY3JlZW5zaG90KHJlcXVlc3QpLCB7IHNlcnZpY2U6ICdwdXBwZXRlZXInLCBvcGVyYXRpb246ICdjYXB0dXJlV2l0aFZpZXdwb3J0JyB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1ZpZXdwb3J0IHNjcmVlbnNob3QgY2FwdHVyZSBjb21wbGV0ZWQnLCB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0LFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHJlc3BvbnNlLmRpbWVuc2lvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZnJhbWV3b3JrRXJyb3IgPSB0aGlzLmVycm9ySGFuZGxlci5oYW5kbGUoZXJyb3IsICdwdXBwZXRlZXInLCAnY2FwdHVyZVdpdGhWaWV3cG9ydCcpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1ZpZXdwb3J0IHNjcmVlbnNob3QgY2FwdHVyZSBmYWlsZWQnLCB7IGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlIH0sIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZSBzY3JlZW5zaG90IGFmdGVyIHdhaXRpbmcgZm9yIHNwZWNpZmljIGNvbnRlbnRcbiAgICAgKi9cbiAgICBhc3luYyBjYXB0dXJlQWZ0ZXJDb25kaXRpb24odXJsLCB3YWl0Q29uZGl0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1N0YXJ0aW5nIGNvbmRpdGlvbmFsIHNjcmVlbnNob3QgY2FwdHVyZScsIHsgdXJsLCB3YWl0Q29uZGl0aW9uIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgd2FpdEZvcjogdHlwZW9mIHdhaXRDb25kaXRpb24udmFsdWUgPT09ICdudW1iZXInID8gd2FpdENvbmRpdGlvbi52YWx1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmVycm9ySGFuZGxlci5leGVjdXRlV2l0aFJldHJ5KCgpID0+IHRoaXMucGVyZm9ybUNvbmRpdGlvbmFsU2NyZWVuc2hvdChyZXF1ZXN0LCB3YWl0Q29uZGl0aW9uKSwgeyBzZXJ2aWNlOiAncHVwcGV0ZWVyJywgb3BlcmF0aW9uOiAnY2FwdHVyZUFmdGVyQ29uZGl0aW9uJyB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NvbmRpdGlvbmFsIHNjcmVlbnNob3QgY2FwdHVyZSBjb21wbGV0ZWQnLCB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHdhaXRDb25kaXRpb24sXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcmVzcG9uc2UuZGltZW5zaW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXdvcmtFcnJvciA9IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgJ3B1cHBldGVlcicsICdjYXB0dXJlQWZ0ZXJDb25kaXRpb24nKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdDb25kaXRpb25hbCBzY3JlZW5zaG90IGNhcHR1cmUgZmFpbGVkJywgeyBlcnJvcjogZnJhbWV3b3JrRXJyb3IubWVzc2FnZSB9LCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzdXBwb3J0ZWQgc2NyZWVuc2hvdCBmb3JtYXRzIGFuZCBvcHRpb25zXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3VwcG9ydGVkRm9ybWF0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdHM6IFtcbiAgICAgICAgICAgICAgICB7IGZvcm1hdDogJ3BuZycsIG1pbWVUeXBlOiAnaW1hZ2UvcG5nJywgc3VwcG9ydHNRdWFsaXR5OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIHsgZm9ybWF0OiAnanBlZycsIG1pbWVUeXBlOiAnaW1hZ2UvanBlZycsIHN1cHBvcnRzUXVhbGl0eTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIHsgZm9ybWF0OiAnd2VicCcsIG1pbWVUeXBlOiAnaW1hZ2Uvd2VicCcsIHN1cHBvcnRzUXVhbGl0eTogdHJ1ZSB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbWF4V2lkdGg6IDM4NDAsIC8vIDRLIHdpZHRoXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IDIxNjAgLy8gNEsgaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBzZXJ2aWNlIGlzIGF2YWlsYWJsZSBhbmQgY29uZmlndXJlZCBwcm9wZXJseVxuICAgICAqL1xuICAgIGFzeW5jIGlzSGVhbHRoeSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBsYXVuY2ggYSBicm93c2VyIGluc3RhbmNlIHRvIHRlc3QgaWYgUHVwcGV0ZWVyIGlzIHdvcmtpbmdcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXIgPSBhd2FpdCB0aGlzLmdldEJyb3dzZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuZ290bygnZGF0YTp0ZXh0L2h0bWwsPGh0bWw+PGJvZHk+VGVzdDwvYm9keT48L2h0bWw+Jyk7XG4gICAgICAgICAgICBhd2FpdCBwYWdlLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0hlYWx0aCBjaGVjayBmYWlsZWQnLCB7IGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZXJ2aWNlIG5hbWUgZm9yIGhlYWx0aCBjaGVja3NcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdwdXBwZXRlZXItc2NyZWVuc2hvdC1jYXB0dXJlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB0aGUgYWN0dWFsIHNjcmVlbnNob3QgY2FwdHVyZVxuICAgICAqL1xuICAgIGFzeW5jIHBlcmZvcm1TY3JlZW5zaG90KHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGF3YWl0IHRoaXMuZ2V0QnJvd3NlcigpO1xuICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgYnJvd3Nlci5uZXdQYWdlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTZXQgdmlld3BvcnQgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAocmVxdWVzdC53aWR0aCAmJiByZXF1ZXN0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHBhZ2Uuc2V0Vmlld3BvcnQoeyB3aWR0aDogcmVxdWVzdC53aWR0aCwgaGVpZ2h0OiByZXF1ZXN0LmhlaWdodCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFnZS5zZXRWaWV3cG9ydCh0aGlzLmNvbmZpZy52aWV3cG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdXNlciBhZ2VudCBpZiBjb25maWd1cmVkXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcudXNlckFnZW50KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFnZS5zZXRVc2VyQWdlbnQodGhpcy5jb25maWcudXNlckFnZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRvIHRoZSBVUkxcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuZ290byhyZXF1ZXN0LnVybCwge1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogJ25ldHdvcmtpZGxlMicsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWcudGltZW91dCB8fCAzMDAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXYWl0IGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgaWYgKHJlcXVlc3Qud2FpdEZvcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXF1ZXN0LndhaXRGb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRha2Ugc2NyZWVuc2hvdFxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuc2hvdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcmVxdWVzdC5mb3JtYXQgfHwgJ3BuZycsXG4gICAgICAgICAgICAgICAgZnVsbFBhZ2U6IHJlcXVlc3QuZnVsbFBhZ2UgIT09IGZhbHNlIC8vIERlZmF1bHQgdG8gZnVsbCBwYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QucXVhbGl0eSAmJiAocmVxdWVzdC5mb3JtYXQgPT09ICdqcGVnJyB8fCByZXF1ZXN0LmZvcm1hdCA9PT0gJ3dlYnAnKSkge1xuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RPcHRpb25zLnF1YWxpdHkgPSByZXF1ZXN0LnF1YWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBwYWdlLnNjcmVlbnNob3Qoc2NyZWVuc2hvdE9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gR2V0IHBhZ2UgZGltZW5zaW9uc1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IHBhZ2UuZXZhbHVhdGUoKCkgPT4gKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgICAgICBpZDogYHNjcmVlbnNob3RfJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBzY3JlZW5zaG90XyR7RGF0ZS5ub3coKX0uJHtyZXF1ZXN0LmZvcm1hdCB8fCAncG5nJ31gLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHRoaXMuZ2V0TWltZVR5cGUocmVxdWVzdC5mb3JtYXQgfHwgJ3BuZycpLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGVsZW1lbnQtc3BlY2lmaWMgc2NyZWVuc2hvdFxuICAgICAqL1xuICAgIGFzeW5jIHBlcmZvcm1FbGVtZW50U2NyZWVuc2hvdChyZXF1ZXN0LCBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBicm93c2VyID0gYXdhaXQgdGhpcy5nZXRCcm93c2VyKCk7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNldCB2aWV3cG9ydCBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LndpZHRoICYmIHJlcXVlc3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFnZS5zZXRWaWV3cG9ydCh7IHdpZHRoOiByZXF1ZXN0LndpZHRoLCBoZWlnaHQ6IHJlcXVlc3QuaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcudmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwYWdlLnNldFZpZXdwb3J0KHRoaXMuY29uZmlnLnZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRvIHRoZSBVUkxcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuZ290byhyZXF1ZXN0LnVybCwge1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogJ25ldHdvcmtpZGxlMicsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWcudGltZW91dCB8fCAzMDAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgZWxlbWVudCB0byBiZSBwcmVzZW50XG4gICAgICAgICAgICBhd2FpdCBwYWdlLndhaXRGb3JTZWxlY3RvcihzZWxlY3RvciwgeyB0aW1lb3V0OiB0aGlzLmNvbmZpZy50aW1lb3V0IHx8IDMwMDAwIH0pO1xuICAgICAgICAgICAgLy8gVGFrZSBzY3JlZW5zaG90IG9mIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gYXdhaXQgcGFnZS4kKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRWxlbWVudCB3aXRoIHNlbGVjdG9yIFwiJHtzZWxlY3Rvcn1cIiBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjcmVlbnNob3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHJlcXVlc3QuZm9ybWF0IHx8ICdwbmcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QucXVhbGl0eSAmJiAocmVxdWVzdC5mb3JtYXQgPT09ICdqcGVnJyB8fCByZXF1ZXN0LmZvcm1hdCA9PT0gJ3dlYnAnKSkge1xuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RPcHRpb25zLnF1YWxpdHkgPSByZXF1ZXN0LnF1YWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBlbGVtZW50LnNjcmVlbnNob3Qoc2NyZWVuc2hvdE9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gR2V0IGVsZW1lbnQgZGltZW5zaW9uc1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IGVsZW1lbnQuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBlbGVtZW50IGRpbWVuc2lvbnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGBlbGVtZW50X3NjcmVlbnNob3RfJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBlbGVtZW50X3NjcmVlbnNob3RfJHtEYXRlLm5vdygpfS4ke3JlcXVlc3QuZm9ybWF0IHx8ICdwbmcnfWAsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogdGhpcy5nZXRNaW1lVHlwZShyZXF1ZXN0LmZvcm1hdCB8fCAncG5nJyksXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKGRpbWVuc2lvbnMud2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQoZGltZW5zaW9ucy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGNvbmRpdGlvbmFsIHNjcmVlbnNob3QgY2FwdHVyZVxuICAgICAqL1xuICAgIGFzeW5jIHBlcmZvcm1Db25kaXRpb25hbFNjcmVlbnNob3QocmVxdWVzdCwgd2FpdENvbmRpdGlvbikge1xuICAgICAgICBjb25zdCBicm93c2VyID0gYXdhaXQgdGhpcy5nZXRCcm93c2VyKCk7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNldCB2aWV3cG9ydCBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LndpZHRoICYmIHJlcXVlc3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFnZS5zZXRWaWV3cG9ydCh7IHdpZHRoOiByZXF1ZXN0LndpZHRoLCBoZWlnaHQ6IHJlcXVlc3QuaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcudmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwYWdlLnNldFZpZXdwb3J0KHRoaXMuY29uZmlnLnZpZXdwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRvIHRoZSBVUkxcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuZ290byhyZXF1ZXN0LnVybCwge1xuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogJ25ldHdvcmtpZGxlMicsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWcudGltZW91dCB8fCAzMDAwMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXYWl0IGJhc2VkIG9uIGNvbmRpdGlvbiB0eXBlXG4gICAgICAgICAgICBzd2l0Y2ggKHdhaXRDb25kaXRpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdG9yJzpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGFnZS53YWl0Rm9yU2VsZWN0b3Iod2FpdENvbmRpdGlvbi52YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGhpcy5jb25maWcudGltZW91dCB8fCAzMDAwMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndGltZW91dCc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB3YWl0Q29uZGl0aW9uLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25ldHdvcmtJZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGFnZS53YWl0Rm9yTmV0d29ya0lkbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWU6IHdhaXRDb25kaXRpb24udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLmNvbmZpZy50aW1lb3V0IHx8IDMwMDAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRha2Ugc2NyZWVuc2hvdFxuICAgICAgICAgICAgY29uc3Qgc2NyZWVuc2hvdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcmVxdWVzdC5mb3JtYXQgfHwgJ3BuZycsXG4gICAgICAgICAgICAgICAgZnVsbFBhZ2U6IHJlcXVlc3QuZnVsbFBhZ2UgIT09IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QucXVhbGl0eSAmJiAocmVxdWVzdC5mb3JtYXQgPT09ICdqcGVnJyB8fCByZXF1ZXN0LmZvcm1hdCA9PT0gJ3dlYnAnKSkge1xuICAgICAgICAgICAgICAgIHNjcmVlbnNob3RPcHRpb25zLnF1YWxpdHkgPSByZXF1ZXN0LnF1YWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBwYWdlLnNjcmVlbnNob3Qoc2NyZWVuc2hvdE9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gR2V0IHBhZ2UgZGltZW5zaW9uc1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGF3YWl0IHBhZ2UuZXZhbHVhdGUoKCkgPT4gKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgICAgICBpZDogYGNvbmRpdGlvbmFsX3NjcmVlbnNob3RfJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBjb25kaXRpb25hbF9zY3JlZW5zaG90XyR7RGF0ZS5ub3coKX0uJHtyZXF1ZXN0LmZvcm1hdCB8fCAncG5nJ31gLFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHRoaXMuZ2V0TWltZVR5cGUocmVxdWVzdC5mb3JtYXQgfHwgJ3BuZycpLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHBhZ2UuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGJyb3dzZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhc3luYyBnZXRCcm93c2VyKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnJvd3Nlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnB1cHBldGVlcikge1xuICAgICAgICAgICAgICAgIC8vIER5bmFtaWNhbGx5IGltcG9ydCBwdXBwZXRlZXJcbiAgICAgICAgICAgICAgICB0aGlzLnB1cHBldGVlciA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gX19pbXBvcnRTdGFyKHJlcXVpcmUoJ3B1cHBldGVlcicpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJyb3dzZXIgPSBhd2FpdCB0aGlzLnB1cHBldGVlci5sYXVuY2goe1xuICAgICAgICAgICAgICAgIGhlYWRsZXNzOiB0aGlzLmNvbmZpZy5oZWFkbGVzcyAhPT0gZmFsc2UsIC8vIERlZmF1bHQgdG8gaGVhZGxlc3NcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICctLW5vLXNhbmRib3gnLFxuICAgICAgICAgICAgICAgICAgICAnLS1kaXNhYmxlLXNldHVpZC1zYW5kYm94JyxcbiAgICAgICAgICAgICAgICAgICAgJy0tZGlzYWJsZS1kZXYtc2htLXVzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgJy0tZGlzYWJsZS1hY2NlbGVyYXRlZC0yZC1jYW52YXMnLFxuICAgICAgICAgICAgICAgICAgICAnLS1uby1maXJzdC1ydW4nLFxuICAgICAgICAgICAgICAgICAgICAnLS1uby16eWdvdGUnLFxuICAgICAgICAgICAgICAgICAgICAnLS1kaXNhYmxlLWdwdSdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgTUlNRSB0eXBlIGZvciBpbWFnZSBmb3JtYXRcbiAgICAgKi9cbiAgICBnZXRNaW1lVHlwZShmb3JtYXQpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BuZyc6IHJldHVybiAnaW1hZ2UvcG5nJztcbiAgICAgICAgICAgIGNhc2UgJ2pwZWcnOiByZXR1cm4gJ2ltYWdlL2pwZWcnO1xuICAgICAgICAgICAgY2FzZSAnd2VicCc6IHJldHVybiAnaW1hZ2Uvd2VicCc7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gJ2ltYWdlL3BuZyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIHZhbGlkYXRlQ29uZmlnKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JUeXBlc18xLlZhbGlkYXRpb25FcnJvcignU2NyZWVuc2hvdCBjb25maWd1cmF0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcudmlld3BvcnQud2lkdGggPD0gMCB8fCB0aGlzLmNvbmZpZy52aWV3cG9ydC5oZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvclR5cGVzXzEuVmFsaWRhdGlvbkVycm9yKCdWaWV3cG9ydCBkaW1lbnNpb25zIG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy50aW1lb3V0ICYmIHRoaXMuY29uZmlnLnRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yVHlwZXNfMS5WYWxpZGF0aW9uRXJyb3IoJ1RpbWVvdXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFudXAgcmVzb3VyY2VzXG4gICAgICovXG4gICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnJvd3Nlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5icm93c2VyLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmJyb3dzZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZSA9IFB1cHBldGVlclNjcmVlbnNob3RDYXB0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVwcGV0ZWVyU2NyZWVuc2hvdENhcHR1cmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/PuppeteerScreenshotCapture.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactory.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactory.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Screenshot Service Factory\n// Creates and configures screenshot capture services\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScreenshotServiceFactory = void 0;\nconst PuppeteerScreenshotCapture_1 = __webpack_require__(/*! ./PuppeteerScreenshotCapture */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/PuppeteerScreenshotCapture.js\");\nclass ScreenshotServiceFactory {\n    /**\n     * Create a Puppeteer-based screenshot capture service\n     */\n    static createPuppeteerService(config, logger, errorHandler) {\n        return new PuppeteerScreenshotCapture_1.PuppeteerScreenshotCapture(config, logger, errorHandler);\n    }\n    /**\n     * Create screenshot service based on configuration\n     */\n    static createService(config, logger, errorHandler) {\n        // For now, we only support Puppeteer\n        // In the future, we could add support for other screenshot services\n        return this.createPuppeteerService(config, logger, errorHandler);\n    }\n}\nexports.ScreenshotServiceFactory = ScreenshotServiceFactory;\n//# sourceMappingURL=ScreenshotServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmVlbnNob3QvU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMscUNBQXFDLG1CQUFPLENBQUMsMEpBQThCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy9zY3JlZW5zaG90L1NjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFNjcmVlbnNob3QgU2VydmljZSBGYWN0b3J5XG4vLyBDcmVhdGVzIGFuZCBjb25maWd1cmVzIHNjcmVlbnNob3QgY2FwdHVyZSBzZXJ2aWNlc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY3JlZW5zaG90U2VydmljZUZhY3RvcnkgPSB2b2lkIDA7XG5jb25zdCBQdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZV8xID0gcmVxdWlyZShcIi4vUHVwcGV0ZWVyU2NyZWVuc2hvdENhcHR1cmVcIik7XG5jbGFzcyBTY3JlZW5zaG90U2VydmljZUZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFB1cHBldGVlci1iYXNlZCBzY3JlZW5zaG90IGNhcHR1cmUgc2VydmljZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQdXBwZXRlZXJTZXJ2aWNlKGNvbmZpZywgbG9nZ2VyLCBlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZV8xLlB1cHBldGVlclNjcmVlbnNob3RDYXB0dXJlKGNvbmZpZywgbG9nZ2VyLCBlcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgc2NyZWVuc2hvdCBzZXJ2aWNlIGJhc2VkIG9uIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU2VydmljZShjb25maWcsIGxvZ2dlciwgZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIC8vIEZvciBub3csIHdlIG9ubHkgc3VwcG9ydCBQdXBwZXRlZXJcbiAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIG90aGVyIHNjcmVlbnNob3Qgc2VydmljZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUHVwcGV0ZWVyU2VydmljZShjb25maWcsIGxvZ2dlciwgZXJyb3JIYW5kbGVyKTtcbiAgICB9XG59XG5leHBvcnRzLlNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeSA9IFNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactoryImpl.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactoryImpl.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScreenshotServiceFactoryImpl = void 0;\nexports.createScreenshotServiceFactory = createScreenshotServiceFactory;\nconst PuppeteerScreenshotCapture_1 = __webpack_require__(/*! ./PuppeteerScreenshotCapture */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/PuppeteerScreenshotCapture.js\");\nconst ErrorHandler_1 = __webpack_require__(/*! ../../utils/ErrorHandler */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js\");\nclass ScreenshotServiceFactoryImpl {\n    create(config, logger) {\n        const errorHandler = new ErrorHandler_1.FrameworkErrorHandler(config.retry);\n        return new PuppeteerScreenshotCapture_1.PuppeteerScreenshotCapture(config.services.screenshot || {}, logger, errorHandler);\n    }\n    getServiceName() {\n        return 'screenshotCapture';\n    }\n}\nexports.ScreenshotServiceFactoryImpl = ScreenshotServiceFactoryImpl;\n// Helper function to create screenshot service factory\nfunction createScreenshotServiceFactory() {\n    return new ScreenshotServiceFactoryImpl();\n}\n//# sourceMappingURL=ScreenshotServiceFactoryImpl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmVlbnNob3QvU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5SW1wbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDLHFDQUFxQyxtQkFBTyxDQUFDLDBKQUE4QjtBQUMzRSx1QkFBdUIsbUJBQU8sQ0FBQywwSEFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvc2NyZWVuc2hvdC9TY3JlZW5zaG90U2VydmljZUZhY3RvcnlJbXBsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY3JlZW5zaG90U2VydmljZUZhY3RvcnlJbXBsID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVTY3JlZW5zaG90U2VydmljZUZhY3RvcnkgPSBjcmVhdGVTY3JlZW5zaG90U2VydmljZUZhY3Rvcnk7XG5jb25zdCBQdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZV8xID0gcmVxdWlyZShcIi4vUHVwcGV0ZWVyU2NyZWVuc2hvdENhcHR1cmVcIik7XG5jb25zdCBFcnJvckhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9FcnJvckhhbmRsZXJcIik7XG5jbGFzcyBTY3JlZW5zaG90U2VydmljZUZhY3RvcnlJbXBsIHtcbiAgICBjcmVhdGUoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcl8xLkZyYW1ld29ya0Vycm9ySGFuZGxlcihjb25maWcucmV0cnkpO1xuICAgICAgICByZXR1cm4gbmV3IFB1cHBldGVlclNjcmVlbnNob3RDYXB0dXJlXzEuUHVwcGV0ZWVyU2NyZWVuc2hvdENhcHR1cmUoY29uZmlnLnNlcnZpY2VzLnNjcmVlbnNob3QgfHwge30sIGxvZ2dlciwgZXJyb3JIYW5kbGVyKTtcbiAgICB9XG4gICAgZ2V0U2VydmljZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnc2NyZWVuc2hvdENhcHR1cmUnO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5SW1wbCA9IFNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeUltcGw7XG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHNjcmVlbnNob3Qgc2VydmljZSBmYWN0b3J5XG5mdW5jdGlvbiBjcmVhdGVTY3JlZW5zaG90U2VydmljZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTY3JlZW5zaG90U2VydmljZUZhY3RvcnlJbXBsKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY3JlZW5zaG90U2VydmljZUZhY3RvcnlJbXBsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactoryImpl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Screenshot Capture Adapter\n// Provides screenshot capture functionality using Puppeteer\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createScreenshotServiceFactory = exports.ScreenshotServiceFactory = exports.PuppeteerScreenshotCapture = void 0;\nvar PuppeteerScreenshotCapture_1 = __webpack_require__(/*! ./PuppeteerScreenshotCapture */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/PuppeteerScreenshotCapture.js\");\nObject.defineProperty(exports, \"PuppeteerScreenshotCapture\", ({ enumerable: true, get: function () { return PuppeteerScreenshotCapture_1.PuppeteerScreenshotCapture; } }));\nvar ScreenshotServiceFactory_1 = __webpack_require__(/*! ./ScreenshotServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactory.js\");\nObject.defineProperty(exports, \"ScreenshotServiceFactory\", ({ enumerable: true, get: function () { return ScreenshotServiceFactory_1.ScreenshotServiceFactory; } }));\nvar ScreenshotServiceFactoryImpl_1 = __webpack_require__(/*! ./ScreenshotServiceFactoryImpl */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/ScreenshotServiceFactoryImpl.js\");\nObject.defineProperty(exports, \"createScreenshotServiceFactory\", ({ enumerable: true, get: function () { return ScreenshotServiceFactoryImpl_1.createScreenshotServiceFactory; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3NjcmVlbnNob3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQyxHQUFHLGdDQUFnQyxHQUFHLGtDQUFrQztBQUM5RyxtQ0FBbUMsbUJBQU8sQ0FBQywwSkFBOEI7QUFDekUsOERBQTZELEVBQUUscUNBQXFDLG1FQUFtRSxFQUFDO0FBQ3hLLGlDQUFpQyxtQkFBTyxDQUFDLHNKQUE0QjtBQUNyRSw0REFBMkQsRUFBRSxxQ0FBcUMsK0RBQStELEVBQUM7QUFDbEsscUNBQXFDLG1CQUFPLENBQUMsOEpBQWdDO0FBQzdFLGtFQUFpRSxFQUFFLHFDQUFxQyx5RUFBeUUsRUFBQztBQUNsTCIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvc2NyZWVuc2hvdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFNjcmVlbnNob3QgQ2FwdHVyZSBBZGFwdGVyXG4vLyBQcm92aWRlcyBzY3JlZW5zaG90IGNhcHR1cmUgZnVuY3Rpb25hbGl0eSB1c2luZyBQdXBwZXRlZXJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5ID0gZXhwb3J0cy5TY3JlZW5zaG90U2VydmljZUZhY3RvcnkgPSBleHBvcnRzLlB1cHBldGVlclNjcmVlbnNob3RDYXB0dXJlID0gdm9pZCAwO1xudmFyIFB1cHBldGVlclNjcmVlbnNob3RDYXB0dXJlXzEgPSByZXF1aXJlKFwiLi9QdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlB1cHBldGVlclNjcmVlbnNob3RDYXB0dXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQdXBwZXRlZXJTY3JlZW5zaG90Q2FwdHVyZV8xLlB1cHBldGVlclNjcmVlbnNob3RDYXB0dXJlOyB9IH0pO1xudmFyIFNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTY3JlZW5zaG90U2VydmljZUZhY3RvcnlfMS5TY3JlZW5zaG90U2VydmljZUZhY3Rvcnk7IH0gfSk7XG52YXIgU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5SW1wbF8xID0gcmVxdWlyZShcIi4vU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5SW1wbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2NyZWVuc2hvdFNlcnZpY2VGYWN0b3J5SW1wbF8xLmNyZWF0ZVNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/FileStorageServiceFactory.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/FileStorageServiceFactory.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// File Storage Service Factory\n// Factory for creating file storage service instances with different providers\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileStorageServiceFactory = void 0;\nconst LocalFileStorage_1 = __webpack_require__(/*! ./LocalFileStorage */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/LocalFileStorage.js\");\nclass FileStorageServiceFactory {\n    /**\n     * Create file storage instance from framework config\n     * @param config - Framework configuration\n     * @param logger - Logger instance\n     * @returns File storage instance\n     */\n    create(config, logger) {\n        const fileStorageConfig = this.buildFileStorageConfig(config);\n        logger.info('Creating file storage service', {\n            provider: fileStorageConfig.provider\n        });\n        return this.createFileStorage(fileStorageConfig);\n    }\n    /**\n     * Get service name for registration\n     * @returns Service name\n     */\n    getServiceName() {\n        return 'fileStorage';\n    }\n    /**\n     * Build file storage configuration from framework config\n     * @param config - Framework configuration\n     * @returns File storage factory configuration\n     */\n    buildFileStorageConfig(config) {\n        // For now, default to local storage\n        const provider = 'local';\n        const baseDirectory = './storage';\n        const storageConfig = {\n            baseDirectory,\n            maxFileSize: 100 * 1024 * 1024, // 100MB\n            allowedExtensions: [],\n            enableChecksums: true,\n            enableMetadataStorage: true,\n            tempDirectory: `${baseDirectory}/.temp`\n        };\n        return {\n            provider,\n            config: storageConfig\n        };\n    }\n    /**\n     * Create a file storage service instance\n     * @param config - Factory configuration\n     * @returns File storage service instance\n     */\n    createFileStorage(config) {\n        switch (config.provider) {\n            case 'local':\n                return new LocalFileStorage_1.LocalFileStorage(config.config);\n            case 'aws-s3':\n                throw new Error('AWS S3 storage not implemented yet');\n            case 'azure-blob':\n                throw new Error('Azure Blob storage not implemented yet');\n            case 'gcp-storage':\n                throw new Error('Google Cloud Storage not implemented yet');\n            default:\n                throw new Error(`Unsupported storage provider: ${config.provider}`);\n        }\n    }\n    /**\n     * Create local file storage with default configuration\n     * @param baseDirectory - Base directory for file storage\n     * @param options - Additional options\n     * @returns Local file storage instance\n     */\n    static createLocalStorage(baseDirectory, options = {}) {\n        const config = {\n            baseDirectory,\n            maxFileSize: options.maxFileSize || 100 * 1024 * 1024, // 100MB\n            allowedExtensions: options.allowedExtensions || [],\n            enableChecksums: options.enableChecksums ?? true,\n            enableMetadataStorage: options.enableMetadataStorage ?? true,\n            tempDirectory: options.tempDirectory || `${baseDirectory}/.temp`\n        };\n        return new LocalFileStorage_1.LocalFileStorage(config);\n    }\n    /**\n     * Create file storage from environment variables\n     * @returns File storage service instance\n     */\n    static createFromEnvironment() {\n        const provider = (process.env.FILE_STORAGE_PROVIDER || 'local');\n        const baseDirectory = process.env.FILE_STORAGE_BASE_DIR || './storage';\n        const maxFileSize = process.env.FILE_STORAGE_MAX_SIZE\n            ? parseInt(process.env.FILE_STORAGE_MAX_SIZE)\n            : 100 * 1024 * 1024;\n        const allowedExtensions = process.env.FILE_STORAGE_ALLOWED_EXT\n            ? process.env.FILE_STORAGE_ALLOWED_EXT.split(',').map(ext => ext.trim())\n            : [];\n        const enableChecksums = process.env.FILE_STORAGE_CHECKSUMS !== 'false';\n        const enableMetadataStorage = process.env.FILE_STORAGE_METADATA !== 'false';\n        switch (provider) {\n            case 'local':\n                return this.createLocalStorage(baseDirectory, {\n                    maxFileSize,\n                    allowedExtensions,\n                    enableChecksums,\n                    enableMetadataStorage\n                });\n            default:\n                throw new Error(`Unsupported storage provider from environment: ${provider}`);\n        }\n    }\n    /**\n     * Validate storage configuration\n     * @param config - Configuration to validate\n     * @returns True if valid, throws error if invalid\n     */\n    static validateConfig(config) {\n        if (!config.provider) {\n            throw new Error('Storage provider is required');\n        }\n        if (!config.config) {\n            throw new Error('Storage configuration is required');\n        }\n        switch (config.provider) {\n            case 'local':\n                const localConfig = config.config;\n                if (!localConfig.baseDirectory) {\n                    throw new Error('Base directory is required for local storage');\n                }\n                if (localConfig.maxFileSize && localConfig.maxFileSize <= 0) {\n                    throw new Error('Max file size must be positive');\n                }\n                break;\n            default:\n                throw new Error(`Unknown storage provider: ${config.provider}`);\n        }\n        return true;\n    }\n    /**\n     * Get supported storage providers\n     * @returns List of supported providers\n     */\n    static getSupportedProviders() {\n        return ['local']; // Add more as they're implemented\n    }\n    /**\n     * Get default configuration for a provider\n     * @param provider - Storage provider\n     * @returns Default configuration\n     */\n    static getDefaultConfig(provider) {\n        switch (provider) {\n            case 'local':\n                return {\n                    maxFileSize: 100 * 1024 * 1024, // 100MB\n                    allowedExtensions: [],\n                    enableChecksums: true,\n                    enableMetadataStorage: true\n                };\n            default:\n                throw new Error(`No default config available for provider: ${provider}`);\n        }\n    }\n}\nexports.FileStorageServiceFactory = FileStorageServiceFactory;\n//# sourceMappingURL=FileStorageServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3N0b3JhZ2UvRmlsZVN0b3JhZ2VTZXJ2aWNlRmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDO0FBQ2pDLDJCQUEyQixtQkFBTyxDQUFDLG1JQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esa0ZBQWtGLFNBQVM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3N0b3JhZ2UvRmlsZVN0b3JhZ2VTZXJ2aWNlRmFjdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEZpbGUgU3RvcmFnZSBTZXJ2aWNlIEZhY3Rvcnlcbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIGZpbGUgc3RvcmFnZSBzZXJ2aWNlIGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBwcm92aWRlcnNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlsZVN0b3JhZ2VTZXJ2aWNlRmFjdG9yeSA9IHZvaWQgMDtcbmNvbnN0IExvY2FsRmlsZVN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL0xvY2FsRmlsZVN0b3JhZ2VcIik7XG5jbGFzcyBGaWxlU3RvcmFnZVNlcnZpY2VGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZmlsZSBzdG9yYWdlIGluc3RhbmNlIGZyb20gZnJhbWV3b3JrIGNvbmZpZ1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBGcmFtZXdvcmsgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBsb2dnZXIgLSBMb2dnZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBGaWxlIHN0b3JhZ2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjcmVhdGUoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgZmlsZVN0b3JhZ2VDb25maWcgPSB0aGlzLmJ1aWxkRmlsZVN0b3JhZ2VDb25maWcoY29uZmlnKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oJ0NyZWF0aW5nIGZpbGUgc3RvcmFnZSBzZXJ2aWNlJywge1xuICAgICAgICAgICAgcHJvdmlkZXI6IGZpbGVTdG9yYWdlQ29uZmlnLnByb3ZpZGVyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGaWxlU3RvcmFnZShmaWxlU3RvcmFnZUNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZXJ2aWNlIG5hbWUgZm9yIHJlZ2lzdHJhdGlvblxuICAgICAqIEByZXR1cm5zIFNlcnZpY2UgbmFtZVxuICAgICAqL1xuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ2ZpbGVTdG9yYWdlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgZmlsZSBzdG9yYWdlIGNvbmZpZ3VyYXRpb24gZnJvbSBmcmFtZXdvcmsgY29uZmlnXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEZyYW1ld29yayBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgRmlsZSBzdG9yYWdlIGZhY3RvcnkgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIGJ1aWxkRmlsZVN0b3JhZ2VDb25maWcoY29uZmlnKSB7XG4gICAgICAgIC8vIEZvciBub3csIGRlZmF1bHQgdG8gbG9jYWwgc3RvcmFnZVxuICAgICAgICBjb25zdCBwcm92aWRlciA9ICdsb2NhbCc7XG4gICAgICAgIGNvbnN0IGJhc2VEaXJlY3RvcnkgPSAnLi9zdG9yYWdlJztcbiAgICAgICAgY29uc3Qgc3RvcmFnZUNvbmZpZyA9IHtcbiAgICAgICAgICAgIGJhc2VEaXJlY3RvcnksXG4gICAgICAgICAgICBtYXhGaWxlU2l6ZTogMTAwICogMTAyNCAqIDEwMjQsIC8vIDEwME1CXG4gICAgICAgICAgICBhbGxvd2VkRXh0ZW5zaW9uczogW10sXG4gICAgICAgICAgICBlbmFibGVDaGVja3N1bXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVNZXRhZGF0YVN0b3JhZ2U6IHRydWUsXG4gICAgICAgICAgICB0ZW1wRGlyZWN0b3J5OiBgJHtiYXNlRGlyZWN0b3J5fS8udGVtcGBcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgY29uZmlnOiBzdG9yYWdlQ29uZmlnXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZpbGUgc3RvcmFnZSBzZXJ2aWNlIGluc3RhbmNlXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEZhY3RvcnkgY29uZmlndXJhdGlvblxuICAgICAqIEByZXR1cm5zIEZpbGUgc3RvcmFnZSBzZXJ2aWNlIGluc3RhbmNlXG4gICAgICovXG4gICAgY3JlYXRlRmlsZVN0b3JhZ2UoY29uZmlnKSB7XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjYXNlICdsb2NhbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhbEZpbGVTdG9yYWdlXzEuTG9jYWxGaWxlU3RvcmFnZShjb25maWcuY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgJ2F3cy1zMyc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBV1MgUzMgc3RvcmFnZSBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICAgICAgICBjYXNlICdhenVyZS1ibG9iJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F6dXJlIEJsb2Igc3RvcmFnZSBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICAgICAgICBjYXNlICdnY3Atc3RvcmFnZSc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGUgQ2xvdWQgU3RvcmFnZSBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3RvcmFnZSBwcm92aWRlcjogJHtjb25maWcucHJvdmlkZXJ9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGxvY2FsIGZpbGUgc3RvcmFnZSB3aXRoIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBiYXNlRGlyZWN0b3J5IC0gQmFzZSBkaXJlY3RvcnkgZm9yIGZpbGUgc3RvcmFnZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zXG4gICAgICogQHJldHVybnMgTG9jYWwgZmlsZSBzdG9yYWdlIGluc3RhbmNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUxvY2FsU3RvcmFnZShiYXNlRGlyZWN0b3J5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgYmFzZURpcmVjdG9yeSxcbiAgICAgICAgICAgIG1heEZpbGVTaXplOiBvcHRpb25zLm1heEZpbGVTaXplIHx8IDEwMCAqIDEwMjQgKiAxMDI0LCAvLyAxMDBNQlxuICAgICAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnM6IG9wdGlvbnMuYWxsb3dlZEV4dGVuc2lvbnMgfHwgW10sXG4gICAgICAgICAgICBlbmFibGVDaGVja3N1bXM6IG9wdGlvbnMuZW5hYmxlQ2hlY2tzdW1zID8/IHRydWUsXG4gICAgICAgICAgICBlbmFibGVNZXRhZGF0YVN0b3JhZ2U6IG9wdGlvbnMuZW5hYmxlTWV0YWRhdGFTdG9yYWdlID8/IHRydWUsXG4gICAgICAgICAgICB0ZW1wRGlyZWN0b3J5OiBvcHRpb25zLnRlbXBEaXJlY3RvcnkgfHwgYCR7YmFzZURpcmVjdG9yeX0vLnRlbXBgXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgTG9jYWxGaWxlU3RvcmFnZV8xLkxvY2FsRmlsZVN0b3JhZ2UoY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZpbGUgc3RvcmFnZSBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEByZXR1cm5zIEZpbGUgc3RvcmFnZSBzZXJ2aWNlIGluc3RhbmNlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21FbnZpcm9ubWVudCgpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSAocHJvY2Vzcy5lbnYuRklMRV9TVE9SQUdFX1BST1ZJREVSIHx8ICdsb2NhbCcpO1xuICAgICAgICBjb25zdCBiYXNlRGlyZWN0b3J5ID0gcHJvY2Vzcy5lbnYuRklMRV9TVE9SQUdFX0JBU0VfRElSIHx8ICcuL3N0b3JhZ2UnO1xuICAgICAgICBjb25zdCBtYXhGaWxlU2l6ZSA9IHByb2Nlc3MuZW52LkZJTEVfU1RPUkFHRV9NQVhfU0laRVxuICAgICAgICAgICAgPyBwYXJzZUludChwcm9jZXNzLmVudi5GSUxFX1NUT1JBR0VfTUFYX1NJWkUpXG4gICAgICAgICAgICA6IDEwMCAqIDEwMjQgKiAxMDI0O1xuICAgICAgICBjb25zdCBhbGxvd2VkRXh0ZW5zaW9ucyA9IHByb2Nlc3MuZW52LkZJTEVfU1RPUkFHRV9BTExPV0VEX0VYVFxuICAgICAgICAgICAgPyBwcm9jZXNzLmVudi5GSUxFX1NUT1JBR0VfQUxMT1dFRF9FWFQuc3BsaXQoJywnKS5tYXAoZXh0ID0+IGV4dC50cmltKCkpXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBlbmFibGVDaGVja3N1bXMgPSBwcm9jZXNzLmVudi5GSUxFX1NUT1JBR0VfQ0hFQ0tTVU1TICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBlbmFibGVNZXRhZGF0YVN0b3JhZ2UgPSBwcm9jZXNzLmVudi5GSUxFX1NUT1JBR0VfTUVUQURBVEEgIT09ICdmYWxzZSc7XG4gICAgICAgIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xvY2FsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMb2NhbFN0b3JhZ2UoYmFzZURpcmVjdG9yeSwge1xuICAgICAgICAgICAgICAgICAgICBtYXhGaWxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUNoZWNrc3VtcyxcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlTWV0YWRhdGFTdG9yYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3RvcmFnZSBwcm92aWRlciBmcm9tIGVudmlyb25tZW50OiAke3Byb3ZpZGVyfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHN0b3JhZ2UgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIHRvIHZhbGlkYXRlXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB2YWxpZCwgdGhyb3dzIGVycm9yIGlmIGludmFsaWRcbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGlmICghY29uZmlnLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0b3JhZ2UgcHJvdmlkZXIgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZy5jb25maWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RvcmFnZSBjb25maWd1cmF0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb25maWcucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xvY2FsJzpcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbENvbmZpZyA9IGNvbmZpZy5jb25maWc7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbENvbmZpZy5iYXNlRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFzZSBkaXJlY3RvcnkgaXMgcmVxdWlyZWQgZm9yIGxvY2FsIHN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsQ29uZmlnLm1heEZpbGVTaXplICYmIGxvY2FsQ29uZmlnLm1heEZpbGVTaXplIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXggZmlsZSBzaXplIG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdG9yYWdlIHByb3ZpZGVyOiAke2NvbmZpZy5wcm92aWRlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHN1cHBvcnRlZCBzdG9yYWdlIHByb3ZpZGVyc1xuICAgICAqIEByZXR1cm5zIExpc3Qgb2Ygc3VwcG9ydGVkIHByb3ZpZGVyc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTdXBwb3J0ZWRQcm92aWRlcnMoKSB7XG4gICAgICAgIHJldHVybiBbJ2xvY2FsJ107IC8vIEFkZCBtb3JlIGFzIHRoZXkncmUgaW1wbGVtZW50ZWRcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgYSBwcm92aWRlclxuICAgICAqIEBwYXJhbSBwcm92aWRlciAtIFN0b3JhZ2UgcHJvdmlkZXJcbiAgICAgKiBAcmV0dXJucyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENvbmZpZyhwcm92aWRlcikge1xuICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjYXNlICdsb2NhbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RmlsZVNpemU6IDEwMCAqIDEwMjQgKiAxMDI0LCAvLyAxMDBNQlxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkRXh0ZW5zaW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUNoZWNrc3VtczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlTWV0YWRhdGFTdG9yYWdlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZWZhdWx0IGNvbmZpZyBhdmFpbGFibGUgZm9yIHByb3ZpZGVyOiAke3Byb3ZpZGVyfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlU3RvcmFnZVNlcnZpY2VGYWN0b3J5ID0gRmlsZVN0b3JhZ2VTZXJ2aWNlRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbGVTdG9yYWdlU2VydmljZUZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/FileStorageServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/LocalFileStorage.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/LocalFileStorage.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Local File Storage Adapter\n// Implementation of file storage using local filesystem with Node.js fs operations\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocalFileStorage = void 0;\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst Logger_1 = __webpack_require__(/*! ../../utils/Logger */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/Logger.js\");\nconst pipelineAsync = (0, util_1.promisify)(stream_1.pipeline);\nclass LocalFileStorage {\n    constructor(config) {\n        this.metadataCache = new Map();\n        this.logger = new Logger_1.FrameworkLogger('info');\n        this.config = {\n            baseDirectory: config.baseDirectory,\n            maxFileSize: config.maxFileSize || 100 * 1024 * 1024, // 100MB default\n            allowedExtensions: config.allowedExtensions || [],\n            enableChecksums: config.enableChecksums ?? true,\n            enableMetadataStorage: config.enableMetadataStorage ?? true,\n            tempDirectory: config.tempDirectory || path.join(config.baseDirectory, '.temp')\n        };\n        this.initializeStorage();\n    }\n    async initializeStorage() {\n        try {\n            // Create base directory if it doesn't exist\n            await fs.promises.mkdir(this.config.baseDirectory, { recursive: true });\n            // Create temp directory\n            if (this.config.tempDirectory) {\n                await fs.promises.mkdir(this.config.tempDirectory, { recursive: true });\n            }\n            this.logger.info('Local file storage initialized', {\n                baseDirectory: this.config.baseDirectory,\n                maxFileSize: this.config.maxFileSize\n            });\n        }\n        catch (error) {\n            this.logger.error('Failed to initialize storage', { error });\n            throw error;\n        }\n    }\n    async uploadFile(fileData, originalName, options = {}) {\n        try {\n            // Validate file extension\n            const extension = path.extname(originalName).toLowerCase();\n            if (this.config.allowedExtensions.length > 0 &&\n                !this.config.allowedExtensions.includes(extension)) {\n                return {\n                    success: false,\n                    error: `File extension ${extension} not allowed`,\n                    data: null\n                };\n            }\n            // Generate filename and path\n            const filename = options.filename || this.generateUniqueFilename(originalName);\n            const directory = options.directory || '';\n            const fullDirectory = path.join(this.config.baseDirectory, directory);\n            const filePath = path.join(fullDirectory, filename);\n            const relativePath = path.join(directory, filename);\n            // Create directory if needed\n            await fs.promises.mkdir(fullDirectory, { recursive: true });\n            // Check if file exists and handle overwrite\n            if (await this.fileExists(relativePath) && !options.overwrite) {\n                return {\n                    success: false,\n                    error: 'File already exists and overwrite not specified',\n                    data: null\n                };\n            }\n            // Write file data\n            let fileSize;\n            let checksum;\n            if (Buffer.isBuffer(fileData)) {\n                // Handle Buffer upload\n                if (fileData.length > this.config.maxFileSize) {\n                    return {\n                        success: false,\n                        error: `File size exceeds maximum allowed size of ${this.config.maxFileSize} bytes`,\n                        data: null\n                    };\n                }\n                await fs.promises.writeFile(filePath, fileData);\n                fileSize = fileData.length;\n                if (this.config.enableChecksums || options.generateChecksum) {\n                    checksum = crypto.createHash('sha256').update(fileData).digest('hex');\n                }\n            }\n            else {\n                // Handle stream upload\n                const writeStream = fs.createWriteStream(filePath);\n                let bytesWritten = 0;\n                const hash = this.config.enableChecksums || options.generateChecksum\n                    ? crypto.createHash('sha256')\n                    : null;\n                const transformStream = new ((__webpack_require__(/*! stream */ \"stream\").Transform))({\n                    transform(chunk, encoding, callback) {\n                        bytesWritten += chunk.length;\n                        if (bytesWritten > this.config.maxFileSize) {\n                            return callback(new Error(`File size exceeds maximum allowed size`));\n                        }\n                        if (hash)\n                            hash.update(chunk);\n                        callback(null, chunk);\n                    }\n                });\n                await pipelineAsync(fileData, transformStream, writeStream);\n                fileSize = bytesWritten;\n                checksum = hash?.digest('hex');\n            }\n            // Detect MIME type\n            const mimeType = this.detectMimeType(originalName);\n            // Create metadata\n            const metadata = {\n                filename,\n                originalName,\n                size: fileSize,\n                mimeType,\n                extension: extension.slice(1), // Remove the dot\n                uploadedAt: new Date(),\n                path: relativePath,\n                checksum,\n                tags: options.tags || [],\n                customMetadata: options.customMetadata || {}\n            };\n            // Store metadata if enabled\n            if (this.config.enableMetadataStorage) {\n                await this.storeMetadata(relativePath, metadata);\n            }\n            this.metadataCache.set(relativePath, metadata);\n            this.logger.info('File uploaded successfully', {\n                filename,\n                originalName,\n                size: fileSize,\n                path: relativePath\n            });\n            return {\n                success: true,\n                data: metadata,\n                error: null\n            };\n        }\n        catch (error) {\n            this.logger.error('Failed to upload file', {\n                originalName,\n                error: error instanceof Error ? error.message : String(error)\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: null\n            };\n        }\n    }\n    async downloadFile(filePath, options = {}) {\n        try {\n            const fullPath = path.join(this.config.baseDirectory, filePath);\n            // Check if file exists\n            if (!await this.fileExists(filePath)) {\n                return {\n                    success: false,\n                    error: 'File not found',\n                    data: null\n                };\n            }\n            if (options.asStream) {\n                // Return as stream\n                const stream = fs.createReadStream(fullPath, options.range);\n                return {\n                    success: true,\n                    data: stream,\n                    error: null\n                };\n            }\n            else {\n                // Return as buffer\n                const data = await fs.promises.readFile(fullPath);\n                if (options.range) {\n                    const { start, end } = options.range;\n                    const slicedData = data.slice(start, end + 1);\n                    return {\n                        success: true,\n                        data: slicedData,\n                        error: null\n                    };\n                }\n                return {\n                    success: true,\n                    data: data,\n                    error: null\n                };\n            }\n        }\n        catch (error) {\n            this.logger.error('Failed to download file', {\n                filePath,\n                error: error instanceof Error ? error.message : String(error)\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: null\n            };\n        }\n    }\n    async getFileMetadata(filePath) {\n        try {\n            // Check cache first\n            if (this.metadataCache.has(filePath)) {\n                return {\n                    success: true,\n                    data: this.metadataCache.get(filePath),\n                    error: null\n                };\n            }\n            // Try to load from stored metadata\n            if (this.config.enableMetadataStorage) {\n                const storedMetadata = await this.loadMetadata(filePath);\n                if (storedMetadata) {\n                    this.metadataCache.set(filePath, storedMetadata);\n                    return {\n                        success: true,\n                        data: storedMetadata,\n                        error: null\n                    };\n                }\n            }\n            // Generate metadata from filesystem\n            const fullPath = path.join(this.config.baseDirectory, filePath);\n            const stats = await fs.promises.stat(fullPath);\n            const metadata = {\n                filename: path.basename(filePath),\n                originalName: path.basename(filePath),\n                size: stats.size,\n                mimeType: this.detectMimeType(filePath),\n                extension: path.extname(filePath).slice(1),\n                uploadedAt: stats.birthtime,\n                modifiedAt: stats.mtime,\n                path: filePath,\n                tags: [],\n                customMetadata: {}\n            };\n            this.metadataCache.set(filePath, metadata);\n            return {\n                success: true,\n                data: metadata,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'File not found',\n                data: null\n            };\n        }\n    }\n    async deleteFile(filePath) {\n        try {\n            const fullPath = path.join(this.config.baseDirectory, filePath);\n            await fs.promises.unlink(fullPath);\n            // Remove metadata\n            if (this.config.enableMetadataStorage) {\n                await this.deleteMetadata(filePath);\n            }\n            this.metadataCache.delete(filePath);\n            this.logger.info('File deleted successfully', { filePath });\n            return {\n                success: true,\n                data: true,\n                error: null\n            };\n        }\n        catch (error) {\n            this.logger.error('Failed to delete file', {\n                filePath,\n                error: error instanceof Error ? error.message : String(error)\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: false\n            };\n        }\n    }\n    async listFiles(directory = '', filter) {\n        try {\n            const fullDirectory = path.join(this.config.baseDirectory, directory);\n            const files = await this.scanDirectory(fullDirectory, directory);\n            let filteredFiles = files;\n            if (filter) {\n                filteredFiles = files.filter(file => this.matchesFilter(file, filter));\n            }\n            return {\n                success: true,\n                data: filteredFiles,\n                error: null\n            };\n        }\n        catch (error) {\n            this.logger.error('Failed to list files', {\n                directory,\n                error: error instanceof Error ? error.message : String(error)\n            });\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: []\n            };\n        }\n    }\n    async fileExists(filePath) {\n        try {\n            const fullPath = path.join(this.config.baseDirectory, filePath);\n            await fs.promises.access(fullPath, fs.constants.F_OK);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    async createDirectory(directoryPath, recursive = true) {\n        try {\n            const fullPath = path.join(this.config.baseDirectory, directoryPath);\n            await fs.promises.mkdir(fullPath, { recursive });\n            return {\n                success: true,\n                data: true,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: false\n            };\n        }\n    }\n    async deleteDirectory(directoryPath, recursive = false) {\n        try {\n            const fullPath = path.join(this.config.baseDirectory, directoryPath);\n            await fs.promises.rmdir(fullPath, { recursive });\n            return {\n                success: true,\n                data: true,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: false\n            };\n        }\n    }\n    async moveFile(sourcePath, destinationPath, overwrite = false) {\n        try {\n            const fullSourcePath = path.join(this.config.baseDirectory, sourcePath);\n            const fullDestinationPath = path.join(this.config.baseDirectory, destinationPath);\n            if (!overwrite && await this.fileExists(destinationPath)) {\n                return {\n                    success: false,\n                    error: 'Destination file already exists',\n                    data: false\n                };\n            }\n            await fs.promises.rename(fullSourcePath, fullDestinationPath);\n            // Update metadata cache\n            if (this.metadataCache.has(sourcePath)) {\n                const metadata = this.metadataCache.get(sourcePath);\n                metadata.path = destinationPath;\n                metadata.filename = path.basename(destinationPath);\n                this.metadataCache.set(destinationPath, metadata);\n                this.metadataCache.delete(sourcePath);\n            }\n            return {\n                success: true,\n                data: true,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: false\n            };\n        }\n    }\n    async copyFile(sourcePath, destinationPath, overwrite = false) {\n        try {\n            const fullSourcePath = path.join(this.config.baseDirectory, sourcePath);\n            const fullDestinationPath = path.join(this.config.baseDirectory, destinationPath);\n            if (!overwrite && await this.fileExists(destinationPath)) {\n                return {\n                    success: false,\n                    error: 'Destination file already exists',\n                    data: false\n                };\n            }\n            await fs.promises.copyFile(fullSourcePath, fullDestinationPath);\n            return {\n                success: true,\n                data: true,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: false\n            };\n        }\n    }\n    async getStorageStats() {\n        try {\n            const stats = await this.calculateStorageStats();\n            return {\n                success: true,\n                data: stats,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: null\n            };\n        }\n    }\n    async searchFiles(searchTerm, filter) {\n        try {\n            const allFiles = await this.listFiles('');\n            if (!allFiles.success || !allFiles.data) {\n                return allFiles;\n            }\n            const searchResults = allFiles.data.filter(file => {\n                const matchesSearch = file.filename.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                    file.originalName.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                    (file.tags && file.tags.some(tag => tag.toLowerCase().includes(searchTerm.toLowerCase())));\n                const matchesFilter = filter ? this.matchesFilter(file, filter) : true;\n                return matchesSearch && matchesFilter;\n            });\n            return {\n                success: true,\n                data: searchResults,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: []\n            };\n        }\n    }\n    async generateDownloadUrl(filePath, expiresInSeconds = 3600) {\n        // For local storage, we can generate a simple token-based URL\n        // In a real implementation, this would be more secure\n        const token = crypto.randomUUID();\n        const expiry = Date.now() + (expiresInSeconds * 1000);\n        // Store token mapping (in memory for this implementation)\n        // In production, you'd use Redis or similar\n        const url = `/download/${token}?path=${encodeURIComponent(filePath)}&expires=${expiry}`;\n        return {\n            success: true,\n            data: url,\n            error: null\n        };\n    }\n    async updateFileMetadata(filePath, metadata) {\n        try {\n            const currentMetadata = await this.getFileMetadata(filePath);\n            if (!currentMetadata.success || !currentMetadata.data) {\n                return currentMetadata;\n            }\n            const updatedMetadata = {\n                ...currentMetadata.data,\n                ...metadata,\n                modifiedAt: new Date()\n            };\n            if (this.config.enableMetadataStorage) {\n                await this.storeMetadata(filePath, updatedMetadata);\n            }\n            this.metadataCache.set(filePath, updatedMetadata);\n            return {\n                success: true,\n                data: updatedMetadata,\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: null\n            };\n        }\n    }\n    async isHealthy() {\n        try {\n            // Check if base directory is accessible\n            await fs.promises.access(this.config.baseDirectory, fs.constants.R_OK | fs.constants.W_OK);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    getServiceName() {\n        return 'LocalFileStorage';\n    }\n    getStorageType() {\n        return 'local';\n    }\n    async cleanup() {\n        try {\n            let filesDeleted = 0;\n            let spaceFreed = 0;\n            // Clean up temp directory\n            if (this.config.tempDirectory) {\n                const tempFiles = await fs.promises.readdir(this.config.tempDirectory);\n                for (const file of tempFiles) {\n                    const filePath = path.join(this.config.tempDirectory, file);\n                    const stats = await fs.promises.stat(filePath);\n                    await fs.promises.unlink(filePath);\n                    filesDeleted++;\n                    spaceFreed += stats.size;\n                }\n            }\n            return {\n                success: true,\n                data: { filesDeleted, spaceFreed },\n                error: null\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error instanceof Error ? error.message : 'Unknown error occurred',\n                data: null\n            };\n        }\n    }\n    // Private helper methods\n    generateUniqueFilename(originalName) {\n        const timestamp = Date.now();\n        const random = Math.random().toString(36).substring(2, 8);\n        const extension = path.extname(originalName);\n        const baseName = path.basename(originalName, extension);\n        return `${baseName}_${timestamp}_${random}${extension}`;\n    }\n    detectMimeType(filename) {\n        const extension = path.extname(filename).toLowerCase();\n        const mimeTypes = {\n            '.pdf': 'application/pdf',\n            '.txt': 'text/plain',\n            '.doc': 'application/msword',\n            '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            '.xls': 'application/vnd.ms-excel',\n            '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            '.ppt': 'application/vnd.ms-powerpoint',\n            '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            '.jpg': 'image/jpeg',\n            '.jpeg': 'image/jpeg',\n            '.png': 'image/png',\n            '.gif': 'image/gif',\n            '.svg': 'image/svg+xml',\n            '.mp4': 'video/mp4',\n            '.mp3': 'audio/mpeg',\n            '.zip': 'application/zip',\n            '.json': 'application/json',\n            '.xml': 'application/xml',\n            '.csv': 'text/csv'\n        };\n        return mimeTypes[extension] || 'application/octet-stream';\n    }\n    async scanDirectory(fullDirectory, relativeDirectory) {\n        const files = [];\n        try {\n            const entries = await fs.promises.readdir(fullDirectory, { withFileTypes: true });\n            for (const entry of entries) {\n                if (entry.isFile()) {\n                    const filePath = path.join(relativeDirectory, entry.name);\n                    const metadataResult = await this.getFileMetadata(filePath);\n                    if (metadataResult.success && metadataResult.data) {\n                        files.push(metadataResult.data);\n                    }\n                }\n            }\n        }\n        catch (error) {\n            this.logger.error('Error scanning directory', { fullDirectory, error });\n        }\n        return files;\n    }\n    matchesFilter(file, filter) {\n        if (filter.extension && !filter.extension.includes(file.extension))\n            return false;\n        if (filter.mimeType && !filter.mimeType.includes(file.mimeType))\n            return false;\n        if (filter.sizeMin && file.size < filter.sizeMin)\n            return false;\n        if (filter.sizeMax && file.size > filter.sizeMax)\n            return false;\n        if (filter.uploadedAfter && file.uploadedAt < filter.uploadedAfter)\n            return false;\n        if (filter.uploadedBefore && file.uploadedAt > filter.uploadedBefore)\n            return false;\n        if (filter.tags && filter.tags.length > 0) {\n            const hasMatchingTag = filter.tags.some(tag => file.tags?.some(fileTag => fileTag.toLowerCase().includes(tag.toLowerCase())));\n            if (!hasMatchingTag)\n                return false;\n        }\n        if (filter.searchTerm) {\n            const searchLower = filter.searchTerm.toLowerCase();\n            const matchesName = file.filename.toLowerCase().includes(searchLower) ||\n                file.originalName.toLowerCase().includes(searchLower);\n            const matchesTags = file.tags?.some(tag => tag.toLowerCase().includes(searchLower));\n            if (!matchesName && !matchesTags)\n                return false;\n        }\n        return true;\n    }\n    async calculateStorageStats() {\n        let totalFiles = 0;\n        let totalSize = 0;\n        const scanDir = async (dir) => {\n            try {\n                const entries = await fs.promises.readdir(dir, { withFileTypes: true });\n                for (const entry of entries) {\n                    const fullPath = path.join(dir, entry.name);\n                    if (entry.isFile()) {\n                        const stats = await fs.promises.stat(fullPath);\n                        totalFiles++;\n                        totalSize += stats.size;\n                    }\n                    else if (entry.isDirectory()) {\n                        await scanDir(fullPath);\n                    }\n                }\n            }\n            catch (error) {\n                this.logger.error('Error calculating storage stats', { dir, error });\n            }\n        };\n        await scanDir(this.config.baseDirectory);\n        return {\n            totalFiles,\n            totalSize,\n            usedSpace: totalSize,\n            lastUpdated: new Date()\n        };\n    }\n    async storeMetadata(filePath, metadata) {\n        try {\n            const metadataPath = path.join(this.config.baseDirectory, '.metadata', `${filePath}.json`);\n            const metadataDir = path.dirname(metadataPath);\n            await fs.promises.mkdir(metadataDir, { recursive: true });\n            await fs.promises.writeFile(metadataPath, JSON.stringify(metadata, null, 2));\n        }\n        catch (error) {\n            this.logger.error('Failed to store metadata', { filePath, error });\n        }\n    }\n    async loadMetadata(filePath) {\n        try {\n            const metadataPath = path.join(this.config.baseDirectory, '.metadata', `${filePath}.json`);\n            const metadataContent = await fs.promises.readFile(metadataPath, 'utf-8');\n            return JSON.parse(metadataContent);\n        }\n        catch {\n            return null;\n        }\n    }\n    async deleteMetadata(filePath) {\n        try {\n            const metadataPath = path.join(this.config.baseDirectory, '.metadata', `${filePath}.json`);\n            await fs.promises.unlink(metadataPath);\n        }\n        catch {\n            // Metadata file might not exist, which is fine\n        }\n    }\n}\nexports.LocalFileStorage = LocalFileStorage;\n//# sourceMappingURL=LocalFileStorage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3N0b3JhZ2UvTG9jYWxGaWxlU3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLHdCQUF3QixtQkFBTyxDQUFDLGNBQUk7QUFDcEMsMEJBQTBCLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsNEJBQTRCLG1CQUFPLENBQUMsc0JBQVE7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDhHQUFvQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0E7QUFDQSxxRUFBcUUsaUJBQWlCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnRUFBZ0UsT0FBTztBQUN2RTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUseUJBQXlCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVEQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNLFFBQVEsNkJBQTZCLFdBQVcsT0FBTztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVMsR0FBRyxVQUFVLEdBQUcsT0FBTyxFQUFFLFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxxQkFBcUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxzQkFBc0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHFCQUFxQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxZQUFZO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixTQUFTO0FBQy9GO0FBQ0EsbURBQW1ELGlCQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFNBQVM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFNBQVM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3N0b3JhZ2UvTG9jYWxGaWxlU3RvcmFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIExvY2FsIEZpbGUgU3RvcmFnZSBBZGFwdGVyXG4vLyBJbXBsZW1lbnRhdGlvbiBvZiBmaWxlIHN0b3JhZ2UgdXNpbmcgbG9jYWwgZmlsZXN5c3RlbSB3aXRoIE5vZGUuanMgZnMgb3BlcmF0aW9uc1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvY2FsRmlsZVN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBmcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZnNcIikpO1xuY29uc3QgcGF0aCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicGF0aFwiKSk7XG5jb25zdCBjcnlwdG8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImNyeXB0b1wiKSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0xvZ2dlclwiKTtcbmNvbnN0IHBpcGVsaW5lQXN5bmMgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoc3RyZWFtXzEucGlwZWxpbmUpO1xuY2xhc3MgTG9jYWxGaWxlU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBuZXcgTG9nZ2VyXzEuRnJhbWV3b3JrTG9nZ2VyKCdpbmZvJyk7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgYmFzZURpcmVjdG9yeTogY29uZmlnLmJhc2VEaXJlY3RvcnksXG4gICAgICAgICAgICBtYXhGaWxlU2l6ZTogY29uZmlnLm1heEZpbGVTaXplIHx8IDEwMCAqIDEwMjQgKiAxMDI0LCAvLyAxMDBNQiBkZWZhdWx0XG4gICAgICAgICAgICBhbGxvd2VkRXh0ZW5zaW9uczogY29uZmlnLmFsbG93ZWRFeHRlbnNpb25zIHx8IFtdLFxuICAgICAgICAgICAgZW5hYmxlQ2hlY2tzdW1zOiBjb25maWcuZW5hYmxlQ2hlY2tzdW1zID8/IHRydWUsXG4gICAgICAgICAgICBlbmFibGVNZXRhZGF0YVN0b3JhZ2U6IGNvbmZpZy5lbmFibGVNZXRhZGF0YVN0b3JhZ2UgPz8gdHJ1ZSxcbiAgICAgICAgICAgIHRlbXBEaXJlY3Rvcnk6IGNvbmZpZy50ZW1wRGlyZWN0b3J5IHx8IHBhdGguam9pbihjb25maWcuYmFzZURpcmVjdG9yeSwgJy50ZW1wJylcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplU3RvcmFnZSgpO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplU3RvcmFnZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBiYXNlIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5ta2Rpcih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0ZW1wIGRpcmVjdG9yeVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRlbXBEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5ta2Rpcih0aGlzLmNvbmZpZy50ZW1wRGlyZWN0b3J5LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0xvY2FsIGZpbGUgc3RvcmFnZSBpbml0aWFsaXplZCcsIHtcbiAgICAgICAgICAgICAgICBiYXNlRGlyZWN0b3J5OiB0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgIG1heEZpbGVTaXplOiB0aGlzLmNvbmZpZy5tYXhGaWxlU2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgc3RvcmFnZScsIHsgZXJyb3IgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWRGaWxlKGZpbGVEYXRhLCBvcmlnaW5hbE5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgZmlsZSBleHRlbnNpb25cbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShvcmlnaW5hbE5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuYWxsb3dlZEV4dGVuc2lvbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmNvbmZpZy5hbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBgRmlsZSBleHRlbnNpb24gJHtleHRlbnNpb259IG5vdCBhbGxvd2VkYCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBmaWxlbmFtZSBhbmQgcGF0aFxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lIHx8IHRoaXMuZ2VuZXJhdGVVbmlxdWVGaWxlbmFtZShvcmlnaW5hbE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0b3J5ID0gb3B0aW9ucy5kaXJlY3RvcnkgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBmdWxsRGlyZWN0b3J5ID0gcGF0aC5qb2luKHRoaXMuY29uZmlnLmJhc2VEaXJlY3RvcnksIGRpcmVjdG9yeSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihmdWxsRGlyZWN0b3J5LCBmaWxlbmFtZSk7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgZGlyZWN0b3J5IGlmIG5lZWRlZFxuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMubWtkaXIoZnVsbERpcmVjdG9yeSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIGV4aXN0cyBhbmQgaGFuZGxlIG92ZXJ3cml0ZVxuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMuZmlsZUV4aXN0cyhyZWxhdGl2ZVBhdGgpICYmICFvcHRpb25zLm92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ZpbGUgYWxyZWFkeSBleGlzdHMgYW5kIG92ZXJ3cml0ZSBub3Qgc3BlY2lmaWVkJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXcml0ZSBmaWxlIGRhdGFcbiAgICAgICAgICAgIGxldCBmaWxlU2l6ZTtcbiAgICAgICAgICAgIGxldCBjaGVja3N1bTtcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZmlsZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIEJ1ZmZlciB1cGxvYWRcbiAgICAgICAgICAgICAgICBpZiAoZmlsZURhdGEubGVuZ3RoID4gdGhpcy5jb25maWcubWF4RmlsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBGaWxlIHNpemUgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiAke3RoaXMuY29uZmlnLm1heEZpbGVTaXplfSBieXRlc2AsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShmaWxlUGF0aCwgZmlsZURhdGEpO1xuICAgICAgICAgICAgICAgIGZpbGVTaXplID0gZmlsZURhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDaGVja3N1bXMgfHwgb3B0aW9ucy5nZW5lcmF0ZUNoZWNrc3VtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShmaWxlRGF0YSkuZGlnZXN0KCdoZXgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3RyZWFtIHVwbG9hZFxuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCBieXRlc1dyaXR0ZW4gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmNvbmZpZy5lbmFibGVDaGVja3N1bXMgfHwgb3B0aW9ucy5nZW5lcmF0ZUNoZWNrc3VtXG4gICAgICAgICAgICAgICAgICAgID8gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSBuZXcgKHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybSkoe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNXcml0dGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlc1dyaXR0ZW4gPiB0aGlzLmNvbmZpZy5tYXhGaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoYEZpbGUgc2l6ZSBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBzaXplYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaC51cGRhdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGlwZWxpbmVBc3luYyhmaWxlRGF0YSwgdHJhbnNmb3JtU3RyZWFtLCB3cml0ZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgZmlsZVNpemUgPSBieXRlc1dyaXR0ZW47XG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gPSBoYXNoPy5kaWdlc3QoJ2hleCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGV0ZWN0IE1JTUUgdHlwZVxuICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSB0aGlzLmRldGVjdE1pbWVUeXBlKG9yaWdpbmFsTmFtZSk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbWV0YWRhdGFcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmaWxlU2l6ZSxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICBleHRlbnNpb246IGV4dGVuc2lvbi5zbGljZSgxKSwgLy8gUmVtb3ZlIHRoZSBkb3RcbiAgICAgICAgICAgICAgICB1cGxvYWRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHBhdGg6IHJlbGF0aXZlUGF0aCxcbiAgICAgICAgICAgICAgICBjaGVja3N1bSxcbiAgICAgICAgICAgICAgICB0YWdzOiBvcHRpb25zLnRhZ3MgfHwgW10sXG4gICAgICAgICAgICAgICAgY3VzdG9tTWV0YWRhdGE6IG9wdGlvbnMuY3VzdG9tTWV0YWRhdGEgfHwge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBTdG9yZSBtZXRhZGF0YSBpZiBlbmFibGVkXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTWV0YWRhdGFTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zdG9yZU1ldGFkYXRhKHJlbGF0aXZlUGF0aCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlLnNldChyZWxhdGl2ZVBhdGgsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0ZpbGUgdXBsb2FkZWQgc3VjY2Vzc2Z1bGx5Jywge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmaWxlU2l6ZSxcbiAgICAgICAgICAgICAgICBwYXRoOiByZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZScsIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE5hbWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRvd25sb2FkRmlsZShmaWxlUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCBmaWxlUGF0aCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIGV4aXN0c1xuICAgICAgICAgICAgaWYgKCFhd2FpdCB0aGlzLmZpbGVFeGlzdHMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAnRmlsZSBub3QgZm91bmQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFzU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFzIHN0cmVhbVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZnVsbFBhdGgsIG9wdGlvbnMucmFuZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHN0cmVhbSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFzIGJ1ZmZlclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZShmdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBvcHRpb25zLnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGljZWREYXRhID0gZGF0YS5zbGljZShzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc2xpY2VkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZG93bmxvYWQgZmlsZScsIHtcbiAgICAgICAgICAgICAgICBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0RmlsZU1ldGFkYXRhKGZpbGVQYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFDYWNoZS5oYXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5tZXRhZGF0YUNhY2hlLmdldChmaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyeSB0byBsb2FkIGZyb20gc3RvcmVkIG1ldGFkYXRhXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTWV0YWRhdGFTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkTWV0YWRhdGEgPSBhd2FpdCB0aGlzLmxvYWRNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZS5zZXQoZmlsZVBhdGgsIHN0b3JlZE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzdG9yZWRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbWV0YWRhdGEgZnJvbSBmaWxlc3lzdGVtXG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCBmaWxlUGF0aCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnByb21pc2VzLnN0YXQoZnVsbFBhdGgpO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTmFtZTogcGF0aC5iYXNlbmFtZShmaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgc2l6ZTogc3RhdHMuc2l6ZSxcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogdGhpcy5kZXRlY3RNaW1lVHlwZShmaWxlUGF0aCksXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBwYXRoLmV4dG5hbWUoZmlsZVBhdGgpLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgIHVwbG9hZGVkQXQ6IHN0YXRzLmJpcnRodGltZSxcbiAgICAgICAgICAgICAgICBtb2RpZmllZEF0OiBzdGF0cy5tdGltZSxcbiAgICAgICAgICAgICAgICBwYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgICAgICAgICBjdXN0b21NZXRhZGF0YToge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuc2V0KGZpbGVQYXRoLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdGaWxlIG5vdCBmb3VuZCcsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGVGaWxlKGZpbGVQYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCBmaWxlUGF0aCk7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy51bmxpbmsoZnVsbFBhdGgpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIG1ldGFkYXRhXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlTWV0YWRhdGFTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuZGVsZXRlKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0ZpbGUgZGVsZXRlZCBzdWNjZXNzZnVsbHknLCB7IGZpbGVQYXRoIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBmaWxlJywge1xuICAgICAgICAgICAgICAgIGZpbGVQYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCcsXG4gICAgICAgICAgICAgICAgZGF0YTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEZpbGVzKGRpcmVjdG9yeSA9ICcnLCBmaWx0ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxEaXJlY3RvcnkgPSBwYXRoLmpvaW4odGhpcy5jb25maWcuYmFzZURpcmVjdG9yeSwgZGlyZWN0b3J5KTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy5zY2FuRGlyZWN0b3J5KGZ1bGxEaXJlY3RvcnksIGRpcmVjdG9yeSk7XG4gICAgICAgICAgICBsZXQgZmlsdGVyZWRGaWxlcyA9IGZpbGVzO1xuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkRmlsZXMgPSBmaWxlcy5maWx0ZXIoZmlsZSA9PiB0aGlzLm1hdGNoZXNGaWx0ZXIoZmlsZSwgZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogZmlsdGVyZWRGaWxlcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gbGlzdCBmaWxlcycsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmaWxlRXhpc3RzKGZpbGVQYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCBmaWxlUGF0aCk7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5hY2Nlc3MoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5GX09LKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVEaXJlY3RvcnkoZGlyZWN0b3J5UGF0aCwgcmVjdXJzaXZlID0gdHJ1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4odGhpcy5jb25maWcuYmFzZURpcmVjdG9yeSwgZGlyZWN0b3J5UGF0aCk7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5ta2RpcihmdWxsUGF0aCwgeyByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZURpcmVjdG9yeShkaXJlY3RvcnlQYXRoLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4odGhpcy5jb25maWcuYmFzZURpcmVjdG9yeSwgZGlyZWN0b3J5UGF0aCk7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5ybWRpcihmdWxsUGF0aCwgeyByZWN1cnNpdmUgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG1vdmVGaWxlKHNvdXJjZVBhdGgsIGRlc3RpbmF0aW9uUGF0aCwgb3ZlcndyaXRlID0gZmFsc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxTb3VyY2VQYXRoID0gcGF0aC5qb2luKHRoaXMuY29uZmlnLmJhc2VEaXJlY3RvcnksIHNvdXJjZVBhdGgpO1xuICAgICAgICAgICAgY29uc3QgZnVsbERlc3RpbmF0aW9uUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCBkZXN0aW5hdGlvblBhdGgpO1xuICAgICAgICAgICAgaWYgKCFvdmVyd3JpdGUgJiYgYXdhaXQgdGhpcy5maWxlRXhpc3RzKGRlc3RpbmF0aW9uUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdEZXN0aW5hdGlvbiBmaWxlIGFscmVhZHkgZXhpc3RzJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMucmVuYW1lKGZ1bGxTb3VyY2VQYXRoLCBmdWxsRGVzdGluYXRpb25QYXRoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBtZXRhZGF0YSBjYWNoZVxuICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFDYWNoZS5oYXMoc291cmNlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFDYWNoZS5nZXQoc291cmNlUGF0aCk7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEucGF0aCA9IGRlc3RpbmF0aW9uUGF0aDtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5maWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoZGVzdGluYXRpb25QYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuc2V0KGRlc3RpbmF0aW9uUGF0aCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZS5kZWxldGUoc291cmNlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNvcHlGaWxlKHNvdXJjZVBhdGgsIGRlc3RpbmF0aW9uUGF0aCwgb3ZlcndyaXRlID0gZmFsc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxTb3VyY2VQYXRoID0gcGF0aC5qb2luKHRoaXMuY29uZmlnLmJhc2VEaXJlY3RvcnksIHNvdXJjZVBhdGgpO1xuICAgICAgICAgICAgY29uc3QgZnVsbERlc3RpbmF0aW9uUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCBkZXN0aW5hdGlvblBhdGgpO1xuICAgICAgICAgICAgaWYgKCFvdmVyd3JpdGUgJiYgYXdhaXQgdGhpcy5maWxlRXhpc3RzKGRlc3RpbmF0aW9uUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdEZXN0aW5hdGlvbiBmaWxlIGFscmVhZHkgZXhpc3RzJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMuY29weUZpbGUoZnVsbFNvdXJjZVBhdGgsIGZ1bGxEZXN0aW5hdGlvblBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRTdG9yYWdlU3RhdHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlU3RvcmFnZVN0YXRzKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogc3RhdHMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNlYXJjaEZpbGVzKHNlYXJjaFRlcm0sIGZpbHRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBhd2FpdCB0aGlzLmxpc3RGaWxlcygnJyk7XG4gICAgICAgICAgICBpZiAoIWFsbEZpbGVzLnN1Y2Nlc3MgfHwgIWFsbEZpbGVzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsRmlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hSZXN1bHRzID0gYWxsRmlsZXMuZGF0YS5maWx0ZXIoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlc1NlYXJjaCA9IGZpbGUuZmlsZW5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGZpbGUub3JpZ2luYWxOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoZmlsZS50YWdzICYmIGZpbGUudGFncy5zb21lKHRhZyA9PiB0YWcudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCkpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlc0ZpbHRlciA9IGZpbHRlciA/IHRoaXMubWF0Y2hlc0ZpbHRlcihmaWxlLCBmaWx0ZXIpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1NlYXJjaCAmJiBtYXRjaGVzRmlsdGVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogc2VhcmNoUmVzdWx0cyxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlRG93bmxvYWRVcmwoZmlsZVBhdGgsIGV4cGlyZXNJblNlY29uZHMgPSAzNjAwKSB7XG4gICAgICAgIC8vIEZvciBsb2NhbCBzdG9yYWdlLCB3ZSBjYW4gZ2VuZXJhdGUgYSBzaW1wbGUgdG9rZW4tYmFzZWQgVVJMXG4gICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3b3VsZCBiZSBtb3JlIHNlY3VyZVxuICAgICAgICBjb25zdCB0b2tlbiA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICAgIGNvbnN0IGV4cGlyeSA9IERhdGUubm93KCkgKyAoZXhwaXJlc0luU2Vjb25kcyAqIDEwMDApO1xuICAgICAgICAvLyBTdG9yZSB0b2tlbiBtYXBwaW5nIChpbiBtZW1vcnkgZm9yIHRoaXMgaW1wbGVtZW50YXRpb24pXG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHlvdSdkIHVzZSBSZWRpcyBvciBzaW1pbGFyXG4gICAgICAgIGNvbnN0IHVybCA9IGAvZG93bmxvYWQvJHt0b2tlbn0/cGF0aD0ke2VuY29kZVVSSUNvbXBvbmVudChmaWxlUGF0aCl9JmV4cGlyZXM9JHtleHBpcnl9YDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB1cmwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVGaWxlTWV0YWRhdGEoZmlsZVBhdGgsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldEZpbGVNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRNZXRhZGF0YS5zdWNjZXNzIHx8ICFjdXJyZW50TWV0YWRhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50TWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgLi4uY3VycmVudE1ldGFkYXRhLmRhdGEsXG4gICAgICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRBdDogbmV3IERhdGUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVNZXRhZGF0YVN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnN0b3JlTWV0YWRhdGEoZmlsZVBhdGgsIHVwZGF0ZWRNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuc2V0KGZpbGVQYXRoLCB1cGRhdGVkTWV0YWRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaXNIZWFsdGh5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYmFzZSBkaXJlY3RvcnkgaXMgYWNjZXNzaWJsZVxuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMuYWNjZXNzKHRoaXMuY29uZmlnLmJhc2VEaXJlY3RvcnksIGZzLmNvbnN0YW50cy5SX09LIHwgZnMuY29uc3RhbnRzLldfT0spO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0xvY2FsRmlsZVN0b3JhZ2UnO1xuICAgIH1cbiAgICBnZXRTdG9yYWdlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdsb2NhbCc7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFudXAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmlsZXNEZWxldGVkID0gMDtcbiAgICAgICAgICAgIGxldCBzcGFjZUZyZWVkID0gMDtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRlbXAgZGlyZWN0b3J5XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcudGVtcERpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBGaWxlcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRkaXIodGhpcy5jb25maWcudGVtcERpcmVjdG9yeSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIHRlbXBGaWxlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy50ZW1wRGlyZWN0b3J5LCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5wcm9taXNlcy5zdGF0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMudW5saW5rKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXNEZWxldGVkKys7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlRnJlZWQgKz0gc3RhdHMuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogeyBmaWxlc0RlbGV0ZWQsIHNwYWNlRnJlZWQgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJpdmF0ZSBoZWxwZXIgbWV0aG9kc1xuICAgIGdlbmVyYXRlVW5pcXVlRmlsZW5hbWUob3JpZ2luYWxOYW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKG9yaWdpbmFsTmFtZSk7XG4gICAgICAgIGNvbnN0IGJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShvcmlnaW5hbE5hbWUsIGV4dGVuc2lvbik7XG4gICAgICAgIHJldHVybiBgJHtiYXNlTmFtZX1fJHt0aW1lc3RhbXB9XyR7cmFuZG9tfSR7ZXh0ZW5zaW9ufWA7XG4gICAgfVxuICAgIGRldGVjdE1pbWVUeXBlKGZpbGVuYW1lKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShmaWxlbmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbWltZVR5cGVzID0ge1xuICAgICAgICAgICAgJy5wZGYnOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgICAgICAgICAgICcudHh0JzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgJy5kb2MnOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgICAgICAgICAgICcuZG9jeCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAnLnhscyc6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICAgICAgICAgICAgJy54bHN4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgICAgICAgICAgICcucHB0JzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JyxcbiAgICAgICAgICAgICcucHB0eCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICcuanBnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJy5qcGVnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJy5wbmcnOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgICcuZ2lmJzogJ2ltYWdlL2dpZicsXG4gICAgICAgICAgICAnLnN2Zyc6ICdpbWFnZS9zdmcreG1sJyxcbiAgICAgICAgICAgICcubXA0JzogJ3ZpZGVvL21wNCcsXG4gICAgICAgICAgICAnLm1wMyc6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgICAgICcuemlwJzogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICAgICAgICAnLmpzb24nOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnLnhtbCc6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgICAgICAgJy5jc3YnOiAndGV4dC9jc3YnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtaW1lVHlwZXNbZXh0ZW5zaW9uXSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICB9XG4gICAgYXN5bmMgc2NhbkRpcmVjdG9yeShmdWxsRGlyZWN0b3J5LCByZWxhdGl2ZURpcmVjdG9yeSkge1xuICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRkaXIoZnVsbERpcmVjdG9yeSwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHJlbGF0aXZlRGlyZWN0b3J5LCBlbnRyeS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFSZXN1bHQgPSBhd2FpdCB0aGlzLmdldEZpbGVNZXRhZGF0YShmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVJlc3VsdC5zdWNjZXNzICYmIG1ldGFkYXRhUmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2gobWV0YWRhdGFSZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRXJyb3Igc2Nhbm5pbmcgZGlyZWN0b3J5JywgeyBmdWxsRGlyZWN0b3J5LCBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZXM7XG4gICAgfVxuICAgIG1hdGNoZXNGaWx0ZXIoZmlsZSwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIuZXh0ZW5zaW9uICYmICFmaWx0ZXIuZXh0ZW5zaW9uLmluY2x1ZGVzKGZpbGUuZXh0ZW5zaW9uKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZpbHRlci5taW1lVHlwZSAmJiAhZmlsdGVyLm1pbWVUeXBlLmluY2x1ZGVzKGZpbGUubWltZVR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZmlsdGVyLnNpemVNaW4gJiYgZmlsZS5zaXplIDwgZmlsdGVyLnNpemVNaW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChmaWx0ZXIuc2l6ZU1heCAmJiBmaWxlLnNpemUgPiBmaWx0ZXIuc2l6ZU1heClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZpbHRlci51cGxvYWRlZEFmdGVyICYmIGZpbGUudXBsb2FkZWRBdCA8IGZpbHRlci51cGxvYWRlZEFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZmlsdGVyLnVwbG9hZGVkQmVmb3JlICYmIGZpbGUudXBsb2FkZWRBdCA+IGZpbHRlci51cGxvYWRlZEJlZm9yZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZpbHRlci50YWdzICYmIGZpbHRlci50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nVGFnID0gZmlsdGVyLnRhZ3Muc29tZSh0YWcgPT4gZmlsZS50YWdzPy5zb21lKGZpbGVUYWcgPT4gZmlsZVRhZy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRhZy50b0xvd2VyQ2FzZSgpKSkpO1xuICAgICAgICAgICAgaWYgKCFoYXNNYXRjaGluZ1RhZylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlci5zZWFyY2hUZXJtKSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hMb3dlciA9IGZpbHRlci5zZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzTmFtZSA9IGZpbGUuZmlsZW5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikgfHxcbiAgICAgICAgICAgICAgICBmaWxlLm9yaWdpbmFsTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaExvd2VyKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXNUYWdzID0gZmlsZS50YWdzPy5zb21lKHRhZyA9PiB0YWcudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcikpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzTmFtZSAmJiAhbWF0Y2hlc1RhZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBjYWxjdWxhdGVTdG9yYWdlU3RhdHMoKSB7XG4gICAgICAgIGxldCB0b3RhbEZpbGVzID0gMDtcbiAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IHNjYW5EaXIgPSBhc3luYyAoZGlyKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkZGlyKGRpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIGVudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMucHJvbWlzZXMuc3RhdChmdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEZpbGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNpemUgKz0gc3RhdHMuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzY2FuRGlyKGZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFcnJvciBjYWxjdWxhdGluZyBzdG9yYWdlIHN0YXRzJywgeyBkaXIsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCBzY2FuRGlyKHRoaXMuY29uZmlnLmJhc2VEaXJlY3RvcnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG90YWxGaWxlcyxcbiAgICAgICAgICAgIHRvdGFsU2l6ZSxcbiAgICAgICAgICAgIHVzZWRTcGFjZTogdG90YWxTaXplLFxuICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcmVNZXRhZGF0YShmaWxlUGF0aCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCAnLm1ldGFkYXRhJywgYCR7ZmlsZVBhdGh9Lmpzb25gKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhRGlyID0gcGF0aC5kaXJuYW1lKG1ldGFkYXRhUGF0aCk7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5ta2RpcihtZXRhZGF0YURpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUobWV0YWRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSwgbnVsbCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzdG9yZSBtZXRhZGF0YScsIHsgZmlsZVBhdGgsIGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxvYWRNZXRhZGF0YShmaWxlUGF0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFQYXRoID0gcGF0aC5qb2luKHRoaXMuY29uZmlnLmJhc2VEaXJlY3RvcnksICcubWV0YWRhdGEnLCBgJHtmaWxlUGF0aH0uanNvbmApO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFDb250ZW50ID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUobWV0YWRhdGFQYXRoLCAndXRmLTgnKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKG1ldGFkYXRhQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlTWV0YWRhdGEoZmlsZVBhdGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhUGF0aCA9IHBhdGguam9pbih0aGlzLmNvbmZpZy5iYXNlRGlyZWN0b3J5LCAnLm1ldGFkYXRhJywgYCR7ZmlsZVBhdGh9Lmpzb25gKTtcbiAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLnVubGluayhtZXRhZGF0YVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE1ldGFkYXRhIGZpbGUgbWlnaHQgbm90IGV4aXN0LCB3aGljaCBpcyBmaW5lXG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxvY2FsRmlsZVN0b3JhZ2UgPSBMb2NhbEZpbGVTdG9yYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9jYWxGaWxlU3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/LocalFileStorage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// File Storage Adapter Exports\n// Central export point for file storage adapters and related types\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileStorageServiceFactory = exports.LocalFileStorage = void 0;\nvar LocalFileStorage_1 = __webpack_require__(/*! ./LocalFileStorage */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/LocalFileStorage.js\");\nObject.defineProperty(exports, \"LocalFileStorage\", ({ enumerable: true, get: function () { return LocalFileStorage_1.LocalFileStorage; } }));\nvar FileStorageServiceFactory_1 = __webpack_require__(/*! ./FileStorageServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/FileStorageServiceFactory.js\");\nObject.defineProperty(exports, \"FileStorageServiceFactory\", ({ enumerable: true, get: function () { return FileStorageServiceFactory_1.FileStorageServiceFactory; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3N0b3JhZ2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLHdCQUF3QjtBQUM1RCx5QkFBeUIsbUJBQU8sQ0FBQyxtSUFBb0I7QUFDckQsb0RBQW1ELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQzFJLGtDQUFrQyxtQkFBTyxDQUFDLHFKQUE2QjtBQUN2RSw2REFBNEQsRUFBRSxxQ0FBcUMsaUVBQWlFLEVBQUM7QUFDcksiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3N0b3JhZ2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBGaWxlIFN0b3JhZ2UgQWRhcHRlciBFeHBvcnRzXG4vLyBDZW50cmFsIGV4cG9ydCBwb2ludCBmb3IgZmlsZSBzdG9yYWdlIGFkYXB0ZXJzIGFuZCByZWxhdGVkIHR5cGVzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbGVTdG9yYWdlU2VydmljZUZhY3RvcnkgPSBleHBvcnRzLkxvY2FsRmlsZVN0b3JhZ2UgPSB2b2lkIDA7XG52YXIgTG9jYWxGaWxlU3RvcmFnZV8xID0gcmVxdWlyZShcIi4vTG9jYWxGaWxlU3RvcmFnZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvY2FsRmlsZVN0b3JhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIExvY2FsRmlsZVN0b3JhZ2VfMS5Mb2NhbEZpbGVTdG9yYWdlOyB9IH0pO1xudmFyIEZpbGVTdG9yYWdlU2VydmljZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL0ZpbGVTdG9yYWdlU2VydmljZUZhY3RvcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWxlU3RvcmFnZVNlcnZpY2VGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBGaWxlU3RvcmFnZVNlcnZpY2VGYWN0b3J5XzEuRmlsZVN0b3JhZ2VTZXJ2aWNlRmFjdG9yeTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyServiceFactory.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyServiceFactory.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TavilyServiceFactory = void 0;\nexports.createTavilyServiceFactory = createTavilyServiceFactory;\nconst TavilyWebSearcher_1 = __webpack_require__(/*! ./TavilyWebSearcher */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyWebSearcher.js\");\nconst ErrorHandler_1 = __webpack_require__(/*! ../../utils/ErrorHandler */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js\");\nconst ErrorTypes_1 = __webpack_require__(/*! ../../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass TavilyServiceFactory {\n    create(config, logger) {\n        if (!config.services.tavily) {\n            throw new ErrorTypes_1.ValidationError('Tavily configuration is required for web search');\n        }\n        const errorHandler = new ErrorHandler_1.FrameworkErrorHandler(config.retry);\n        return new TavilyWebSearcher_1.TavilyWebSearcher(config.services.tavily, logger, errorHandler);\n    }\n    getServiceName() {\n        return 'webSearcher';\n    }\n}\nexports.TavilyServiceFactory = TavilyServiceFactory;\nfunction createTavilyServiceFactory() {\n    return new TavilyServiceFactory();\n}\n//# sourceMappingURL=TavilyServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3RhdmlseS9UYXZpbHlTZXJ2aWNlRmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLG9JQUFxQjtBQUN6RCx1QkFBdUIsbUJBQU8sQ0FBQywwSEFBMEI7QUFDekQscUJBQXFCLG1CQUFPLENBQUMsZ0lBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvdGF2aWx5L1RhdmlseVNlcnZpY2VGYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYXZpbHlTZXJ2aWNlRmFjdG9yeSA9IHZvaWQgMDtcbmV4cG9ydHMuY3JlYXRlVGF2aWx5U2VydmljZUZhY3RvcnkgPSBjcmVhdGVUYXZpbHlTZXJ2aWNlRmFjdG9yeTtcbmNvbnN0IFRhdmlseVdlYlNlYXJjaGVyXzEgPSByZXF1aXJlKFwiLi9UYXZpbHlXZWJTZWFyY2hlclwiKTtcbmNvbnN0IEVycm9ySGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0Vycm9ySGFuZGxlclwiKTtcbmNvbnN0IEVycm9yVHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3R5cGVzL0Vycm9yVHlwZXNcIik7XG5jbGFzcyBUYXZpbHlTZXJ2aWNlRmFjdG9yeSB7XG4gICAgY3JlYXRlKGNvbmZpZywgbG9nZ2VyKSB7XG4gICAgICAgIGlmICghY29uZmlnLnNlcnZpY2VzLnRhdmlseSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yVHlwZXNfMS5WYWxpZGF0aW9uRXJyb3IoJ1RhdmlseSBjb25maWd1cmF0aW9uIGlzIHJlcXVpcmVkIGZvciB3ZWIgc2VhcmNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcl8xLkZyYW1ld29ya0Vycm9ySGFuZGxlcihjb25maWcucmV0cnkpO1xuICAgICAgICByZXR1cm4gbmV3IFRhdmlseVdlYlNlYXJjaGVyXzEuVGF2aWx5V2ViU2VhcmNoZXIoY29uZmlnLnNlcnZpY2VzLnRhdmlseSwgbG9nZ2VyLCBlcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd3ZWJTZWFyY2hlcic7XG4gICAgfVxufVxuZXhwb3J0cy5UYXZpbHlTZXJ2aWNlRmFjdG9yeSA9IFRhdmlseVNlcnZpY2VGYWN0b3J5O1xuZnVuY3Rpb24gY3JlYXRlVGF2aWx5U2VydmljZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBUYXZpbHlTZXJ2aWNlRmFjdG9yeSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGF2aWx5U2VydmljZUZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyWebSearcher.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyWebSearcher.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TavilyWebSearcher = void 0;\nconst ErrorTypes_1 = __webpack_require__(/*! ../../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass TavilyWebSearcher {\n    constructor(config, logger, errorHandler) {\n        this.config = config;\n        this.logger = logger;\n        this.errorHandler = errorHandler;\n        this.baseUrl = config.baseUrl || 'https://api.tavily.com';\n        this.validateConfig();\n    }\n    /**\n     * Perform a web search with the given query\n     */\n    async search(request) {\n        this.logger.info('Starting Tavily web search', { query: request.query });\n        try {\n            const result = await this.errorHandler.executeWithRetry(() => this.performSearch(request), { service: 'tavily', operation: 'search' });\n            this.logger.info('Tavily web search completed', {\n                query: request.query,\n                resultCount: result.results.length\n            });\n            return {\n                success: true,\n                data: result\n            };\n        }\n        catch (error) {\n            const frameworkError = this.errorHandler.handle(error, 'tavily', 'search');\n            this.logger.error('Tavily web search failed', { error: frameworkError.message }, error);\n            return {\n                success: false,\n                error: frameworkError.message\n            };\n        }\n    }\n    /**\n     * Perform a paginated web search\n     */\n    async searchPaginated(request, pagination) {\n        // Tavily doesn't support true pagination, so we'll simulate it\n        const limit = pagination.limit || 10;\n        const offset = pagination.offset || 0;\n        const adjustedRequest = {\n            ...request,\n            maxResults: Math.min(offset + limit, 20) // Tavily max is usually 20\n        };\n        const searchResult = await this.search(adjustedRequest);\n        if (!searchResult.success || !searchResult.data) {\n            return {\n                success: false,\n                error: searchResult.error || 'Search failed'\n            };\n        }\n        const paginatedResults = searchResult.data.results.slice(offset, offset + limit);\n        return {\n            success: true,\n            data: {\n                data: paginatedResults,\n                pagination: {\n                    total: searchResult.data.results.length,\n                    hasMore: offset + limit < searchResult.data.results.length,\n                    nextCursor: offset + limit < searchResult.data.results.length ? (offset + limit).toString() : undefined\n                }\n            }\n        };\n    }\n    /**\n     * Search for recent news articles\n     */\n    async searchNews(query, maxResults = 5) {\n        return this.search({\n            query: `${query} news recent`,\n            maxResults,\n            searchDepth: 'basic'\n        });\n    }\n    /**\n     * Search for academic papers or research\n     */\n    async searchAcademic(query, maxResults = 5) {\n        return this.search({\n            query: `${query} academic research paper`,\n            maxResults,\n            searchDepth: 'advanced'\n        });\n    }\n    /**\n     * Get search suggestions (not supported by Tavily, returns empty)\n     */\n    async getSuggestions(partialQuery) {\n        this.logger.warn('Search suggestions not supported by Tavily', { partialQuery });\n        return {\n            success: true,\n            data: []\n        };\n    }\n    /**\n     * Check if the service is available and configured properly\n     */\n    async isHealthy() {\n        try {\n            // Perform a simple test search\n            const result = await this.performSearch({\n                query: 'test',\n                maxResults: 1,\n                searchDepth: 'basic'\n            });\n            return result.results.length >= 0; // Even 0 results means the API is working\n        }\n        catch (error) {\n            this.logger.error('Tavily health check failed', { error: error.message });\n            return false;\n        }\n    }\n    /**\n     * Get service name for health check\n     */\n    getServiceName() {\n        return 'Tavily Web Search';\n    }\n    /**\n     * Perform the actual search request to Tavily API\n     */\n    async performSearch(request) {\n        const tavilyRequest = {\n            query: request.query,\n            search_depth: request.searchDepth || 'basic',\n            max_results: Math.min(request.maxResults || 5, 20), // Tavily typically limits to 20\n            include_answer: true,\n            include_raw_content: false,\n            include_images: false\n        };\n        if (request.includeDomains && request.includeDomains.length > 0) {\n            tavilyRequest.include_domains = request.includeDomains;\n        }\n        if (request.excludeDomains && request.excludeDomains.length > 0) {\n            tavilyRequest.exclude_domains = request.excludeDomains;\n        }\n        const response = await this.makeApiCall('/search', tavilyRequest);\n        return {\n            query: response.query,\n            results: response.results.map(result => ({\n                title: result.title,\n                url: result.url,\n                content: result.content,\n                publishedDate: result.published_date ? new Date(result.published_date) : undefined,\n                score: result.score\n            })),\n            totalResults: response.results.length,\n            answer: response.answer\n        };\n    }\n    /**\n     * Make HTTP request to Tavily API\n     */\n    async makeApiCall(endpoint, data) {\n        const url = `${this.baseUrl}${endpoint}`;\n        const timeout = this.config.timeout || 30000;\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n        try {\n            const response = await fetch(url, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.config.apiKey}`\n                },\n                body: JSON.stringify(data),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new ErrorTypes_1.ServiceUnavailableError(`Tavily API request failed: ${response.status} ${response.statusText}. ${errorText}`, 'tavily');\n            }\n            const result = await response.json();\n            return result;\n        }\n        catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new ErrorTypes_1.TimeoutError('Tavily API request timed out', 'tavily');\n            }\n            throw error;\n        }\n    }\n    /**\n     * Validate the Tavily configuration\n     */\n    validateConfig() {\n        if (!this.config.apiKey) {\n            throw new ErrorTypes_1.ValidationError('Tavily API key is required');\n        }\n        if (this.config.timeout && (this.config.timeout < 1000 || this.config.timeout > 120000)) {\n            throw new ErrorTypes_1.ValidationError('Tavily timeout must be between 1000ms and 120000ms');\n        }\n        if (this.config.searchDepth && !['basic', 'advanced'].includes(this.config.searchDepth)) {\n            throw new ErrorTypes_1.ValidationError('Tavily search depth must be either \"basic\" or \"advanced\"');\n        }\n    }\n}\nexports.TavilyWebSearcher = TavilyWebSearcher;\n//# sourceMappingURL=TavilyWebSearcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3RhdmlseS9UYXZpbHlXZWJTZWFyY2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIscUJBQXFCLG1CQUFPLENBQUMsZ0lBQTZCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQSx5R0FBeUcsd0NBQXdDO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwrQkFBK0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsY0FBYztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSw4REFBOEQsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsRUFBRSxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CO0FBQ2xFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixpQkFBaUIsRUFBRSxvQkFBb0IsSUFBSSxVQUFVO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvdGF2aWx5L1RhdmlseVdlYlNlYXJjaGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYXZpbHlXZWJTZWFyY2hlciA9IHZvaWQgMDtcbmNvbnN0IEVycm9yVHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3R5cGVzL0Vycm9yVHlwZXNcIik7XG5jbGFzcyBUYXZpbHlXZWJTZWFyY2hlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBsb2dnZXIsIGVycm9ySGFuZGxlcikge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBjb25maWcuYmFzZVVybCB8fCAnaHR0cHM6Ly9hcGkudGF2aWx5LmNvbSc7XG4gICAgICAgIHRoaXMudmFsaWRhdGVDb25maWcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHdlYiBzZWFyY2ggd2l0aCB0aGUgZ2l2ZW4gcXVlcnlcbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2gocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyBUYXZpbHkgd2ViIHNlYXJjaCcsIHsgcXVlcnk6IHJlcXVlc3QucXVlcnkgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmVycm9ySGFuZGxlci5leGVjdXRlV2l0aFJldHJ5KCgpID0+IHRoaXMucGVyZm9ybVNlYXJjaChyZXF1ZXN0KSwgeyBzZXJ2aWNlOiAndGF2aWx5Jywgb3BlcmF0aW9uOiAnc2VhcmNoJyB9KTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1RhdmlseSB3ZWIgc2VhcmNoIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgICAgICAgICBxdWVyeTogcmVxdWVzdC5xdWVyeSxcbiAgICAgICAgICAgICAgICByZXN1bHRDb3VudDogcmVzdWx0LnJlc3VsdHMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXdvcmtFcnJvciA9IHRoaXMuZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgJ3RhdmlseScsICdzZWFyY2gnKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdUYXZpbHkgd2ViIHNlYXJjaCBmYWlsZWQnLCB7IGVycm9yOiBmcmFtZXdvcmtFcnJvci5tZXNzYWdlIH0sIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZyYW1ld29ya0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHBhZ2luYXRlZCB3ZWIgc2VhcmNoXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoUGFnaW5hdGVkKHJlcXVlc3QsIHBhZ2luYXRpb24pIHtcbiAgICAgICAgLy8gVGF2aWx5IGRvZXNuJ3Qgc3VwcG9ydCB0cnVlIHBhZ2luYXRpb24sIHNvIHdlJ2xsIHNpbXVsYXRlIGl0XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gcGFnaW5hdGlvbi5saW1pdCB8fCAxMDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFnaW5hdGlvbi5vZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgICAgIG1heFJlc3VsdHM6IE1hdGgubWluKG9mZnNldCArIGxpbWl0LCAyMCkgLy8gVGF2aWx5IG1heCBpcyB1c3VhbGx5IDIwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNlYXJjaFJlc3VsdCA9IGF3YWl0IHRoaXMuc2VhcmNoKGFkanVzdGVkUmVxdWVzdCk7XG4gICAgICAgIGlmICghc2VhcmNoUmVzdWx0LnN1Y2Nlc3MgfHwgIXNlYXJjaFJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBzZWFyY2hSZXN1bHQuZXJyb3IgfHwgJ1NlYXJjaCBmYWlsZWQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2luYXRlZFJlc3VsdHMgPSBzZWFyY2hSZXN1bHQuZGF0YS5yZXN1bHRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBwYWdpbmF0ZWRSZXN1bHRzLFxuICAgICAgICAgICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IHNlYXJjaFJlc3VsdC5kYXRhLnJlc3VsdHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBoYXNNb3JlOiBvZmZzZXQgKyBsaW1pdCA8IHNlYXJjaFJlc3VsdC5kYXRhLnJlc3VsdHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBuZXh0Q3Vyc29yOiBvZmZzZXQgKyBsaW1pdCA8IHNlYXJjaFJlc3VsdC5kYXRhLnJlc3VsdHMubGVuZ3RoID8gKG9mZnNldCArIGxpbWl0KS50b1N0cmluZygpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIHJlY2VudCBuZXdzIGFydGljbGVzXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoTmV3cyhxdWVyeSwgbWF4UmVzdWx0cyA9IDUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoKHtcbiAgICAgICAgICAgIHF1ZXJ5OiBgJHtxdWVyeX0gbmV3cyByZWNlbnRgLFxuICAgICAgICAgICAgbWF4UmVzdWx0cyxcbiAgICAgICAgICAgIHNlYXJjaERlcHRoOiAnYmFzaWMnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGFjYWRlbWljIHBhcGVycyBvciByZXNlYXJjaFxuICAgICAqL1xuICAgIGFzeW5jIHNlYXJjaEFjYWRlbWljKHF1ZXJ5LCBtYXhSZXN1bHRzID0gNSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2goe1xuICAgICAgICAgICAgcXVlcnk6IGAke3F1ZXJ5fSBhY2FkZW1pYyByZXNlYXJjaCBwYXBlcmAsXG4gICAgICAgICAgICBtYXhSZXN1bHRzLFxuICAgICAgICAgICAgc2VhcmNoRGVwdGg6ICdhZHZhbmNlZCdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZWFyY2ggc3VnZ2VzdGlvbnMgKG5vdCBzdXBwb3J0ZWQgYnkgVGF2aWx5LCByZXR1cm5zIGVtcHR5KVxuICAgICAqL1xuICAgIGFzeW5jIGdldFN1Z2dlc3Rpb25zKHBhcnRpYWxRdWVyeSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdTZWFyY2ggc3VnZ2VzdGlvbnMgbm90IHN1cHBvcnRlZCBieSBUYXZpbHknLCB7IHBhcnRpYWxRdWVyeSB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc2VydmljZSBpcyBhdmFpbGFibGUgYW5kIGNvbmZpZ3VyZWQgcHJvcGVybHlcbiAgICAgKi9cbiAgICBhc3luYyBpc0hlYWx0aHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIGEgc2ltcGxlIHRlc3Qgc2VhcmNoXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBlcmZvcm1TZWFyY2goe1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiAndGVzdCcsXG4gICAgICAgICAgICAgICAgbWF4UmVzdWx0czogMSxcbiAgICAgICAgICAgICAgICBzZWFyY2hEZXB0aDogJ2Jhc2ljJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdHMubGVuZ3RoID49IDA7IC8vIEV2ZW4gMCByZXN1bHRzIG1lYW5zIHRoZSBBUEkgaXMgd29ya2luZ1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1RhdmlseSBoZWFsdGggY2hlY2sgZmFpbGVkJywgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2VydmljZSBuYW1lIGZvciBoZWFsdGggY2hlY2tcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdUYXZpbHkgV2ViIFNlYXJjaCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBzZWFyY2ggcmVxdWVzdCB0byBUYXZpbHkgQVBJXG4gICAgICovXG4gICAgYXN5bmMgcGVyZm9ybVNlYXJjaChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHRhdmlseVJlcXVlc3QgPSB7XG4gICAgICAgICAgICBxdWVyeTogcmVxdWVzdC5xdWVyeSxcbiAgICAgICAgICAgIHNlYXJjaF9kZXB0aDogcmVxdWVzdC5zZWFyY2hEZXB0aCB8fCAnYmFzaWMnLFxuICAgICAgICAgICAgbWF4X3Jlc3VsdHM6IE1hdGgubWluKHJlcXVlc3QubWF4UmVzdWx0cyB8fCA1LCAyMCksIC8vIFRhdmlseSB0eXBpY2FsbHkgbGltaXRzIHRvIDIwXG4gICAgICAgICAgICBpbmNsdWRlX2Fuc3dlcjogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1ZGVfcmF3X2NvbnRlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgaW5jbHVkZV9pbWFnZXM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXF1ZXN0LmluY2x1ZGVEb21haW5zICYmIHJlcXVlc3QuaW5jbHVkZURvbWFpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGF2aWx5UmVxdWVzdC5pbmNsdWRlX2RvbWFpbnMgPSByZXF1ZXN0LmluY2x1ZGVEb21haW5zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0LmV4Y2x1ZGVEb21haW5zICYmIHJlcXVlc3QuZXhjbHVkZURvbWFpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGF2aWx5UmVxdWVzdC5leGNsdWRlX2RvbWFpbnMgPSByZXF1ZXN0LmV4Y2x1ZGVEb21haW5zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlQXBpQ2FsbCgnL3NlYXJjaCcsIHRhdmlseVJlcXVlc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVlcnk6IHJlc3BvbnNlLnF1ZXJ5LFxuICAgICAgICAgICAgcmVzdWx0czogcmVzcG9uc2UucmVzdWx0cy5tYXAocmVzdWx0ID0+ICh7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHJlc3VsdC50aXRsZSxcbiAgICAgICAgICAgICAgICB1cmw6IHJlc3VsdC51cmwsXG4gICAgICAgICAgICAgICAgY29udGVudDogcmVzdWx0LmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgcHVibGlzaGVkRGF0ZTogcmVzdWx0LnB1Ymxpc2hlZF9kYXRlID8gbmV3IERhdGUocmVzdWx0LnB1Ymxpc2hlZF9kYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzY29yZTogcmVzdWx0LnNjb3JlXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB0b3RhbFJlc3VsdHM6IHJlc3BvbnNlLnJlc3VsdHMubGVuZ3RoLFxuICAgICAgICAgICAgYW5zd2VyOiByZXNwb25zZS5hbnN3ZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBIVFRQIHJlcXVlc3QgdG8gVGF2aWx5IEFQSVxuICAgICAqL1xuICAgIGFzeW5jIG1ha2VBcGlDYWxsKGVuZHBvaW50LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2VuZHBvaW50fWA7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLmNvbmZpZy50aW1lb3V0IHx8IDMwMDAwO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dGhpcy5jb25maWcuYXBpS2V5fWBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvclR5cGVzXzEuU2VydmljZVVuYXZhaWxhYmxlRXJyb3IoYFRhdmlseSBBUEkgcmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LiAke2Vycm9yVGV4dH1gLCAndGF2aWx5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JUeXBlc18xLlRpbWVvdXRFcnJvcignVGF2aWx5IEFQSSByZXF1ZXN0IHRpbWVkIG91dCcsICd0YXZpbHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBUYXZpbHkgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIHZhbGlkYXRlQ29uZmlnKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yVHlwZXNfMS5WYWxpZGF0aW9uRXJyb3IoJ1RhdmlseSBBUEkga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRpbWVvdXQgJiYgKHRoaXMuY29uZmlnLnRpbWVvdXQgPCAxMDAwIHx8IHRoaXMuY29uZmlnLnRpbWVvdXQgPiAxMjAwMDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JUeXBlc18xLlZhbGlkYXRpb25FcnJvcignVGF2aWx5IHRpbWVvdXQgbXVzdCBiZSBiZXR3ZWVuIDEwMDBtcyBhbmQgMTIwMDAwbXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcuc2VhcmNoRGVwdGggJiYgIVsnYmFzaWMnLCAnYWR2YW5jZWQnXS5pbmNsdWRlcyh0aGlzLmNvbmZpZy5zZWFyY2hEZXB0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvclR5cGVzXzEuVmFsaWRhdGlvbkVycm9yKCdUYXZpbHkgc2VhcmNoIGRlcHRoIG11c3QgYmUgZWl0aGVyIFwiYmFzaWNcIiBvciBcImFkdmFuY2VkXCInKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGF2aWx5V2ViU2VhcmNoZXIgPSBUYXZpbHlXZWJTZWFyY2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhdmlseVdlYlNlYXJjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyWebSearcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createTavilyServiceFactory = exports.TavilyServiceFactory = exports.TavilyWebSearcher = void 0;\n// Tavily Web Search adapter exports\nvar TavilyWebSearcher_1 = __webpack_require__(/*! ./TavilyWebSearcher */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyWebSearcher.js\");\nObject.defineProperty(exports, \"TavilyWebSearcher\", ({ enumerable: true, get: function () { return TavilyWebSearcher_1.TavilyWebSearcher; } }));\nvar TavilyServiceFactory_1 = __webpack_require__(/*! ./TavilyServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/TavilyServiceFactory.js\");\nObject.defineProperty(exports, \"TavilyServiceFactory\", ({ enumerable: true, get: function () { return TavilyServiceFactory_1.TavilyServiceFactory; } }));\nObject.defineProperty(exports, \"createTavilyServiceFactory\", ({ enumerable: true, get: function () { return TavilyServiceFactory_1.createTavilyServiceFactory; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3RhdmlseS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDN0Y7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxvSUFBcUI7QUFDdkQscURBQW9ELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzdJLDZCQUE2QixtQkFBTyxDQUFDLDBJQUF3QjtBQUM3RCx3REFBdUQsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDdEosOERBQTZELEVBQUUscUNBQXFDLDZEQUE2RCxFQUFDO0FBQ2xLIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy90YXZpbHkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVRhdmlseVNlcnZpY2VGYWN0b3J5ID0gZXhwb3J0cy5UYXZpbHlTZXJ2aWNlRmFjdG9yeSA9IGV4cG9ydHMuVGF2aWx5V2ViU2VhcmNoZXIgPSB2b2lkIDA7XG4vLyBUYXZpbHkgV2ViIFNlYXJjaCBhZGFwdGVyIGV4cG9ydHNcbnZhciBUYXZpbHlXZWJTZWFyY2hlcl8xID0gcmVxdWlyZShcIi4vVGF2aWx5V2ViU2VhcmNoZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUYXZpbHlXZWJTZWFyY2hlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVGF2aWx5V2ViU2VhcmNoZXJfMS5UYXZpbHlXZWJTZWFyY2hlcjsgfSB9KTtcbnZhciBUYXZpbHlTZXJ2aWNlRmFjdG9yeV8xID0gcmVxdWlyZShcIi4vVGF2aWx5U2VydmljZUZhY3RvcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUYXZpbHlTZXJ2aWNlRmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVGF2aWx5U2VydmljZUZhY3RvcnlfMS5UYXZpbHlTZXJ2aWNlRmFjdG9yeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVRhdmlseVNlcnZpY2VGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBUYXZpbHlTZXJ2aWNlRmFjdG9yeV8xLmNyZWF0ZVRhdmlseVNlcnZpY2VGYWN0b3J5OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/LangChainTextChunker.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/LangChainTextChunker.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// LangChain Text Chunker Implementation\n// Provides text chunking using LangChain's RecursiveCharacterTextSplitter\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LangChainTextChunker = void 0;\nconst textsplitters_1 = __webpack_require__(/*! @langchain/textsplitters */ \"(rsc)/./node_modules/@langchain/textsplitters/index.cjs\");\nclass LangChainTextChunker {\n    constructor(config, logger) {\n        this.usageStats = {\n            totalRequests: 0,\n            totalTextProcessed: 0,\n            totalChunksGenerated: 0,\n            totalProcessingTime: 0\n        };\n        this.config = config;\n        this.logger = logger;\n        this.defaultChunkSize = config.defaultChunkSize || 1000;\n        this.defaultOverlap = config.defaultOverlap || 200;\n        this.defaultStrategy = config.defaultStrategy || 'recursive';\n        this.logger.info('LangChain Text Chunker initialized', {\n            defaultChunkSize: this.defaultChunkSize,\n            defaultOverlap: this.defaultOverlap,\n            defaultStrategy: this.defaultStrategy\n        });\n    }\n    /**\n     * Chunk text into smaller pieces\n     */\n    async chunkText(request) {\n        const startTime = Date.now();\n        try {\n            const strategy = request.strategy || this.defaultStrategy;\n            const chunkSize = request.chunkSize || this.defaultChunkSize;\n            const chunkOverlap = request.chunkOverlap || this.defaultOverlap;\n            this.logger.debug('Chunking text', {\n                textLength: request.text.length,\n                strategy,\n                chunkSize,\n                chunkOverlap\n            });\n            // Validate inputs\n            if (!request.text || request.text.trim().length === 0) {\n                return {\n                    success: false,\n                    error: 'No text provided for chunking'\n                };\n            }\n            if (chunkSize <= 0 || chunkOverlap < 0) {\n                return {\n                    success: false,\n                    error: 'Invalid chunk size or overlap parameters'\n                };\n            }\n            if (chunkOverlap >= chunkSize) {\n                return {\n                    success: false,\n                    error: 'Chunk overlap must be less than chunk size'\n                };\n            }\n            // Create chunker based on strategy\n            let chunks;\n            switch (strategy) {\n                case 'recursive':\n                    chunks = await this.chunkWithRecursive(request.text, chunkSize, chunkOverlap, request.separators, request.keepSeparator);\n                    break;\n                case 'character':\n                    chunks = await this.chunkWithCharacter(request.text, chunkSize, chunkOverlap);\n                    break;\n                default:\n                    chunks = await this.chunkWithRecursive(request.text, chunkSize, chunkOverlap, request.separators, request.keepSeparator);\n            }\n            const processingTime = Date.now() - startTime;\n            // Update usage stats\n            this.usageStats.totalRequests++;\n            this.usageStats.totalTextProcessed += request.text.length;\n            this.usageStats.totalChunksGenerated += chunks.length;\n            this.usageStats.totalProcessingTime += processingTime;\n            // Calculate average chunk size\n            const averageChunkSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0) / chunks.length;\n            this.logger.debug('Text chunking completed', {\n                totalChunks: chunks.length,\n                averageChunkSize: Math.round(averageChunkSize),\n                processingTime\n            });\n            return {\n                success: true,\n                data: {\n                    chunks,\n                    metadata: {\n                        totalChunks: chunks.length,\n                        averageChunkSize: Math.round(averageChunkSize),\n                        processingTime,\n                        strategy\n                    }\n                }\n            };\n        }\n        catch (error) {\n            const processingTime = Date.now() - startTime;\n            this.logger.error('Text chunking failed', {\n                error: error.message,\n                processingTime\n            });\n            return {\n                success: false,\n                error: `Text chunking failed: ${error.message}`\n            };\n        }\n    }\n    /**\n     * Chunk text with simple parameters - convenience method\n     */\n    async chunkTextSimple(text, chunkSize, overlap) {\n        const result = await this.chunkText({\n            text,\n            chunkSize,\n            chunkOverlap: overlap\n        });\n        if (!result.success) {\n            return {\n                success: false,\n                error: result.error\n            };\n        }\n        return {\n            success: true,\n            data: result.data.chunks\n        };\n    }\n    /**\n     * Chunk multiple texts in batch\n     */\n    async chunkBatch(texts, chunkSize, overlap) {\n        try {\n            const results = [];\n            for (const text of texts) {\n                const result = await this.chunkTextSimple(text, chunkSize, overlap);\n                if (!result.success) {\n                    return {\n                        success: false,\n                        error: `Batch chunking failed: ${result.error}`\n                    };\n                }\n                results.push(result.data);\n            }\n            return {\n                success: true,\n                data: results\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: `Batch chunking failed: ${error.message}`\n            };\n        }\n    }\n    /**\n     * Get available chunking strategies\n     */\n    getAvailableStrategies() {\n        return [\n            {\n                name: 'recursive',\n                description: 'Recursively splits text by trying different separators in order',\n                defaultChunkSize: 1000,\n                defaultOverlap: 200,\n                supportsSeparators: true\n            },\n            {\n                name: 'character',\n                description: 'Simple character-based splitting',\n                defaultChunkSize: 1000,\n                defaultOverlap: 200,\n                supportsSeparators: false\n            }\n        ];\n    }\n    /**\n     * Get default strategy name\n     */\n    getDefaultStrategy() {\n        return this.defaultStrategy;\n    }\n    /**\n     * Estimate optimal chunk size for given text and target\n     */\n    estimateOptimalChunkSize(text, targetTokens = 1000) {\n        // Rough estimation: 1 token â 3-4 characters for English text\n        const estimatedCharsPerToken = 3.5;\n        const recommendedChars = Math.round(targetTokens * estimatedCharsPerToken);\n        // Ensure it's within reasonable bounds\n        return Math.max(100, Math.min(recommendedChars, 10000));\n    }\n    /**\n     * Check if the service is healthy\n     */\n    async isHealthy() {\n        try {\n            const testResult = await this.chunkTextSimple('Health check test text for chunking service.');\n            return testResult.success;\n        }\n        catch (error) {\n            this.logger.error('Text chunker health check failed', {\n                error: error.message\n            });\n            return false;\n        }\n    }\n    /**\n     * Get service name for health checks\n     */\n    getServiceName() {\n        return 'LangChain Text Chunker';\n    }\n    /**\n     * Get usage statistics\n     */\n    getUsageStats() {\n        return {\n            totalRequests: this.usageStats.totalRequests,\n            totalTextProcessed: this.usageStats.totalTextProcessed,\n            totalChunksGenerated: this.usageStats.totalChunksGenerated,\n            averageProcessingTime: this.usageStats.totalRequests > 0\n                ? this.usageStats.totalProcessingTime / this.usageStats.totalRequests\n                : 0\n        };\n    }\n    /**\n     * Chunk text using RecursiveCharacterTextSplitter\n     */\n    async chunkWithRecursive(text, chunkSize, chunkOverlap, separators, keepSeparator) {\n        const defaultSeparators = [\"\\n\\n\", \"\\n\", \" \", \"\"];\n        const splitter = new textsplitters_1.RecursiveCharacterTextSplitter({\n            chunkSize,\n            chunkOverlap,\n            separators: separators || defaultSeparators,\n            keepSeparator: keepSeparator || false\n        });\n        return await splitter.splitText(text);\n    }\n    /**\n     * Chunk text using simple character-based splitting\n     */\n    async chunkWithCharacter(text, chunkSize, chunkOverlap) {\n        const chunks = [];\n        let start = 0;\n        while (start < text.length) {\n            const end = Math.min(start + chunkSize, text.length);\n            const chunk = text.slice(start, end);\n            chunks.push(chunk);\n            // Move start position considering overlap\n            start = end - chunkOverlap;\n            if (start <= 0)\n                start = end;\n        }\n        return chunks.filter(chunk => chunk.trim().length > 0);\n    }\n}\nexports.LangChainTextChunker = LangChainTextChunker;\n//# sourceMappingURL=LangChainTextChunker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3RleHRwcm9jZXNzaW5nL0xhbmdDaGFpblRleHRDaHVua2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUIsd0JBQXdCLG1CQUFPLENBQUMseUZBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvdGV4dHByb2Nlc3NpbmcvTGFuZ0NoYWluVGV4dENodW5rZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBMYW5nQ2hhaW4gVGV4dCBDaHVua2VyIEltcGxlbWVudGF0aW9uXG4vLyBQcm92aWRlcyB0ZXh0IGNodW5raW5nIHVzaW5nIExhbmdDaGFpbidzIFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYW5nQ2hhaW5UZXh0Q2h1bmtlciA9IHZvaWQgMDtcbmNvbnN0IHRleHRzcGxpdHRlcnNfMSA9IHJlcXVpcmUoXCJAbGFuZ2NoYWluL3RleHRzcGxpdHRlcnNcIik7XG5jbGFzcyBMYW5nQ2hhaW5UZXh0Q2h1bmtlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy51c2FnZVN0YXRzID0ge1xuICAgICAgICAgICAgdG90YWxSZXF1ZXN0czogMCxcbiAgICAgICAgICAgIHRvdGFsVGV4dFByb2Nlc3NlZDogMCxcbiAgICAgICAgICAgIHRvdGFsQ2h1bmtzR2VuZXJhdGVkOiAwLFxuICAgICAgICAgICAgdG90YWxQcm9jZXNzaW5nVGltZTogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuZGVmYXVsdENodW5rU2l6ZSA9IGNvbmZpZy5kZWZhdWx0Q2h1bmtTaXplIHx8IDEwMDA7XG4gICAgICAgIHRoaXMuZGVmYXVsdE92ZXJsYXAgPSBjb25maWcuZGVmYXVsdE92ZXJsYXAgfHwgMjAwO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdHJhdGVneSA9IGNvbmZpZy5kZWZhdWx0U3RyYXRlZ3kgfHwgJ3JlY3Vyc2l2ZSc7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0xhbmdDaGFpbiBUZXh0IENodW5rZXIgaW5pdGlhbGl6ZWQnLCB7XG4gICAgICAgICAgICBkZWZhdWx0Q2h1bmtTaXplOiB0aGlzLmRlZmF1bHRDaHVua1NpemUsXG4gICAgICAgICAgICBkZWZhdWx0T3ZlcmxhcDogdGhpcy5kZWZhdWx0T3ZlcmxhcCxcbiAgICAgICAgICAgIGRlZmF1bHRTdHJhdGVneTogdGhpcy5kZWZhdWx0U3RyYXRlZ3lcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENodW5rIHRleHQgaW50byBzbWFsbGVyIHBpZWNlc1xuICAgICAqL1xuICAgIGFzeW5jIGNodW5rVGV4dChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IHJlcXVlc3Quc3RyYXRlZ3kgfHwgdGhpcy5kZWZhdWx0U3RyYXRlZ3k7XG4gICAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSByZXF1ZXN0LmNodW5rU2l6ZSB8fCB0aGlzLmRlZmF1bHRDaHVua1NpemU7XG4gICAgICAgICAgICBjb25zdCBjaHVua092ZXJsYXAgPSByZXF1ZXN0LmNodW5rT3ZlcmxhcCB8fCB0aGlzLmRlZmF1bHRPdmVybGFwO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NodW5raW5nIHRleHQnLCB7XG4gICAgICAgICAgICAgICAgdGV4dExlbmd0aDogcmVxdWVzdC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICBjaHVua1NpemUsXG4gICAgICAgICAgICAgICAgY2h1bmtPdmVybGFwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGlucHV0c1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LnRleHQgfHwgcmVxdWVzdC50ZXh0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdObyB0ZXh0IHByb3ZpZGVkIGZvciBjaHVua2luZydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNodW5rU2l6ZSA8PSAwIHx8IGNodW5rT3ZlcmxhcCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIGNodW5rIHNpemUgb3Igb3ZlcmxhcCBwYXJhbWV0ZXJzJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2h1bmtPdmVybGFwID49IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0NodW5rIG92ZXJsYXAgbXVzdCBiZSBsZXNzIHRoYW4gY2h1bmsgc2l6ZSdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIGNodW5rZXIgYmFzZWQgb24gc3RyYXRlZ3lcbiAgICAgICAgICAgIGxldCBjaHVua3M7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVjdXJzaXZlJzpcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzID0gYXdhaXQgdGhpcy5jaHVua1dpdGhSZWN1cnNpdmUocmVxdWVzdC50ZXh0LCBjaHVua1NpemUsIGNodW5rT3ZlcmxhcCwgcmVxdWVzdC5zZXBhcmF0b3JzLCByZXF1ZXN0LmtlZXBTZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjaGFyYWN0ZXInOlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MgPSBhd2FpdCB0aGlzLmNodW5rV2l0aENoYXJhY3RlcihyZXF1ZXN0LnRleHQsIGNodW5rU2l6ZSwgY2h1bmtPdmVybGFwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzID0gYXdhaXQgdGhpcy5jaHVua1dpdGhSZWN1cnNpdmUocmVxdWVzdC50ZXh0LCBjaHVua1NpemUsIGNodW5rT3ZlcmxhcCwgcmVxdWVzdC5zZXBhcmF0b3JzLCByZXF1ZXN0LmtlZXBTZXBhcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2luZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHVzYWdlIHN0YXRzXG4gICAgICAgICAgICB0aGlzLnVzYWdlU3RhdHMudG90YWxSZXF1ZXN0cysrO1xuICAgICAgICAgICAgdGhpcy51c2FnZVN0YXRzLnRvdGFsVGV4dFByb2Nlc3NlZCArPSByZXF1ZXN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy51c2FnZVN0YXRzLnRvdGFsQ2h1bmtzR2VuZXJhdGVkICs9IGNodW5rcy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnVzYWdlU3RhdHMudG90YWxQcm9jZXNzaW5nVGltZSArPSBwcm9jZXNzaW5nVGltZTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIGNodW5rIHNpemVcbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VDaHVua1NpemUgPSBjaHVua3MucmVkdWNlKChzdW0sIGNodW5rKSA9PiBzdW0gKyBjaHVuay5sZW5ndGgsIDApIC8gY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdUZXh0IGNodW5raW5nIGNvbXBsZXRlZCcsIHtcbiAgICAgICAgICAgICAgICB0b3RhbENodW5rczogY2h1bmtzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhdmVyYWdlQ2h1bmtTaXplOiBNYXRoLnJvdW5kKGF2ZXJhZ2VDaHVua1NpemUpLFxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQ2h1bmtzOiBjaHVua3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZUNodW5rU2l6ZTogTWF0aC5yb3VuZChhdmVyYWdlQ2h1bmtTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignVGV4dCBjaHVua2luZyBmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYFRleHQgY2h1bmtpbmcgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaHVuayB0ZXh0IHdpdGggc2ltcGxlIHBhcmFtZXRlcnMgLSBjb252ZW5pZW5jZSBtZXRob2RcbiAgICAgKi9cbiAgICBhc3luYyBjaHVua1RleHRTaW1wbGUodGV4dCwgY2h1bmtTaXplLCBvdmVybGFwKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2h1bmtUZXh0KHtcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBjaHVua1NpemUsXG4gICAgICAgICAgICBjaHVua092ZXJsYXA6IG92ZXJsYXBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLmNodW5rc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaHVuayBtdWx0aXBsZSB0ZXh0cyBpbiBiYXRjaFxuICAgICAqL1xuICAgIGFzeW5jIGNodW5rQmF0Y2godGV4dHMsIGNodW5rU2l6ZSwgb3ZlcmxhcCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0ZXh0IG9mIHRleHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jaHVua1RleHRTaW1wbGUodGV4dCwgY2h1bmtTaXplLCBvdmVybGFwKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQmF0Y2ggY2h1bmtpbmcgZmFpbGVkOiAke3Jlc3VsdC5lcnJvcn1gXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGBCYXRjaCBjaHVua2luZyBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhdmFpbGFibGUgY2h1bmtpbmcgc3RyYXRlZ2llc1xuICAgICAqL1xuICAgIGdldEF2YWlsYWJsZVN0cmF0ZWdpZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3JlY3Vyc2l2ZScsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdSZWN1cnNpdmVseSBzcGxpdHMgdGV4dCBieSB0cnlpbmcgZGlmZmVyZW50IHNlcGFyYXRvcnMgaW4gb3JkZXInLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRDaHVua1NpemU6IDEwMDAsXG4gICAgICAgICAgICAgICAgZGVmYXVsdE92ZXJsYXA6IDIwMCxcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1NlcGFyYXRvcnM6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2NoYXJhY3RlcicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdTaW1wbGUgY2hhcmFjdGVyLWJhc2VkIHNwbGl0dGluZycsXG4gICAgICAgICAgICAgICAgZGVmYXVsdENodW5rU2l6ZTogMTAwMCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0T3ZlcmxhcDogMjAwLFxuICAgICAgICAgICAgICAgIHN1cHBvcnRzU2VwYXJhdG9yczogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGRlZmF1bHQgc3RyYXRlZ3kgbmFtZVxuICAgICAqL1xuICAgIGdldERlZmF1bHRTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFN0cmF0ZWd5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFc3RpbWF0ZSBvcHRpbWFsIGNodW5rIHNpemUgZm9yIGdpdmVuIHRleHQgYW5kIHRhcmdldFxuICAgICAqL1xuICAgIGVzdGltYXRlT3B0aW1hbENodW5rU2l6ZSh0ZXh0LCB0YXJnZXRUb2tlbnMgPSAxMDAwKSB7XG4gICAgICAgIC8vIFJvdWdoIGVzdGltYXRpb246IDEgdG9rZW4g4omIIDMtNCBjaGFyYWN0ZXJzIGZvciBFbmdsaXNoIHRleHRcbiAgICAgICAgY29uc3QgZXN0aW1hdGVkQ2hhcnNQZXJUb2tlbiA9IDMuNTtcbiAgICAgICAgY29uc3QgcmVjb21tZW5kZWRDaGFycyA9IE1hdGgucm91bmQodGFyZ2V0VG9rZW5zICogZXN0aW1hdGVkQ2hhcnNQZXJUb2tlbik7XG4gICAgICAgIC8vIEVuc3VyZSBpdCdzIHdpdGhpbiByZWFzb25hYmxlIGJvdW5kc1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMTAwLCBNYXRoLm1pbihyZWNvbW1lbmRlZENoYXJzLCAxMDAwMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc2VydmljZSBpcyBoZWFsdGh5XG4gICAgICovXG4gICAgYXN5bmMgaXNIZWFsdGh5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IGF3YWl0IHRoaXMuY2h1bmtUZXh0U2ltcGxlKCdIZWFsdGggY2hlY2sgdGVzdCB0ZXh0IGZvciBjaHVua2luZyBzZXJ2aWNlLicpO1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RSZXN1bHQuc3VjY2VzcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdUZXh0IGNodW5rZXIgaGVhbHRoIGNoZWNrIGZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlcnZpY2UgbmFtZSBmb3IgaGVhbHRoIGNoZWNrc1xuICAgICAqL1xuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0xhbmdDaGFpbiBUZXh0IENodW5rZXInO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdXNhZ2Ugc3RhdGlzdGljc1xuICAgICAqL1xuICAgIGdldFVzYWdlU3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3RhbFJlcXVlc3RzOiB0aGlzLnVzYWdlU3RhdHMudG90YWxSZXF1ZXN0cyxcbiAgICAgICAgICAgIHRvdGFsVGV4dFByb2Nlc3NlZDogdGhpcy51c2FnZVN0YXRzLnRvdGFsVGV4dFByb2Nlc3NlZCxcbiAgICAgICAgICAgIHRvdGFsQ2h1bmtzR2VuZXJhdGVkOiB0aGlzLnVzYWdlU3RhdHMudG90YWxDaHVua3NHZW5lcmF0ZWQsXG4gICAgICAgICAgICBhdmVyYWdlUHJvY2Vzc2luZ1RpbWU6IHRoaXMudXNhZ2VTdGF0cy50b3RhbFJlcXVlc3RzID4gMFxuICAgICAgICAgICAgICAgID8gdGhpcy51c2FnZVN0YXRzLnRvdGFsUHJvY2Vzc2luZ1RpbWUgLyB0aGlzLnVzYWdlU3RhdHMudG90YWxSZXF1ZXN0c1xuICAgICAgICAgICAgICAgIDogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaHVuayB0ZXh0IHVzaW5nIFJlY3Vyc2l2ZUNoYXJhY3RlclRleHRTcGxpdHRlclxuICAgICAqL1xuICAgIGFzeW5jIGNodW5rV2l0aFJlY3Vyc2l2ZSh0ZXh0LCBjaHVua1NpemUsIGNodW5rT3ZlcmxhcCwgc2VwYXJhdG9ycywga2VlcFNlcGFyYXRvcikge1xuICAgICAgICBjb25zdCBkZWZhdWx0U2VwYXJhdG9ycyA9IFtcIlxcblxcblwiLCBcIlxcblwiLCBcIiBcIiwgXCJcIl07XG4gICAgICAgIGNvbnN0IHNwbGl0dGVyID0gbmV3IHRleHRzcGxpdHRlcnNfMS5SZWN1cnNpdmVDaGFyYWN0ZXJUZXh0U3BsaXR0ZXIoe1xuICAgICAgICAgICAgY2h1bmtTaXplLFxuICAgICAgICAgICAgY2h1bmtPdmVybGFwLFxuICAgICAgICAgICAgc2VwYXJhdG9yczogc2VwYXJhdG9ycyB8fCBkZWZhdWx0U2VwYXJhdG9ycyxcbiAgICAgICAgICAgIGtlZXBTZXBhcmF0b3I6IGtlZXBTZXBhcmF0b3IgfHwgZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzcGxpdHRlci5zcGxpdFRleHQodGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENodW5rIHRleHQgdXNpbmcgc2ltcGxlIGNoYXJhY3Rlci1iYXNlZCBzcGxpdHRpbmdcbiAgICAgKi9cbiAgICBhc3luYyBjaHVua1dpdGhDaGFyYWN0ZXIodGV4dCwgY2h1bmtTaXplLCBjaHVua092ZXJsYXApIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIHdoaWxlIChzdGFydCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGNodW5rU2l6ZSwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgLy8gTW92ZSBzdGFydCBwb3NpdGlvbiBjb25zaWRlcmluZyBvdmVybGFwXG4gICAgICAgICAgICBzdGFydCA9IGVuZCAtIGNodW5rT3ZlcmxhcDtcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSAwKVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua3MuZmlsdGVyKGNodW5rID0+IGNodW5rLnRyaW0oKS5sZW5ndGggPiAwKTtcbiAgICB9XG59XG5leHBvcnRzLkxhbmdDaGFpblRleHRDaHVua2VyID0gTGFuZ0NoYWluVGV4dENodW5rZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYW5nQ2hhaW5UZXh0Q2h1bmtlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/LangChainTextChunker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/TextChunkerServiceFactory.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/TextChunkerServiceFactory.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Text Chunker Service Factory\n// Creates text chunker instances following the factory pattern\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextChunkerServiceFactory = void 0;\nconst LangChainTextChunker_1 = __webpack_require__(/*! ./LangChainTextChunker */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/LangChainTextChunker.js\");\nclass TextChunkerServiceFactory {\n    /**\n     * Create text chunker instance\n     * @param config - Framework configuration\n     * @param logger - Logger instance\n     * @returns Text chunker instance\n     */\n    create(config, logger) {\n        const chunkerConfig = this.buildTextChunkerConfig(config);\n        logger.info('Creating LangChain Text Chunker', {\n            defaultChunkSize: chunkerConfig.defaultChunkSize,\n            defaultOverlap: chunkerConfig.defaultOverlap,\n            defaultStrategy: chunkerConfig.defaultStrategy\n        });\n        return new LangChainTextChunker_1.LangChainTextChunker(chunkerConfig, logger);\n    }\n    /**\n     * Get service name for registration\n     * @returns Service name\n     */\n    getServiceName() {\n        return 'textChunker';\n    }\n    /**\n     * Build text chunker configuration from framework config\n     * @param config - Framework configuration\n     * @returns Text chunker configuration\n     */\n    buildTextChunkerConfig(config) {\n        // First try to get from environment variables\n        const envConfig = this.getConfigFromEnvironment();\n        if (envConfig) {\n            return envConfig;\n        }\n        // Fallback to framework config if available\n        if (config.services.textChunker) {\n            return {\n                defaultChunkSize: config.services.textChunker.defaultChunkSize,\n                defaultOverlap: config.services.textChunker.defaultOverlap,\n                defaultStrategy: config.services.textChunker.defaultStrategy\n            };\n        }\n        // Default configuration\n        return {\n            defaultChunkSize: parseInt(process.env.TEXT_CHUNK_SIZE || '1000'),\n            defaultOverlap: parseInt(process.env.TEXT_CHUNK_OVERLAP || '200'),\n            defaultStrategy: process.env.TEXT_CHUNK_STRATEGY || 'recursive'\n        };\n    }\n    /**\n     * Get text chunker configuration from environment variables\n     * @returns Text chunker configuration or null if not available\n     */\n    getConfigFromEnvironment() {\n        const chunkSize = process.env.TEXT_CHUNK_SIZE;\n        const overlap = process.env.TEXT_CHUNK_OVERLAP;\n        const strategy = process.env.TEXT_CHUNK_STRATEGY;\n        if (!chunkSize && !overlap && !strategy) {\n            return null;\n        }\n        return {\n            defaultChunkSize: parseInt(chunkSize || '1000'),\n            defaultOverlap: parseInt(overlap || '200'),\n            defaultStrategy: strategy || 'recursive'\n        };\n    }\n}\nexports.TextChunkerServiceFactory = TextChunkerServiceFactory;\n//# sourceMappingURL=TextChunkerServiceFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3RleHRwcm9jZXNzaW5nL1RleHRDaHVua2VyU2VydmljZUZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQztBQUNqQywrQkFBK0IsbUJBQU8sQ0FBQyxrSkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvYWRhcHRlcnMvdGV4dHByb2Nlc3NpbmcvVGV4dENodW5rZXJTZXJ2aWNlRmFjdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFRleHQgQ2h1bmtlciBTZXJ2aWNlIEZhY3Rvcnlcbi8vIENyZWF0ZXMgdGV4dCBjaHVua2VyIGluc3RhbmNlcyBmb2xsb3dpbmcgdGhlIGZhY3RvcnkgcGF0dGVyblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZXh0Q2h1bmtlclNlcnZpY2VGYWN0b3J5ID0gdm9pZCAwO1xuY29uc3QgTGFuZ0NoYWluVGV4dENodW5rZXJfMSA9IHJlcXVpcmUoXCIuL0xhbmdDaGFpblRleHRDaHVua2VyXCIpO1xuY2xhc3MgVGV4dENodW5rZXJTZXJ2aWNlRmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRleHQgY2h1bmtlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjb25maWcgLSBGcmFtZXdvcmsgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBsb2dnZXIgLSBMb2dnZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyBUZXh0IGNodW5rZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjcmVhdGUoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgY2h1bmtlckNvbmZpZyA9IHRoaXMuYnVpbGRUZXh0Q2h1bmtlckNvbmZpZyhjb25maWcpO1xuICAgICAgICBsb2dnZXIuaW5mbygnQ3JlYXRpbmcgTGFuZ0NoYWluIFRleHQgQ2h1bmtlcicsIHtcbiAgICAgICAgICAgIGRlZmF1bHRDaHVua1NpemU6IGNodW5rZXJDb25maWcuZGVmYXVsdENodW5rU2l6ZSxcbiAgICAgICAgICAgIGRlZmF1bHRPdmVybGFwOiBjaHVua2VyQ29uZmlnLmRlZmF1bHRPdmVybGFwLFxuICAgICAgICAgICAgZGVmYXVsdFN0cmF0ZWd5OiBjaHVua2VyQ29uZmlnLmRlZmF1bHRTdHJhdGVneVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMYW5nQ2hhaW5UZXh0Q2h1bmtlcl8xLkxhbmdDaGFpblRleHRDaHVua2VyKGNodW5rZXJDb25maWcsIGxvZ2dlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZXJ2aWNlIG5hbWUgZm9yIHJlZ2lzdHJhdGlvblxuICAgICAqIEByZXR1cm5zIFNlcnZpY2UgbmFtZVxuICAgICAqL1xuICAgIGdldFNlcnZpY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RleHRDaHVua2VyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgdGV4dCBjaHVua2VyIGNvbmZpZ3VyYXRpb24gZnJvbSBmcmFtZXdvcmsgY29uZmlnXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEZyYW1ld29yayBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgVGV4dCBjaHVua2VyIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBidWlsZFRleHRDaHVua2VyQ29uZmlnKGNvbmZpZykge1xuICAgICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICAgIGNvbnN0IGVudkNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnRnJvbUVudmlyb25tZW50KCk7XG4gICAgICAgIGlmIChlbnZDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnZDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZnJhbWV3b3JrIGNvbmZpZyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNvbmZpZy5zZXJ2aWNlcy50ZXh0Q2h1bmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q2h1bmtTaXplOiBjb25maWcuc2VydmljZXMudGV4dENodW5rZXIuZGVmYXVsdENodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0T3ZlcmxhcDogY29uZmlnLnNlcnZpY2VzLnRleHRDaHVua2VyLmRlZmF1bHRPdmVybGFwLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRTdHJhdGVneTogY29uZmlnLnNlcnZpY2VzLnRleHRDaHVua2VyLmRlZmF1bHRTdHJhdGVneVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlZmF1bHRDaHVua1NpemU6IHBhcnNlSW50KHByb2Nlc3MuZW52LlRFWFRfQ0hVTktfU0laRSB8fCAnMTAwMCcpLFxuICAgICAgICAgICAgZGVmYXVsdE92ZXJsYXA6IHBhcnNlSW50KHByb2Nlc3MuZW52LlRFWFRfQ0hVTktfT1ZFUkxBUCB8fCAnMjAwJyksXG4gICAgICAgICAgICBkZWZhdWx0U3RyYXRlZ3k6IHByb2Nlc3MuZW52LlRFWFRfQ0hVTktfU1RSQVRFR1kgfHwgJ3JlY3Vyc2l2ZSdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRleHQgY2h1bmtlciBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogQHJldHVybnMgVGV4dCBjaHVua2VyIGNvbmZpZ3VyYXRpb24gb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZ2V0Q29uZmlnRnJvbUVudmlyb25tZW50KCkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBwcm9jZXNzLmVudi5URVhUX0NIVU5LX1NJWkU7XG4gICAgICAgIGNvbnN0IG92ZXJsYXAgPSBwcm9jZXNzLmVudi5URVhUX0NIVU5LX09WRVJMQVA7XG4gICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gcHJvY2Vzcy5lbnYuVEVYVF9DSFVOS19TVFJBVEVHWTtcbiAgICAgICAgaWYgKCFjaHVua1NpemUgJiYgIW92ZXJsYXAgJiYgIXN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmYXVsdENodW5rU2l6ZTogcGFyc2VJbnQoY2h1bmtTaXplIHx8ICcxMDAwJyksXG4gICAgICAgICAgICBkZWZhdWx0T3ZlcmxhcDogcGFyc2VJbnQob3ZlcmxhcCB8fCAnMjAwJyksXG4gICAgICAgICAgICBkZWZhdWx0U3RyYXRlZ3k6IHN0cmF0ZWd5IHx8ICdyZWN1cnNpdmUnXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0Q2h1bmtlclNlcnZpY2VGYWN0b3J5ID0gVGV4dENodW5rZXJTZXJ2aWNlRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRDaHVua2VyU2VydmljZUZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/TextChunkerServiceFactory.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Text Processing Adapters Index\n// Exports all text processing adapter components\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextChunkerServiceFactory = exports.LangChainTextChunker = void 0;\nvar LangChainTextChunker_1 = __webpack_require__(/*! ./LangChainTextChunker */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/LangChainTextChunker.js\");\nObject.defineProperty(exports, \"LangChainTextChunker\", ({ enumerable: true, get: function () { return LangChainTextChunker_1.LangChainTextChunker; } }));\nvar TextChunkerServiceFactory_1 = __webpack_require__(/*! ./TextChunkerServiceFactory */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/TextChunkerServiceFactory.js\");\nObject.defineProperty(exports, \"TextChunkerServiceFactory\", ({ enumerable: true, get: function () { return TextChunkerServiceFactory_1.TextChunkerServiceFactory; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2FkYXB0ZXJzL3RleHRwcm9jZXNzaW5nL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyw0QkFBNEI7QUFDaEUsNkJBQTZCLG1CQUFPLENBQUMsa0pBQXdCO0FBQzdELHdEQUF1RCxFQUFFLHFDQUFxQyx1REFBdUQsRUFBQztBQUN0SixrQ0FBa0MsbUJBQU8sQ0FBQyw0SkFBNkI7QUFDdkUsNkRBQTRELEVBQUUscUNBQXFDLGlFQUFpRSxFQUFDO0FBQ3JLIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9hZGFwdGVycy90ZXh0cHJvY2Vzc2luZy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFRleHQgUHJvY2Vzc2luZyBBZGFwdGVycyBJbmRleFxuLy8gRXhwb3J0cyBhbGwgdGV4dCBwcm9jZXNzaW5nIGFkYXB0ZXIgY29tcG9uZW50c1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZXh0Q2h1bmtlclNlcnZpY2VGYWN0b3J5ID0gZXhwb3J0cy5MYW5nQ2hhaW5UZXh0Q2h1bmtlciA9IHZvaWQgMDtcbnZhciBMYW5nQ2hhaW5UZXh0Q2h1bmtlcl8xID0gcmVxdWlyZShcIi4vTGFuZ0NoYWluVGV4dENodW5rZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMYW5nQ2hhaW5UZXh0Q2h1bmtlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTGFuZ0NoYWluVGV4dENodW5rZXJfMS5MYW5nQ2hhaW5UZXh0Q2h1bmtlcjsgfSB9KTtcbnZhciBUZXh0Q2h1bmtlclNlcnZpY2VGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9UZXh0Q2h1bmtlclNlcnZpY2VGYWN0b3J5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGV4dENodW5rZXJTZXJ2aWNlRmFjdG9yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVGV4dENodW5rZXJTZXJ2aWNlRmFjdG9yeV8xLlRleHRDaHVua2VyU2VydmljZUZhY3Rvcnk7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ConfigLoader.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ConfigLoader.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Configuration Loader for the Hexagonal Framework\n// Loads configuration from environment variables, files, and other sources\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConfigLoaderFactory = exports.ConfigLoader = exports.DefaultConfigValidator = exports.ObjectConfigSource = exports.FileConfigSource = exports.EnvironmentConfigSource = void 0;\nconst FrameworkConfig_1 = __webpack_require__(/*! ./FrameworkConfig */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/FrameworkConfig.js\");\nclass EnvironmentConfigSource {\n    constructor() {\n        this.name = 'environment';\n    }\n    async load() {\n        const config = {};\n        // General framework settings\n        if (process.env.FRAMEWORK_ENVIRONMENT) {\n            config.environment = process.env.FRAMEWORK_ENVIRONMENT;\n        }\n        if (process.env.FRAMEWORK_DEBUG) {\n            config.debug = process.env.FRAMEWORK_DEBUG.toLowerCase() === 'true';\n        }\n        if (process.env.FRAMEWORK_LOG_LEVEL) {\n            config.logLevel = process.env.FRAMEWORK_LOG_LEVEL;\n        }\n        // Service configurations\n        config.services = {};\n        // OpenAI configuration\n        if (process.env.OPENAI_API_KEY) {\n            const openaiConfig = {\n                apiKey: process.env.OPENAI_API_KEY,\n                baseUrl: process.env.OPENAI_BASE_URL,\n                timeout: process.env.OPENAI_TIMEOUT ? parseInt(process.env.OPENAI_TIMEOUT) : undefined,\n                model: process.env.OPENAI_MODEL,\n                organization: process.env.OPENAI_ORGANIZATION\n            };\n            config.services.openai = openaiConfig;\n        }\n        // Tavily configuration\n        if (process.env.TAVILY_API_KEY) {\n            const tavilyConfig = {\n                apiKey: process.env.TAVILY_API_KEY,\n                baseUrl: process.env.TAVILY_BASE_URL,\n                timeout: process.env.TAVILY_TIMEOUT ? parseInt(process.env.TAVILY_TIMEOUT) : undefined,\n                searchDepth: process.env.TAVILY_SEARCH_DEPTH\n            };\n            config.services.tavily = tavilyConfig;\n        }\n        // Firebase configuration\n        if (process.env.FIREBASE_PROJECT_ID && process.env.FIREBASE_API_KEY) {\n            const firebaseConfig = {\n                projectId: process.env.FIREBASE_PROJECT_ID,\n                apiKey: process.env.FIREBASE_API_KEY,\n                authDomain: process.env.FIREBASE_AUTH_DOMAIN || `${process.env.FIREBASE_PROJECT_ID}.firebaseapp.com`,\n                storageBucket: process.env.FIREBASE_STORAGE_BUCKET\n            };\n            config.services.firebase = firebaseConfig;\n        }\n        // Stripe configuration\n        if (process.env.STRIPE_SECRET_KEY) {\n            const stripeConfig = {\n                apiKey: process.env.STRIPE_SECRET_KEY,\n                publishableKey: process.env.STRIPE_PUBLISHABLE_KEY,\n                webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,\n                baseUrl: process.env.STRIPE_BASE_URL,\n                timeout: process.env.STRIPE_TIMEOUT ? parseInt(process.env.STRIPE_TIMEOUT) : undefined\n            };\n            config.services.stripe = stripeConfig;\n        }\n        // Screenshot configuration\n        if (process.env.SCREENSHOT_ENABLED) {\n            const screenshotConfig = {\n                headless: process.env.SCREENSHOT_HEADLESS?.toLowerCase() !== 'false',\n                timeout: process.env.SCREENSHOT_TIMEOUT ? parseInt(process.env.SCREENSHOT_TIMEOUT) : undefined,\n                userAgent: process.env.SCREENSHOT_USER_AGENT,\n                viewport: process.env.SCREENSHOT_VIEWPORT_WIDTH && process.env.SCREENSHOT_VIEWPORT_HEIGHT\n                    ? {\n                        width: parseInt(process.env.SCREENSHOT_VIEWPORT_WIDTH),\n                        height: parseInt(process.env.SCREENSHOT_VIEWPORT_HEIGHT)\n                    }\n                    : undefined\n            };\n            config.services.screenshot = screenshotConfig;\n        }\n        // Retry configuration\n        if (process.env.RETRY_MAX_ATTEMPTS || process.env.RETRY_BACKOFF_MULTIPLIER) {\n            const retryConfig = {};\n            if (process.env.RETRY_MAX_ATTEMPTS) {\n                retryConfig.maxAttempts = parseInt(process.env.RETRY_MAX_ATTEMPTS);\n            }\n            if (process.env.RETRY_BACKOFF_MULTIPLIER) {\n                retryConfig.backoffMultiplier = parseFloat(process.env.RETRY_BACKOFF_MULTIPLIER);\n            }\n            if (process.env.RETRY_MAX_BACKOFF_MS) {\n                retryConfig.maxBackoffMs = parseInt(process.env.RETRY_MAX_BACKOFF_MS);\n            }\n            config.retry = retryConfig;\n        }\n        return config;\n    }\n}\nexports.EnvironmentConfigSource = EnvironmentConfigSource;\nclass FileConfigSource {\n    constructor(filePath) {\n        this.name = 'file';\n        this.filePath = filePath;\n    }\n    async load() {\n        try {\n            const fs = (__webpack_require__(/*! fs */ \"fs\").promises);\n            const content = await fs.readFile(this.filePath, 'utf8');\n            if (this.filePath.endsWith('.json')) {\n                return JSON.parse(content);\n            }\n            else if (this.filePath.endsWith('.js') || this.filePath.endsWith('.ts')) {\n                // For JS/TS files, we would need to require/import them\n                // This is a simplified implementation\n                const module = __webpack_require__(\"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config sync recursive\")(this.filePath);\n                return module.default || module;\n            }\n            throw new Error(`Unsupported config file format: ${this.filePath}`);\n        }\n        catch (error) {\n            throw new Error(`Failed to load config file ${this.filePath}: ${error.message}`);\n        }\n    }\n}\nexports.FileConfigSource = FileConfigSource;\nclass ObjectConfigSource {\n    constructor(config) {\n        this.name = 'object';\n        this.config = config;\n    }\n    async load() {\n        return this.config;\n    }\n}\nexports.ObjectConfigSource = ObjectConfigSource;\nclass DefaultConfigValidator {\n    validate(config) {\n        const errors = [];\n        const warnings = [];\n        // Validate environment\n        if (!['development', 'staging', 'production'].includes(config.environment)) {\n            errors.push(`Invalid environment: ${config.environment}`);\n        }\n        // Validate log level\n        if (!['error', 'warn', 'info', 'debug'].includes(config.logLevel)) {\n            errors.push(`Invalid log level: ${config.logLevel}`);\n        }\n        // Validate retry configuration\n        if (config.retry.maxAttempts < 1) {\n            errors.push('Retry maxAttempts must be at least 1');\n        }\n        if (config.retry.backoffMultiplier < 1) {\n            errors.push('Retry backoffMultiplier must be at least 1');\n        }\n        // Validate service configurations\n        if (config.services.openai) {\n            if (!config.services.openai.apiKey) {\n                errors.push('OpenAI API key is required');\n            }\n        }\n        if (config.services.tavily) {\n            if (!config.services.tavily.apiKey) {\n                errors.push('Tavily API key is required');\n            }\n        }\n        if (config.services.firebase) {\n            if (!config.services.firebase.projectId) {\n                errors.push('Firebase project ID is required');\n            }\n            if (!config.services.firebase.apiKey) {\n                errors.push('Firebase API key is required');\n            }\n        }\n        if (config.services.stripe) {\n            if (!config.services.stripe.apiKey) {\n                errors.push('Stripe API key is required');\n            }\n        }\n        // Add warnings for common misconfigurations\n        if (config.environment === 'production' && config.debug) {\n            warnings.push('Debug mode is enabled in production environment');\n        }\n        if (config.environment === 'production' && config.logLevel === 'debug') {\n            warnings.push('Debug log level is set in production environment');\n        }\n        return {\n            isValid: errors.length === 0,\n            errors,\n            warnings\n        };\n    }\n}\nexports.DefaultConfigValidator = DefaultConfigValidator;\nclass ConfigLoader {\n    constructor(validator) {\n        this.sources = [];\n        this.validator = validator || new DefaultConfigValidator();\n    }\n    /**\n     * Add a configuration source\n     * @param source - Configuration source to add\n     */\n    addSource(source) {\n        this.sources.push(source);\n    }\n    /**\n     * Add multiple configuration sources\n     * @param sources - Array of configuration sources\n     */\n    addSources(sources) {\n        this.sources.push(...sources);\n    }\n    /**\n     * Load configuration from all sources and merge them\n     * @returns Merged and validated configuration\n     */\n    async load() {\n        let mergedConfig = { ...FrameworkConfig_1.defaultFrameworkConfig };\n        // Load from each source in order (later sources override earlier ones)\n        for (const source of this.sources) {\n            try {\n                const sourceConfig = await source.load();\n                mergedConfig = this.mergeConfigs(mergedConfig, sourceConfig);\n            }\n            catch (error) {\n                throw new Error(`Failed to load config from ${source.name}: ${error.message}`);\n            }\n        }\n        // Validate the final configuration\n        const validation = this.validator.validate(mergedConfig);\n        if (!validation.isValid) {\n            throw new Error(`Configuration validation failed:\\n${validation.errors.join('\\n')}`);\n        }\n        // Log warnings if any\n        if (validation.warnings.length > 0) {\n            console.warn('Configuration warnings:\\n' + validation.warnings.join('\\n'));\n        }\n        return mergedConfig;\n    }\n    /**\n     * Deep merge two configuration objects\n     * @param target - Target configuration\n     * @param source - Source configuration\n     * @returns Merged configuration\n     */\n    mergeConfigs(target, source) {\n        const result = { ...target };\n        for (const [key, value] of Object.entries(source)) {\n            if (value !== undefined) {\n                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n                    // @ts-ignore - Complex deep merge handling\n                    result[key] = { ...result[key], ...value };\n                }\n                else {\n                    // @ts-ignore - Direct assignment for primitives and arrays\n                    result[key] = value;\n                }\n            }\n        }\n        return result;\n    }\n}\nexports.ConfigLoader = ConfigLoader;\n// Factory for creating config loader with common sources\nclass ConfigLoaderFactory {\n    /**\n     * Create a config loader with environment variables only\n     * @returns ConfigLoader instance\n     */\n    static createEnvironmentLoader() {\n        const loader = new ConfigLoader();\n        loader.addSource(new EnvironmentConfigSource());\n        return loader;\n    }\n    /**\n     * Create a config loader with file and environment sources\n     * @param configFilePath - Path to configuration file\n     * @returns ConfigLoader instance\n     */\n    static createFileAndEnvironmentLoader(configFilePath) {\n        const loader = new ConfigLoader();\n        loader.addSource(new FileConfigSource(configFilePath));\n        loader.addSource(new EnvironmentConfigSource()); // Environment overrides file\n        return loader;\n    }\n    /**\n     * Create a config loader with object, file, and environment sources\n     * @param baseConfig - Base configuration object\n     * @param configFilePath - Optional path to configuration file\n     * @returns ConfigLoader instance\n     */\n    static createFullLoader(baseConfig, configFilePath) {\n        const loader = new ConfigLoader();\n        loader.addSource(new ObjectConfigSource(baseConfig));\n        if (configFilePath) {\n            loader.addSource(new FileConfigSource(configFilePath));\n        }\n        loader.addSource(new EnvironmentConfigSource()); // Environment has highest priority\n        return loader;\n    }\n}\nexports.ConfigLoaderFactory = ConfigLoaderFactory;\n//# sourceMappingURL=ConfigLoader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvbmZpZy9Db25maWdMb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLG9CQUFvQixHQUFHLDhCQUE4QixHQUFHLDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLCtCQUErQjtBQUM3SywwQkFBMEIsbUJBQU8sQ0FBQyx1SEFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxnQ0FBZ0M7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0hBQVEsYUFBYSxDQUFDO0FBQ3JEO0FBQ0E7QUFDQSwrREFBK0QsY0FBYztBQUM3RTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsSUFBSSxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG1CQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZLElBQUksY0FBYztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDZCQUE2QjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb25maWcvQ29uZmlnTG9hZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29uZmlndXJhdGlvbiBMb2FkZXIgZm9yIHRoZSBIZXhhZ29uYWwgRnJhbWV3b3JrXG4vLyBMb2FkcyBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzLCBmaWxlcywgYW5kIG90aGVyIHNvdXJjZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uZmlnTG9hZGVyRmFjdG9yeSA9IGV4cG9ydHMuQ29uZmlnTG9hZGVyID0gZXhwb3J0cy5EZWZhdWx0Q29uZmlnVmFsaWRhdG9yID0gZXhwb3J0cy5PYmplY3RDb25maWdTb3VyY2UgPSBleHBvcnRzLkZpbGVDb25maWdTb3VyY2UgPSBleHBvcnRzLkVudmlyb25tZW50Q29uZmlnU291cmNlID0gdm9pZCAwO1xuY29uc3QgRnJhbWV3b3JrQ29uZmlnXzEgPSByZXF1aXJlKFwiLi9GcmFtZXdvcmtDb25maWdcIik7XG5jbGFzcyBFbnZpcm9ubWVudENvbmZpZ1NvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdlbnZpcm9ubWVudCc7XG4gICAgfVxuICAgIGFzeW5jIGxvYWQoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHt9O1xuICAgICAgICAvLyBHZW5lcmFsIGZyYW1ld29yayBzZXR0aW5nc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuRlJBTUVXT1JLX0VOVklST05NRU5UKSB7XG4gICAgICAgICAgICBjb25maWcuZW52aXJvbm1lbnQgPSBwcm9jZXNzLmVudi5GUkFNRVdPUktfRU5WSVJPTk1FTlQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkZSQU1FV09SS19ERUJVRykge1xuICAgICAgICAgICAgY29uZmlnLmRlYnVnID0gcHJvY2Vzcy5lbnYuRlJBTUVXT1JLX0RFQlVHLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuRlJBTUVXT1JLX0xPR19MRVZFTCkge1xuICAgICAgICAgICAgY29uZmlnLmxvZ0xldmVsID0gcHJvY2Vzcy5lbnYuRlJBTUVXT1JLX0xPR19MRVZFTDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXJ2aWNlIGNvbmZpZ3VyYXRpb25zXG4gICAgICAgIGNvbmZpZy5zZXJ2aWNlcyA9IHt9O1xuICAgICAgICAvLyBPcGVuQUkgY29uZmlndXJhdGlvblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5haUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBhcGlLZXk6IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZLFxuICAgICAgICAgICAgICAgIGJhc2VVcmw6IHByb2Nlc3MuZW52Lk9QRU5BSV9CQVNFX1VSTCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBwcm9jZXNzLmVudi5PUEVOQUlfVElNRU9VVCA/IHBhcnNlSW50KHByb2Nlc3MuZW52Lk9QRU5BSV9USU1FT1VUKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtb2RlbDogcHJvY2Vzcy5lbnYuT1BFTkFJX01PREVMLFxuICAgICAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogcHJvY2Vzcy5lbnYuT1BFTkFJX09SR0FOSVpBVElPTlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbmZpZy5zZXJ2aWNlcy5vcGVuYWkgPSBvcGVuYWlDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGF2aWx5IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlRBVklMWV9BUElfS0VZKSB7XG4gICAgICAgICAgICBjb25zdCB0YXZpbHlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5UQVZJTFlfQVBJX0tFWSxcbiAgICAgICAgICAgICAgICBiYXNlVXJsOiBwcm9jZXNzLmVudi5UQVZJTFlfQkFTRV9VUkwsXG4gICAgICAgICAgICAgICAgdGltZW91dDogcHJvY2Vzcy5lbnYuVEFWSUxZX1RJTUVPVVQgPyBwYXJzZUludChwcm9jZXNzLmVudi5UQVZJTFlfVElNRU9VVCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc2VhcmNoRGVwdGg6IHByb2Nlc3MuZW52LlRBVklMWV9TRUFSQ0hfREVQVEhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25maWcuc2VydmljZXMudGF2aWx5ID0gdGF2aWx5Q29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmViYXNlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkZJUkVCQVNFX1BST0pFQ1RfSUQgJiYgcHJvY2Vzcy5lbnYuRklSRUJBU0VfQVBJX0tFWSkge1xuICAgICAgICAgICAgY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdElkOiBwcm9jZXNzLmVudi5GSVJFQkFTRV9QUk9KRUNUX0lELFxuICAgICAgICAgICAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuRklSRUJBU0VfQVBJX0tFWSxcbiAgICAgICAgICAgICAgICBhdXRoRG9tYWluOiBwcm9jZXNzLmVudi5GSVJFQkFTRV9BVVRIX0RPTUFJTiB8fCBgJHtwcm9jZXNzLmVudi5GSVJFQkFTRV9QUk9KRUNUX0lEfS5maXJlYmFzZWFwcC5jb21gLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VCdWNrZXQ6IHByb2Nlc3MuZW52LkZJUkVCQVNFX1NUT1JBR0VfQlVDS0VUXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uZmlnLnNlcnZpY2VzLmZpcmViYXNlID0gZmlyZWJhc2VDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RyaXBlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNUUklQRV9TRUNSRVRfS0VZKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpcGVDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYXBpS2V5OiBwcm9jZXNzLmVudi5TVFJJUEVfU0VDUkVUX0tFWSxcbiAgICAgICAgICAgICAgICBwdWJsaXNoYWJsZUtleTogcHJvY2Vzcy5lbnYuU1RSSVBFX1BVQkxJU0hBQkxFX0tFWSxcbiAgICAgICAgICAgICAgICB3ZWJob29rU2VjcmV0OiBwcm9jZXNzLmVudi5TVFJJUEVfV0VCSE9PS19TRUNSRVQsXG4gICAgICAgICAgICAgICAgYmFzZVVybDogcHJvY2Vzcy5lbnYuU1RSSVBFX0JBU0VfVVJMLFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHByb2Nlc3MuZW52LlNUUklQRV9USU1FT1VUID8gcGFyc2VJbnQocHJvY2Vzcy5lbnYuU1RSSVBFX1RJTUVPVVQpIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uZmlnLnNlcnZpY2VzLnN0cmlwZSA9IHN0cmlwZUNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICAvLyBTY3JlZW5zaG90IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNDUkVFTlNIT1RfRU5BQkxFRCkge1xuICAgICAgICAgICAgY29uc3Qgc2NyZWVuc2hvdENvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBoZWFkbGVzczogcHJvY2Vzcy5lbnYuU0NSRUVOU0hPVF9IRUFETEVTUz8udG9Mb3dlckNhc2UoKSAhPT0gJ2ZhbHNlJyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBwcm9jZXNzLmVudi5TQ1JFRU5TSE9UX1RJTUVPVVQgPyBwYXJzZUludChwcm9jZXNzLmVudi5TQ1JFRU5TSE9UX1RJTUVPVVQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudDogcHJvY2Vzcy5lbnYuU0NSRUVOU0hPVF9VU0VSX0FHRU5ULFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0OiBwcm9jZXNzLmVudi5TQ1JFRU5TSE9UX1ZJRVdQT1JUX1dJRFRIICYmIHByb2Nlc3MuZW52LlNDUkVFTlNIT1RfVklFV1BPUlRfSEVJR0hUXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlSW50KHByb2Nlc3MuZW52LlNDUkVFTlNIT1RfVklFV1BPUlRfV0lEVEgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChwcm9jZXNzLmVudi5TQ1JFRU5TSE9UX1ZJRVdQT1JUX0hFSUdIVClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbmZpZy5zZXJ2aWNlcy5zY3JlZW5zaG90ID0gc2NyZWVuc2hvdENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXRyeSBjb25maWd1cmF0aW9uXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5SRVRSWV9NQVhfQVRURU1QVFMgfHwgcHJvY2Vzcy5lbnYuUkVUUllfQkFDS09GRl9NVUxUSVBMSUVSKSB7XG4gICAgICAgICAgICBjb25zdCByZXRyeUNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LlJFVFJZX01BWF9BVFRFTVBUUykge1xuICAgICAgICAgICAgICAgIHJldHJ5Q29uZmlnLm1heEF0dGVtcHRzID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuUkVUUllfTUFYX0FUVEVNUFRTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5SRVRSWV9CQUNLT0ZGX01VTFRJUExJRVIpIHtcbiAgICAgICAgICAgICAgICByZXRyeUNvbmZpZy5iYWNrb2ZmTXVsdGlwbGllciA9IHBhcnNlRmxvYXQocHJvY2Vzcy5lbnYuUkVUUllfQkFDS09GRl9NVUxUSVBMSUVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5SRVRSWV9NQVhfQkFDS09GRl9NUykge1xuICAgICAgICAgICAgICAgIHJldHJ5Q29uZmlnLm1heEJhY2tvZmZNcyA9IHBhcnNlSW50KHByb2Nlc3MuZW52LlJFVFJZX01BWF9CQUNLT0ZGX01TKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5yZXRyeSA9IHJldHJ5Q29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufVxuZXhwb3J0cy5FbnZpcm9ubWVudENvbmZpZ1NvdXJjZSA9IEVudmlyb25tZW50Q29uZmlnU291cmNlO1xuY2xhc3MgRmlsZUNvbmZpZ1NvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoZmlsZVBhdGgpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ2ZpbGUnO1xuICAgICAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG4gICAgfVxuICAgIGFzeW5jIGxvYWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJykucHJvbWlzZXM7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUodGhpcy5maWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbGVQYXRoLmVuZHNXaXRoKCcuanNvbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZpbGVQYXRoLmVuZHNXaXRoKCcuanMnKSB8fCB0aGlzLmZpbGVQYXRoLmVuZHNXaXRoKCcudHMnKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBKUy9UUyBmaWxlcywgd2Ugd291bGQgbmVlZCB0byByZXF1aXJlL2ltcG9ydCB0aGVtXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGUgPSByZXF1aXJlKHRoaXMuZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZGVmYXVsdCB8fCBtb2R1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbmZpZyBmaWxlIGZvcm1hdDogJHt0aGlzLmZpbGVQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBjb25maWcgZmlsZSAke3RoaXMuZmlsZVBhdGh9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZpbGVDb25maWdTb3VyY2UgPSBGaWxlQ29uZmlnU291cmNlO1xuY2xhc3MgT2JqZWN0Q29uZmlnU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ29iamVjdCc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICBhc3luYyBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWc7XG4gICAgfVxufVxuZXhwb3J0cy5PYmplY3RDb25maWdTb3VyY2UgPSBPYmplY3RDb25maWdTb3VyY2U7XG5jbGFzcyBEZWZhdWx0Q29uZmlnVmFsaWRhdG9yIHtcbiAgICB2YWxpZGF0ZShjb25maWcpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgICAgIC8vIFZhbGlkYXRlIGVudmlyb25tZW50XG4gICAgICAgIGlmICghWydkZXZlbG9wbWVudCcsICdzdGFnaW5nJywgJ3Byb2R1Y3Rpb24nXS5pbmNsdWRlcyhjb25maWcuZW52aXJvbm1lbnQpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChgSW52YWxpZCBlbnZpcm9ubWVudDogJHtjb25maWcuZW52aXJvbm1lbnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgbG9nIGxldmVsXG4gICAgICAgIGlmICghWydlcnJvcicsICd3YXJuJywgJ2luZm8nLCAnZGVidWcnXS5pbmNsdWRlcyhjb25maWcubG9nTGV2ZWwpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChgSW52YWxpZCBsb2cgbGV2ZWw6ICR7Y29uZmlnLmxvZ0xldmVsfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHJldHJ5IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgaWYgKGNvbmZpZy5yZXRyeS5tYXhBdHRlbXB0cyA8IDEpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKCdSZXRyeSBtYXhBdHRlbXB0cyBtdXN0IGJlIGF0IGxlYXN0IDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnJldHJ5LmJhY2tvZmZNdWx0aXBsaWVyIDwgMSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goJ1JldHJ5IGJhY2tvZmZNdWx0aXBsaWVyIG11c3QgYmUgYXQgbGVhc3QgMScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHNlcnZpY2UgY29uZmlndXJhdGlvbnNcbiAgICAgICAgaWYgKGNvbmZpZy5zZXJ2aWNlcy5vcGVuYWkpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLnNlcnZpY2VzLm9wZW5haS5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCgnT3BlbkFJIEFQSSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnNlcnZpY2VzLnRhdmlseSkge1xuICAgICAgICAgICAgaWYgKCFjb25maWcuc2VydmljZXMudGF2aWx5LmFwaUtleSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKCdUYXZpbHkgQVBJIGtleSBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuc2VydmljZXMuZmlyZWJhc2UpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLnNlcnZpY2VzLmZpcmViYXNlLnByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKCdGaXJlYmFzZSBwcm9qZWN0IElEIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5zZXJ2aWNlcy5maXJlYmFzZS5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCgnRmlyZWJhc2UgQVBJIGtleSBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuc2VydmljZXMuc3RyaXBlKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5zZXJ2aWNlcy5zdHJpcGUuYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goJ1N0cmlwZSBBUEkga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHdhcm5pbmdzIGZvciBjb21tb24gbWlzY29uZmlndXJhdGlvbnNcbiAgICAgICAgaWYgKGNvbmZpZy5lbnZpcm9ubWVudCA9PT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaCgnRGVidWcgbW9kZSBpcyBlbmFibGVkIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmVudmlyb25tZW50ID09PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLmxvZ0xldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICB3YXJuaW5ncy5wdXNoKCdEZWJ1ZyBsb2cgbGV2ZWwgaXMgc2V0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICAgIHdhcm5pbmdzXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0Q29uZmlnVmFsaWRhdG9yID0gRGVmYXVsdENvbmZpZ1ZhbGlkYXRvcjtcbmNsYXNzIENvbmZpZ0xvYWRlciB7XG4gICAgY29uc3RydWN0b3IodmFsaWRhdG9yKSB7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvciB8fCBuZXcgRGVmYXVsdENvbmZpZ1ZhbGlkYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb25maWd1cmF0aW9uIHNvdXJjZVxuICAgICAqIEBwYXJhbSBzb3VyY2UgLSBDb25maWd1cmF0aW9uIHNvdXJjZSB0byBhZGRcbiAgICAgKi9cbiAgICBhZGRTb3VyY2Uoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBtdWx0aXBsZSBjb25maWd1cmF0aW9uIHNvdXJjZXNcbiAgICAgKiBAcGFyYW0gc291cmNlcyAtIEFycmF5IG9mIGNvbmZpZ3VyYXRpb24gc291cmNlc1xuICAgICAqL1xuICAgIGFkZFNvdXJjZXMoc291cmNlcykge1xuICAgICAgICB0aGlzLnNvdXJjZXMucHVzaCguLi5zb3VyY2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBjb25maWd1cmF0aW9uIGZyb20gYWxsIHNvdXJjZXMgYW5kIG1lcmdlIHRoZW1cbiAgICAgKiBAcmV0dXJucyBNZXJnZWQgYW5kIHZhbGlkYXRlZCBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgbG9hZCgpIHtcbiAgICAgICAgbGV0IG1lcmdlZENvbmZpZyA9IHsgLi4uRnJhbWV3b3JrQ29uZmlnXzEuZGVmYXVsdEZyYW1ld29ya0NvbmZpZyB9O1xuICAgICAgICAvLyBMb2FkIGZyb20gZWFjaCBzb3VyY2UgaW4gb3JkZXIgKGxhdGVyIHNvdXJjZXMgb3ZlcnJpZGUgZWFybGllciBvbmVzKVxuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlQ29uZmlnID0gYXdhaXQgc291cmNlLmxvYWQoKTtcbiAgICAgICAgICAgICAgICBtZXJnZWRDb25maWcgPSB0aGlzLm1lcmdlQ29uZmlncyhtZXJnZWRDb25maWcsIHNvdXJjZUNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGNvbmZpZyBmcm9tICR7c291cmNlLm5hbWV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGZpbmFsIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlKG1lcmdlZENvbmZpZyk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbmZpZ3VyYXRpb24gdmFsaWRhdGlvbiBmYWlsZWQ6XFxuJHt2YWxpZGF0aW9uLmVycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2cgd2FybmluZ3MgaWYgYW55XG4gICAgICAgIGlmICh2YWxpZGF0aW9uLndhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29uZmlndXJhdGlvbiB3YXJuaW5nczpcXG4nICsgdmFsaWRhdGlvbi53YXJuaW5ncy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZENvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVlcCBtZXJnZSB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRhcmdldCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHNvdXJjZSAtIFNvdXJjZSBjb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMgTWVyZ2VkIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBtZXJnZUNvbmZpZ3ModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi50YXJnZXQgfTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc291cmNlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIENvbXBsZXggZGVlcCBtZXJnZSBoYW5kbGluZ1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHsgLi4ucmVzdWx0W2tleV0sIC4uLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gRGlyZWN0IGFzc2lnbm1lbnQgZm9yIHByaW1pdGl2ZXMgYW5kIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZmlnTG9hZGVyID0gQ29uZmlnTG9hZGVyO1xuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgY29uZmlnIGxvYWRlciB3aXRoIGNvbW1vbiBzb3VyY2VzXG5jbGFzcyBDb25maWdMb2FkZXJGYWN0b3J5IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb25maWcgbG9hZGVyIHdpdGggZW52aXJvbm1lbnQgdmFyaWFibGVzIG9ubHlcbiAgICAgKiBAcmV0dXJucyBDb25maWdMb2FkZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRW52aXJvbm1lbnRMb2FkZXIoKSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBDb25maWdMb2FkZXIoKTtcbiAgICAgICAgbG9hZGVyLmFkZFNvdXJjZShuZXcgRW52aXJvbm1lbnRDb25maWdTb3VyY2UoKSk7XG4gICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbmZpZyBsb2FkZXIgd2l0aCBmaWxlIGFuZCBlbnZpcm9ubWVudCBzb3VyY2VzXG4gICAgICogQHBhcmFtIGNvbmZpZ0ZpbGVQYXRoIC0gUGF0aCB0byBjb25maWd1cmF0aW9uIGZpbGVcbiAgICAgKiBAcmV0dXJucyBDb25maWdMb2FkZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmlsZUFuZEVudmlyb25tZW50TG9hZGVyKGNvbmZpZ0ZpbGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBDb25maWdMb2FkZXIoKTtcbiAgICAgICAgbG9hZGVyLmFkZFNvdXJjZShuZXcgRmlsZUNvbmZpZ1NvdXJjZShjb25maWdGaWxlUGF0aCkpO1xuICAgICAgICBsb2FkZXIuYWRkU291cmNlKG5ldyBFbnZpcm9ubWVudENvbmZpZ1NvdXJjZSgpKTsgLy8gRW52aXJvbm1lbnQgb3ZlcnJpZGVzIGZpbGVcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29uZmlnIGxvYWRlciB3aXRoIG9iamVjdCwgZmlsZSwgYW5kIGVudmlyb25tZW50IHNvdXJjZXNcbiAgICAgKiBAcGFyYW0gYmFzZUNvbmZpZyAtIEJhc2UgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gY29uZmlnRmlsZVBhdGggLSBPcHRpb25hbCBwYXRoIHRvIGNvbmZpZ3VyYXRpb24gZmlsZVxuICAgICAqIEByZXR1cm5zIENvbmZpZ0xvYWRlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGdWxsTG9hZGVyKGJhc2VDb25maWcsIGNvbmZpZ0ZpbGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBDb25maWdMb2FkZXIoKTtcbiAgICAgICAgbG9hZGVyLmFkZFNvdXJjZShuZXcgT2JqZWN0Q29uZmlnU291cmNlKGJhc2VDb25maWcpKTtcbiAgICAgICAgaWYgKGNvbmZpZ0ZpbGVQYXRoKSB7XG4gICAgICAgICAgICBsb2FkZXIuYWRkU291cmNlKG5ldyBGaWxlQ29uZmlnU291cmNlKGNvbmZpZ0ZpbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmFkZFNvdXJjZShuZXcgRW52aXJvbm1lbnRDb25maWdTb3VyY2UoKSk7IC8vIEVudmlyb25tZW50IGhhcyBoaWdoZXN0IHByaW9yaXR5XG4gICAgICAgIHJldHVybiBsb2FkZXI7XG4gICAgfVxufVxuZXhwb3J0cy5Db25maWdMb2FkZXJGYWN0b3J5ID0gQ29uZmlnTG9hZGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbmZpZ0xvYWRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ConfigLoader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/FrameworkConfig.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/FrameworkConfig.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Framework Configuration Interface\n// Main configuration for the hexagonal framework and all services\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrameworkConfigBuilder = exports.defaultFrameworkConfig = void 0;\n// Default framework configuration\nexports.defaultFrameworkConfig = {\n    environment: 'development',\n    debug: true,\n    logLevel: 'info',\n    services: {},\n    rag: {\n        defaultChunkSize: 500,\n        defaultChunkOverlap: 50,\n        defaultMaxChunks: 5,\n        defaultSimilarityThreshold: 0.7,\n        enableConversationHistory: true\n    },\n    retry: {\n        maxAttempts: 3,\n        backoffMultiplier: 2,\n        maxBackoffMs: 10000,\n        retryableErrors: ['RATE_LIMITED', 'SERVICE_UNAVAILABLE', 'TIMEOUT', 'NETWORK_ERROR']\n    },\n    healthCheck: {\n        enabled: true,\n        intervalMs: 30000,\n        timeoutMs: 5000\n    },\n    rateLimiting: {\n        enabled: false,\n        windowMs: 60000,\n        maxRequests: 100,\n        skipFailedRequests: true\n    },\n    caching: {\n        enabled: false,\n        ttlMs: 300000, // 5 minutes\n        maxSize: 1000,\n        provider: 'memory'\n    },\n    monitoring: {\n        enabled: false,\n        collectUsageStats: false\n    }\n};\n// Configuration builder for easier setup\nclass FrameworkConfigBuilder {\n    constructor(baseConfig) {\n        this.config = {\n            ...exports.defaultFrameworkConfig,\n            ...baseConfig\n        };\n    }\n    environment(env) {\n        this.config.environment = env;\n        return this;\n    }\n    debug(enabled) {\n        this.config.debug = enabled;\n        return this;\n    }\n    logLevel(level) {\n        this.config.logLevel = level;\n        return this;\n    }\n    openai(config) {\n        this.config.services.openai = config;\n        return this;\n    }\n    tavily(config) {\n        this.config.services.tavily = config;\n        return this;\n    }\n    firebase(config) {\n        this.config.services.firebase = config;\n        return this;\n    }\n    stripe(config) {\n        this.config.services.stripe = config;\n        return this;\n    }\n    screenshot(config) {\n        this.config.services.screenshot = config;\n        return this;\n    }\n    database(config) {\n        this.config.services.database = config;\n        return this;\n    }\n    embedding(config) {\n        this.config.services.embedding = config;\n        return this;\n    }\n    textChunker(config) {\n        this.config.services.textChunker = config;\n        return this;\n    }\n    rag(config) {\n        this.config.rag = { ...this.config.rag, ...config };\n        return this;\n    }\n    retry(config) {\n        this.config.retry = { ...this.config.retry, ...config };\n        return this;\n    }\n    enableHealthCheck(intervalMs, timeoutMs) {\n        this.config.healthCheck = {\n            enabled: true,\n            intervalMs: intervalMs ?? this.config.healthCheck.intervalMs,\n            timeoutMs: timeoutMs ?? this.config.healthCheck.timeoutMs\n        };\n        return this;\n    }\n    enableRateLimiting(windowMs, maxRequests) {\n        this.config.rateLimiting = {\n            enabled: true,\n            windowMs,\n            maxRequests,\n            skipFailedRequests: true\n        };\n        return this;\n    }\n    enableCaching(provider, ttlMs) {\n        this.config.caching = {\n            enabled: true,\n            ttlMs: ttlMs ?? 300000,\n            maxSize: 1000,\n            provider\n        };\n        return this;\n    }\n    enableMonitoring(collectUsageStats = false) {\n        this.config.monitoring = {\n            enabled: true,\n            collectUsageStats\n        };\n        return this;\n    }\n    build() {\n        return { ...this.config };\n    }\n}\nexports.FrameworkConfigBuilder = FrameworkConfigBuilder;\n//# sourceMappingURL=FrameworkConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvbmZpZy9GcmFtZXdvcmtDb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLDhCQUE4QjtBQUMvRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvY29uZmlnL0ZyYW1ld29ya0NvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEZyYW1ld29yayBDb25maWd1cmF0aW9uIEludGVyZmFjZVxuLy8gTWFpbiBjb25maWd1cmF0aW9uIGZvciB0aGUgaGV4YWdvbmFsIGZyYW1ld29yayBhbmQgYWxsIHNlcnZpY2VzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZyYW1ld29ya0NvbmZpZ0J1aWxkZXIgPSBleHBvcnRzLmRlZmF1bHRGcmFtZXdvcmtDb25maWcgPSB2b2lkIDA7XG4vLyBEZWZhdWx0IGZyYW1ld29yayBjb25maWd1cmF0aW9uXG5leHBvcnRzLmRlZmF1bHRGcmFtZXdvcmtDb25maWcgPSB7XG4gICAgZW52aXJvbm1lbnQ6ICdkZXZlbG9wbWVudCcsXG4gICAgZGVidWc6IHRydWUsXG4gICAgbG9nTGV2ZWw6ICdpbmZvJyxcbiAgICBzZXJ2aWNlczoge30sXG4gICAgcmFnOiB7XG4gICAgICAgIGRlZmF1bHRDaHVua1NpemU6IDUwMCxcbiAgICAgICAgZGVmYXVsdENodW5rT3ZlcmxhcDogNTAsXG4gICAgICAgIGRlZmF1bHRNYXhDaHVua3M6IDUsXG4gICAgICAgIGRlZmF1bHRTaW1pbGFyaXR5VGhyZXNob2xkOiAwLjcsXG4gICAgICAgIGVuYWJsZUNvbnZlcnNhdGlvbkhpc3Rvcnk6IHRydWVcbiAgICB9LFxuICAgIHJldHJ5OiB7XG4gICAgICAgIG1heEF0dGVtcHRzOiAzLFxuICAgICAgICBiYWNrb2ZmTXVsdGlwbGllcjogMixcbiAgICAgICAgbWF4QmFja29mZk1zOiAxMDAwMCxcbiAgICAgICAgcmV0cnlhYmxlRXJyb3JzOiBbJ1JBVEVfTElNSVRFRCcsICdTRVJWSUNFX1VOQVZBSUxBQkxFJywgJ1RJTUVPVVQnLCAnTkVUV09SS19FUlJPUiddXG4gICAgfSxcbiAgICBoZWFsdGhDaGVjazoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpbnRlcnZhbE1zOiAzMDAwMCxcbiAgICAgICAgdGltZW91dE1zOiA1MDAwXG4gICAgfSxcbiAgICByYXRlTGltaXRpbmc6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHdpbmRvd01zOiA2MDAwMCxcbiAgICAgICAgbWF4UmVxdWVzdHM6IDEwMCxcbiAgICAgICAgc2tpcEZhaWxlZFJlcXVlc3RzOiB0cnVlXG4gICAgfSxcbiAgICBjYWNoaW5nOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICB0dGxNczogMzAwMDAwLCAvLyA1IG1pbnV0ZXNcbiAgICAgICAgbWF4U2l6ZTogMTAwMCxcbiAgICAgICAgcHJvdmlkZXI6ICdtZW1vcnknXG4gICAgfSxcbiAgICBtb25pdG9yaW5nOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xsZWN0VXNhZ2VTdGF0czogZmFsc2VcbiAgICB9XG59O1xuLy8gQ29uZmlndXJhdGlvbiBidWlsZGVyIGZvciBlYXNpZXIgc2V0dXBcbmNsYXNzIEZyYW1ld29ya0NvbmZpZ0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VDb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICAuLi5leHBvcnRzLmRlZmF1bHRGcmFtZXdvcmtDb25maWcsXG4gICAgICAgICAgICAuLi5iYXNlQ29uZmlnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVudmlyb25tZW50KGVudikge1xuICAgICAgICB0aGlzLmNvbmZpZy5lbnZpcm9ubWVudCA9IGVudjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlYnVnKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVidWcgPSBlbmFibGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICAgICAgdGhpcy5jb25maWcubG9nTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wZW5haShjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2VydmljZXMub3BlbmFpID0gY29uZmlnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGF2aWx5KGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXJ2aWNlcy50YXZpbHkgPSBjb25maWc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaXJlYmFzZShjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2VydmljZXMuZmlyZWJhc2UgPSBjb25maWc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdHJpcGUoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnNlcnZpY2VzLnN0cmlwZSA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNjcmVlbnNob3QoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnNlcnZpY2VzLnNjcmVlbnNob3QgPSBjb25maWc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhYmFzZShjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2VydmljZXMuZGF0YWJhc2UgPSBjb25maWc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbWJlZGRpbmcoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnNlcnZpY2VzLmVtYmVkZGluZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRleHRDaHVua2VyKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXJ2aWNlcy50ZXh0Q2h1bmtlciA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJhZyhjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcucmFnID0geyAuLi50aGlzLmNvbmZpZy5yYWcsIC4uLmNvbmZpZyB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0cnkoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJldHJ5ID0geyAuLi50aGlzLmNvbmZpZy5yZXRyeSwgLi4uY29uZmlnIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbmFibGVIZWFsdGhDaGVjayhpbnRlcnZhbE1zLCB0aW1lb3V0TXMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuaGVhbHRoQ2hlY2sgPSB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNcyA/PyB0aGlzLmNvbmZpZy5oZWFsdGhDaGVjay5pbnRlcnZhbE1zLFxuICAgICAgICAgICAgdGltZW91dE1zOiB0aW1lb3V0TXMgPz8gdGhpcy5jb25maWcuaGVhbHRoQ2hlY2sudGltZW91dE1zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbmFibGVSYXRlTGltaXRpbmcod2luZG93TXMsIG1heFJlcXVlc3RzKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJhdGVMaW1pdGluZyA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB3aW5kb3dNcyxcbiAgICAgICAgICAgIG1heFJlcXVlc3RzLFxuICAgICAgICAgICAgc2tpcEZhaWxlZFJlcXVlc3RzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbmFibGVDYWNoaW5nKHByb3ZpZGVyLCB0dGxNcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5jYWNoaW5nID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR0bE1zOiB0dGxNcyA/PyAzMDAwMDAsXG4gICAgICAgICAgICBtYXhTaXplOiAxMDAwLFxuICAgICAgICAgICAgcHJvdmlkZXJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVuYWJsZU1vbml0b3JpbmcoY29sbGVjdFVzYWdlU3RhdHMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tb25pdG9yaW5nID0ge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbGxlY3RVc2FnZVN0YXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgICB9XG59XG5leHBvcnRzLkZyYW1ld29ya0NvbmZpZ0J1aWxkZXIgPSBGcmFtZXdvcmtDb25maWdCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWV3b3JrQ29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/FrameworkConfig.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ServiceRegistry.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ServiceRegistry.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Service Registry - Dependency injection container for the hexagonal framework\n// Manages service creation, dependency resolution, and lifecycle\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServiceRegistryFactory = exports.ServiceRegistry = void 0;\nclass ServiceRegistry {\n    constructor(config, logger, errorHandler) {\n        this.services = new Map();\n        this.instances = new Map();\n        this.isInitialized = false;\n        this.config = config;\n        this.logger = logger;\n        this.errorHandler = errorHandler;\n    }\n    /**\n     * Register a service definition\n     * @param definition - Service definition\n     */\n    register(definition) {\n        if (this.isInitialized) {\n            throw new Error('Cannot register services after initialization');\n        }\n        this.services.set(definition.name, definition);\n        this.logger.debug('Service registered', {\n            service: definition.name,\n            singleton: definition.singleton,\n            dependencies: definition.dependencies || []\n        });\n    }\n    /**\n     * Register multiple service definitions\n     * @param definitions - Array of service definitions\n     */\n    registerMany(definitions) {\n        definitions.forEach(definition => this.register(definition));\n    }\n    /**\n     * Initialize all registered services in dependency order\n     */\n    async initialize() {\n        if (this.isInitialized) {\n            return;\n        }\n        this.logger.info('Initializing service registry', { servicesCount: this.services.size });\n        // Resolve dependency order\n        const dependencyOrder = this.resolveDependencyOrder();\n        // Create instances in dependency order\n        for (const serviceName of dependencyOrder) {\n            const definition = this.services.get(serviceName);\n            if (definition) {\n                try {\n                    const instance = definition.factory.create(this.config, this.logger);\n                    if (definition.singleton) {\n                        this.instances.set(serviceName, instance);\n                    }\n                    this.logger.debug('Service instance created', { service: serviceName });\n                }\n                catch (error) {\n                    this.logger.error('Failed to create service instance', { service: serviceName }, error);\n                    // Continue with other services instead of failing completely\n                }\n            }\n        }\n        this.isInitialized = true;\n        this.logger.info('Service registry initialization complete', {\n            servicesCount: this.instances.size\n        });\n    }\n    /**\n     * Get a service instance\n     * @param name - Service name\n     * @returns Service instance\n     */\n    get(name) {\n        if (!this.isInitialized) {\n            throw new Error('Service registry not initialized. Call initialize() first.');\n        }\n        const instance = this.instances.get(name);\n        if (!instance) {\n            throw new Error(`Service '${name}' not found or not initialized`);\n        }\n        return instance;\n    }\n    /**\n     * Check if a service is registered\n     * @param name - Service name\n     * @returns Whether service is registered\n     */\n    has(name) {\n        return this.services.has(name);\n    }\n    /**\n     * Check if a service instance exists\n     * @param name - Service name\n     * @returns Whether service instance exists\n     */\n    hasInstance(name) {\n        return this.instances.has(name);\n    }\n    /**\n     * Get all registered service names\n     * @returns Array of service names\n     */\n    getServiceNames() {\n        return Array.from(this.services.keys());\n    }\n    /**\n     * Get all service instances\n     * @returns Array of service instances\n     */\n    getAllInstances() {\n        return Array.from(this.instances.values());\n    }\n    /**\n     * Get all services that implement HealthCheckable\n     * @returns Array of health checkable services\n     */\n    getHealthCheckableServices() {\n        return this.getAllInstances().filter(instance => 'isHealthy' in instance && 'getServiceName' in instance);\n    }\n    /**\n     * Dispose of all services and cleanup\n     */\n    async dispose() {\n        this.logger.info('Disposing service registry');\n        // Dispose services in reverse dependency order\n        const sortedServices = this.resolveDependencyOrder().reverse();\n        for (const serviceName of sortedServices) {\n            const instance = this.instances.get(serviceName);\n            if (instance && 'dispose' in instance && typeof instance.dispose === 'function') {\n                try {\n                    await instance.dispose();\n                    this.logger.debug('Service disposed', { service: serviceName });\n                }\n                catch (error) {\n                    this.logger.error('Error disposing service', { service: serviceName }, error);\n                }\n            }\n        }\n        this.instances.clear();\n        this.isInitialized = false;\n        this.logger.info('Service registry disposed');\n    }\n    /**\n     * Update configuration for all services\n     * @param newConfig - New configuration\n     */\n    async updateConfig(newConfig) {\n        this.config = newConfig;\n        // Recreate services that support config updates\n        for (const serviceName of Array.from(this.instances.keys())) {\n            const instance = this.instances.get(serviceName);\n            if (instance && 'updateConfig' in instance && typeof instance.updateConfig === 'function') {\n                try {\n                    await instance.updateConfig(newConfig);\n                    this.logger.debug('Service config updated', { service: serviceName });\n                }\n                catch (error) {\n                    this.logger.error('Error updating service config', { service: serviceName }, error);\n                }\n            }\n        }\n    }\n    /**\n     * Resolve dependency order for service initialization\n     * @returns Array of service names in dependency order\n     */\n    resolveDependencyOrder() {\n        const visited = new Set();\n        const visiting = new Set();\n        const order = [];\n        const visit = (serviceName) => {\n            if (visiting.has(serviceName)) {\n                throw new Error(`Circular dependency detected involving service '${serviceName}'`);\n            }\n            if (visited.has(serviceName)) {\n                return;\n            }\n            visiting.add(serviceName);\n            const definition = this.services.get(serviceName);\n            if (definition?.dependencies) {\n                for (const dependency of definition.dependencies) {\n                    if (!this.services.has(dependency)) {\n                        throw new Error(`Dependency '${dependency}' not found for service '${serviceName}'`);\n                    }\n                    visit(dependency);\n                }\n            }\n            visiting.delete(serviceName);\n            visited.add(serviceName);\n            order.push(serviceName);\n        };\n        // Visit all registered services\n        for (const serviceName of Array.from(this.services.keys())) {\n            visit(serviceName);\n        }\n        return order;\n    }\n}\nexports.ServiceRegistry = ServiceRegistry;\n// Factory for creating service registry\nclass ServiceRegistryFactory {\n    static create(config, logger, errorHandler) {\n        return new ServiceRegistry(config, logger, errorHandler);\n    }\n    static createWithDefaults(config, logger, errorHandler, serviceFactories) {\n        const registry = new ServiceRegistry(config, logger, errorHandler);\n        // Register provided service factories\n        serviceFactories.forEach(factory => {\n            registry.register({\n                name: factory.getServiceName(),\n                factory,\n                singleton: true // Most services should be singletons\n            });\n        });\n        return registry;\n    }\n}\nexports.ServiceRegistryFactory = ServiceRegistryFactory;\n//# sourceMappingURL=ServiceRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvbmZpZy9TZXJ2aWNlUmVnaXN0cnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsbUNBQW1DO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usc0JBQXNCO0FBQzFGO0FBQ0E7QUFDQSw2RUFBNkUsc0JBQXNCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHNCQUFzQjtBQUNsRjtBQUNBO0FBQ0EsbUVBQW1FLHNCQUFzQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxzQkFBc0I7QUFDeEY7QUFDQTtBQUNBLHlFQUF5RSxzQkFBc0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixZQUFZO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXLDJCQUEyQixZQUFZO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb25maWcvU2VydmljZVJlZ2lzdHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gU2VydmljZSBSZWdpc3RyeSAtIERlcGVuZGVuY3kgaW5qZWN0aW9uIGNvbnRhaW5lciBmb3IgdGhlIGhleGFnb25hbCBmcmFtZXdvcmtcbi8vIE1hbmFnZXMgc2VydmljZSBjcmVhdGlvbiwgZGVwZW5kZW5jeSByZXNvbHV0aW9uLCBhbmQgbGlmZWN5Y2xlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZpY2VSZWdpc3RyeUZhY3RvcnkgPSBleHBvcnRzLlNlcnZpY2VSZWdpc3RyeSA9IHZvaWQgMDtcbmNsYXNzIFNlcnZpY2VSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBsb2dnZXIsIGVycm9ySGFuZGxlcikge1xuICAgICAgICB0aGlzLnNlcnZpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgc2VydmljZSBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIGRlZmluaXRpb24gLSBTZXJ2aWNlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICByZWdpc3RlcihkZWZpbml0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZ2lzdGVyIHNlcnZpY2VzIGFmdGVyIGluaXRpYWxpemF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5zZXQoZGVmaW5pdGlvbi5uYW1lLCBkZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1NlcnZpY2UgcmVnaXN0ZXJlZCcsIHtcbiAgICAgICAgICAgIHNlcnZpY2U6IGRlZmluaXRpb24ubmFtZSxcbiAgICAgICAgICAgIHNpbmdsZXRvbjogZGVmaW5pdGlvbi5zaW5nbGV0b24sXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IGRlZmluaXRpb24uZGVwZW5kZW5jaWVzIHx8IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBtdWx0aXBsZSBzZXJ2aWNlIGRlZmluaXRpb25zXG4gICAgICogQHBhcmFtIGRlZmluaXRpb25zIC0gQXJyYXkgb2Ygc2VydmljZSBkZWZpbml0aW9uc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyTWFueShkZWZpbml0aW9ucykge1xuICAgICAgICBkZWZpbml0aW9ucy5mb3JFYWNoKGRlZmluaXRpb24gPT4gdGhpcy5yZWdpc3RlcihkZWZpbml0aW9uKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYWxsIHJlZ2lzdGVyZWQgc2VydmljZXMgaW4gZGVwZW5kZW5jeSBvcmRlclxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdJbml0aWFsaXppbmcgc2VydmljZSByZWdpc3RyeScsIHsgc2VydmljZXNDb3VudDogdGhpcy5zZXJ2aWNlcy5zaXplIH0pO1xuICAgICAgICAvLyBSZXNvbHZlIGRlcGVuZGVuY3kgb3JkZXJcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeU9yZGVyID0gdGhpcy5yZXNvbHZlRGVwZW5kZW5jeU9yZGVyKCk7XG4gICAgICAgIC8vIENyZWF0ZSBpbnN0YW5jZXMgaW4gZGVwZW5kZW5jeSBvcmRlclxuICAgICAgICBmb3IgKGNvbnN0IHNlcnZpY2VOYW1lIG9mIGRlcGVuZGVuY3lPcmRlcikge1xuICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuc2VydmljZXMuZ2V0KHNlcnZpY2VOYW1lKTtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBkZWZpbml0aW9uLmZhY3RvcnkuY3JlYXRlKHRoaXMuY29uZmlnLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHNlcnZpY2VOYW1lLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1NlcnZpY2UgaW5zdGFuY2UgY3JlYXRlZCcsIHsgc2VydmljZTogc2VydmljZU5hbWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzZXJ2aWNlIGluc3RhbmNlJywgeyBzZXJ2aWNlOiBzZXJ2aWNlTmFtZSB9LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgc2VydmljZXMgaW5zdGVhZCBvZiBmYWlsaW5nIGNvbXBsZXRlbHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2VydmljZSByZWdpc3RyeSBpbml0aWFsaXphdGlvbiBjb21wbGV0ZScsIHtcbiAgICAgICAgICAgIHNlcnZpY2VzQ291bnQ6IHRoaXMuaW5zdGFuY2VzLnNpemVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFNlcnZpY2UgbmFtZVxuICAgICAqIEByZXR1cm5zIFNlcnZpY2UgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXQobmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2aWNlIHJlZ2lzdHJ5IG5vdCBpbml0aWFsaXplZC4gQ2FsbCBpbml0aWFsaXplKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmljZSAnJHtuYW1lfScgbm90IGZvdW5kIG9yIG5vdCBpbml0aWFsaXplZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBzZXJ2aWNlIGlzIHJlZ2lzdGVyZWRcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFNlcnZpY2UgbmFtZVxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgc2VydmljZSBpcyByZWdpc3RlcmVkXG4gICAgICovXG4gICAgaGFzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZXMuaGFzKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHNlcnZpY2UgaW5zdGFuY2UgZXhpc3RzXG4gICAgICogQHBhcmFtIG5hbWUgLSBTZXJ2aWNlIG5hbWVcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHNlcnZpY2UgaW5zdGFuY2UgZXhpc3RzXG4gICAgICovXG4gICAgaGFzSW5zdGFuY2UobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXMuaGFzKG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlZ2lzdGVyZWQgc2VydmljZSBuYW1lc1xuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIHNlcnZpY2UgbmFtZXNcbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc2VydmljZXMua2V5cygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBzZXJ2aWNlIGluc3RhbmNlc1xuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIHNlcnZpY2UgaW5zdGFuY2VzXG4gICAgICovXG4gICAgZ2V0QWxsSW5zdGFuY2VzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgc2VydmljZXMgdGhhdCBpbXBsZW1lbnQgSGVhbHRoQ2hlY2thYmxlXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgaGVhbHRoIGNoZWNrYWJsZSBzZXJ2aWNlc1xuICAgICAqL1xuICAgIGdldEhlYWx0aENoZWNrYWJsZVNlcnZpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxJbnN0YW5jZXMoKS5maWx0ZXIoaW5zdGFuY2UgPT4gJ2lzSGVhbHRoeScgaW4gaW5zdGFuY2UgJiYgJ2dldFNlcnZpY2VOYW1lJyBpbiBpbnN0YW5jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgYWxsIHNlcnZpY2VzIGFuZCBjbGVhbnVwXG4gICAgICovXG4gICAgYXN5bmMgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnRGlzcG9zaW5nIHNlcnZpY2UgcmVnaXN0cnknKTtcbiAgICAgICAgLy8gRGlzcG9zZSBzZXJ2aWNlcyBpbiByZXZlcnNlIGRlcGVuZGVuY3kgb3JkZXJcbiAgICAgICAgY29uc3Qgc29ydGVkU2VydmljZXMgPSB0aGlzLnJlc29sdmVEZXBlbmRlbmN5T3JkZXIoKS5yZXZlcnNlKCk7XG4gICAgICAgIGZvciAoY29uc3Qgc2VydmljZU5hbWUgb2Ygc29ydGVkU2VydmljZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KHNlcnZpY2VOYW1lKTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiAnZGlzcG9zZScgaW4gaW5zdGFuY2UgJiYgdHlwZW9mIGluc3RhbmNlLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTZXJ2aWNlIGRpc3Bvc2VkJywgeyBzZXJ2aWNlOiBzZXJ2aWNlTmFtZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFcnJvciBkaXNwb3Npbmcgc2VydmljZScsIHsgc2VydmljZTogc2VydmljZU5hbWUgfSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc3RhbmNlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2VydmljZSByZWdpc3RyeSBkaXNwb3NlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29uZmlndXJhdGlvbiBmb3IgYWxsIHNlcnZpY2VzXG4gICAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlQ29uZmlnKG5ld0NvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG5ld0NvbmZpZztcbiAgICAgICAgLy8gUmVjcmVhdGUgc2VydmljZXMgdGhhdCBzdXBwb3J0IGNvbmZpZyB1cGRhdGVzXG4gICAgICAgIGZvciAoY29uc3Qgc2VydmljZU5hbWUgb2YgQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy5rZXlzKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChzZXJ2aWNlTmFtZSk7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgJ3VwZGF0ZUNvbmZpZycgaW4gaW5zdGFuY2UgJiYgdHlwZW9mIGluc3RhbmNlLnVwZGF0ZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnVwZGF0ZUNvbmZpZyhuZXdDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnU2VydmljZSBjb25maWcgdXBkYXRlZCcsIHsgc2VydmljZTogc2VydmljZU5hbWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRXJyb3IgdXBkYXRpbmcgc2VydmljZSBjb25maWcnLCB7IHNlcnZpY2U6IHNlcnZpY2VOYW1lIH0sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBkZXBlbmRlbmN5IG9yZGVyIGZvciBzZXJ2aWNlIGluaXRpYWxpemF0aW9uXG4gICAgICogQHJldHVybnMgQXJyYXkgb2Ygc2VydmljZSBuYW1lcyBpbiBkZXBlbmRlbmN5IG9yZGVyXG4gICAgICovXG4gICAgcmVzb2x2ZURlcGVuZGVuY3lPcmRlcigpIHtcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgdmlzaXRpbmcgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IG9yZGVyID0gW107XG4gICAgICAgIGNvbnN0IHZpc2l0ID0gKHNlcnZpY2VOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAodmlzaXRpbmcuaGFzKHNlcnZpY2VOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2lyY3VsYXIgZGVwZW5kZW5jeSBkZXRlY3RlZCBpbnZvbHZpbmcgc2VydmljZSAnJHtzZXJ2aWNlTmFtZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlzaXRlZC5oYXMoc2VydmljZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlzaXRpbmcuYWRkKHNlcnZpY2VOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLnNlcnZpY2VzLmdldChzZXJ2aWNlTmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbj8uZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGRlZmluaXRpb24uZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXJ2aWNlcy5oYXMoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVwZW5kZW5jeSAnJHtkZXBlbmRlbmN5fScgbm90IGZvdW5kIGZvciBzZXJ2aWNlICcke3NlcnZpY2VOYW1lfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2aXNpdChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdGluZy5kZWxldGUoc2VydmljZU5hbWUpO1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoc2VydmljZU5hbWUpO1xuICAgICAgICAgICAgb3JkZXIucHVzaChzZXJ2aWNlTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFZpc2l0IGFsbCByZWdpc3RlcmVkIHNlcnZpY2VzXG4gICAgICAgIGZvciAoY29uc3Qgc2VydmljZU5hbWUgb2YgQXJyYXkuZnJvbSh0aGlzLnNlcnZpY2VzLmtleXMoKSkpIHtcbiAgICAgICAgICAgIHZpc2l0KHNlcnZpY2VOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2aWNlUmVnaXN0cnkgPSBTZXJ2aWNlUmVnaXN0cnk7XG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBzZXJ2aWNlIHJlZ2lzdHJ5XG5jbGFzcyBTZXJ2aWNlUmVnaXN0cnlGYWN0b3J5IHtcbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZywgbG9nZ2VyLCBlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXJ2aWNlUmVnaXN0cnkoY29uZmlnLCBsb2dnZXIsIGVycm9ySGFuZGxlcik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVXaXRoRGVmYXVsdHMoY29uZmlnLCBsb2dnZXIsIGVycm9ySGFuZGxlciwgc2VydmljZUZhY3Rvcmllcykge1xuICAgICAgICBjb25zdCByZWdpc3RyeSA9IG5ldyBTZXJ2aWNlUmVnaXN0cnkoY29uZmlnLCBsb2dnZXIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHByb3ZpZGVkIHNlcnZpY2UgZmFjdG9yaWVzXG4gICAgICAgIHNlcnZpY2VGYWN0b3JpZXMuZm9yRWFjaChmYWN0b3J5ID0+IHtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBmYWN0b3J5LmdldFNlcnZpY2VOYW1lKCksXG4gICAgICAgICAgICAgICAgZmFjdG9yeSxcbiAgICAgICAgICAgICAgICBzaW5nbGV0b246IHRydWUgLy8gTW9zdCBzZXJ2aWNlcyBzaG91bGQgYmUgc2luZ2xldG9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2aWNlUmVnaXN0cnlGYWN0b3J5ID0gU2VydmljZVJlZ2lzdHJ5RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcnZpY2VSZWdpc3RyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ServiceRegistry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/index.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Configuration management for the hexagonal framework\n// Handles environment variables, service configurations, and framework setup\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./FrameworkConfig */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/FrameworkConfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ServiceRegistry */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ServiceRegistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ConfigLoader */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ConfigLoader.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvbmZpZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHVIQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsdUhBQW1CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxpSEFBZ0I7QUFDckMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvbmZpZy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvbmZpZ3VyYXRpb24gbWFuYWdlbWVudCBmb3IgdGhlIGhleGFnb25hbCBmcmFtZXdvcmtcbi8vIEhhbmRsZXMgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBzZXJ2aWNlIGNvbmZpZ3VyYXRpb25zLCBhbmQgZnJhbWV3b3JrIHNldHVwXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GcmFtZXdvcmtDb25maWdcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1NlcnZpY2VSZWdpc3RyeVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29uZmlnTG9hZGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IAuthenticator.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IAuthenticator.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Authentication Port Interface\n// Defines the contract for user authentication services like Firebase\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IAuthenticator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSUF1dGhlbnRpY2F0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb3JlL3BvcnRzL0lBdXRoZW50aWNhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQXV0aGVudGljYXRpb24gUG9ydCBJbnRlcmZhY2Vcbi8vIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciB1c2VyIGF1dGhlbnRpY2F0aW9uIHNlcnZpY2VzIGxpa2UgRmlyZWJhc2Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlBdXRoZW50aWNhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IAuthenticator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IDatabaseAdapter.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IDatabaseAdapter.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Database Adapter Port Interface\n// Defines the contract for database operations with support for various database types\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IDatabaseAdapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSURhdGFiYXNlQWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSURhdGFiYXNlQWRhcHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIERhdGFiYXNlIEFkYXB0ZXIgUG9ydCBJbnRlcmZhY2Vcbi8vIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciBkYXRhYmFzZSBvcGVyYXRpb25zIHdpdGggc3VwcG9ydCBmb3IgdmFyaW91cyBkYXRhYmFzZSB0eXBlc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SURhdGFiYXNlQWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IDatabaseAdapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IEmbeddingGenerator.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IEmbeddingGenerator.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Embedding Generator Port Interface\n// Defines the contract for text-to-vector conversion services\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IEmbeddingGenerator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSUVtYmVkZGluZ0dlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSUVtYmVkZGluZ0dlbmVyYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIEVtYmVkZGluZyBHZW5lcmF0b3IgUG9ydCBJbnRlcmZhY2Vcbi8vIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciB0ZXh0LXRvLXZlY3RvciBjb252ZXJzaW9uIHNlcnZpY2VzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JRW1iZWRkaW5nR2VuZXJhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IEmbeddingGenerator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IFileStorage.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IFileStorage.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// File Storage Port Interface\n// Defines the contract for file storage operations with support for various storage providers\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IFileStorage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSUZpbGVTdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvY29yZS9wb3J0cy9JRmlsZVN0b3JhZ2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBGaWxlIFN0b3JhZ2UgUG9ydCBJbnRlcmZhY2Vcbi8vIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciBmaWxlIHN0b3JhZ2Ugb3BlcmF0aW9ucyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlvdXMgc3RvcmFnZSBwcm92aWRlcnNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlGaWxlU3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IFileStorage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IImageGenerator.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IImageGenerator.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Image Generation Port Interface\n// Defines the contract for AI image generation services\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IImageGenerator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSUltYWdlR2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvY29yZS9wb3J0cy9JSW1hZ2VHZW5lcmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBJbWFnZSBHZW5lcmF0aW9uIFBvcnQgSW50ZXJmYWNlXG4vLyBEZWZpbmVzIHRoZSBjb250cmFjdCBmb3IgQUkgaW1hZ2UgZ2VuZXJhdGlvbiBzZXJ2aWNlc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUltYWdlR2VuZXJhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IImageGenerator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IPaymentProcessor.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IPaymentProcessor.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Payment Processing Port Interface\n// Defines the contract for payment processing services like Stripe\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IPaymentProcessor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSVBheW1lbnRQcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb3JlL3BvcnRzL0lQYXltZW50UHJvY2Vzc29yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gUGF5bWVudCBQcm9jZXNzaW5nIFBvcnQgSW50ZXJmYWNlXG4vLyBEZWZpbmVzIHRoZSBjb250cmFjdCBmb3IgcGF5bWVudCBwcm9jZXNzaW5nIHNlcnZpY2VzIGxpa2UgU3RyaXBlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JUGF5bWVudFByb2Nlc3Nvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IPaymentProcessor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IScreenshotCapture.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IScreenshotCapture.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Screenshot Capture Port Interface\n// Defines the contract for screenshot capture services (full page screenshots)\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IScreenshotCapture.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSVNjcmVlbnNob3RDYXB0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvY29yZS9wb3J0cy9JU2NyZWVuc2hvdENhcHR1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBTY3JlZW5zaG90IENhcHR1cmUgUG9ydCBJbnRlcmZhY2Vcbi8vIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciBzY3JlZW5zaG90IGNhcHR1cmUgc2VydmljZXMgKGZ1bGwgcGFnZSBzY3JlZW5zaG90cylcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlTY3JlZW5zaG90Q2FwdHVyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IScreenshotCapture.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextChunker.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextChunker.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Text Chunker Port Interface\n// Defines the contract for text chunking services\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ITextChunker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSVRleHRDaHVua2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvY29yZS9wb3J0cy9JVGV4dENodW5rZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUZXh0IENodW5rZXIgUG9ydCBJbnRlcmZhY2Vcbi8vIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciB0ZXh0IGNodW5raW5nIHNlcnZpY2VzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JVGV4dENodW5rZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextChunker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextGenerator.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextGenerator.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Text Generation Port Interface\n// Defines the contract for text generation services with both sync and streaming support\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=ITextGenerator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSVRleHRHZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb3JlL3BvcnRzL0lUZXh0R2VuZXJhdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gVGV4dCBHZW5lcmF0aW9uIFBvcnQgSW50ZXJmYWNlXG4vLyBEZWZpbmVzIHRoZSBjb250cmFjdCBmb3IgdGV4dCBnZW5lcmF0aW9uIHNlcnZpY2VzIHdpdGggYm90aCBzeW5jIGFuZCBzdHJlYW1pbmcgc3VwcG9ydFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVRleHRHZW5lcmF0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextGenerator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebScraper.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebScraper.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Web Scraper Port Interface\n// Defines the contract for web scraping services\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IWebScraper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSVdlYlNjcmFwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb3JlL3BvcnRzL0lXZWJTY3JhcGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gV2ViIFNjcmFwZXIgUG9ydCBJbnRlcmZhY2Vcbi8vIERlZmluZXMgdGhlIGNvbnRyYWN0IGZvciB3ZWIgc2NyYXBpbmcgc2VydmljZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlXZWJTY3JhcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebScraper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebSearcher.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebSearcher.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Web Search Port Interface\n// Defines the contract for web search services like Tavily\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=IWebSearcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvSVdlYlNlYXJjaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvY29yZS9wb3J0cy9JV2ViU2VhcmNoZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBXZWIgU2VhcmNoIFBvcnQgSW50ZXJmYWNlXG4vLyBEZWZpbmVzIHRoZSBjb250cmFjdCBmb3Igd2ViIHNlYXJjaCBzZXJ2aWNlcyBsaWtlIFRhdmlseVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SVdlYlNlYXJjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebSearcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/index.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Core ports (interfaces) for the hexagonal framework\n// These define the contracts that adapters must implement\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./ITextGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextGenerator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IImageGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IImageGenerator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IWebSearcher */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebSearcher.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IWebScraper */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IWebScraper.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IScreenshotCapture */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IScreenshotCapture.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IAuthenticator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IAuthenticator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IPaymentProcessor */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IPaymentProcessor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IDatabaseAdapter */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IDatabaseAdapter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IEmbeddingGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IEmbeddingGenerator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./IFileStorage */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/IFileStorage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ITextChunker */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/ITextChunker.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvcG9ydHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyx5SEFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLDJIQUFtQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMscUhBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxtSEFBZTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsaUlBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyx5SEFBa0I7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLCtIQUFxQjtBQUMxQyxhQUFhLG1CQUFPLENBQUMsNkhBQW9CO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxtSUFBdUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLHFIQUFnQjtBQUNyQyxhQUFhLG1CQUFPLENBQUMscUhBQWdCO0FBQ3JDIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb3JlL3BvcnRzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29yZSBwb3J0cyAoaW50ZXJmYWNlcykgZm9yIHRoZSBoZXhhZ29uYWwgZnJhbWV3b3JrXG4vLyBUaGVzZSBkZWZpbmUgdGhlIGNvbnRyYWN0cyB0aGF0IGFkYXB0ZXJzIG11c3QgaW1wbGVtZW50XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JVGV4dEdlbmVyYXRvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSUltYWdlR2VuZXJhdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JV2ViU2VhcmNoZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0lXZWJTY3JhcGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JU2NyZWVuc2hvdENhcHR1cmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0lBdXRoZW50aWNhdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JUGF5bWVudFByb2Nlc3NvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSURhdGFiYXNlQWRhcHRlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSUVtYmVkZGluZ0dlbmVyYXRvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSUZpbGVTdG9yYWdlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JVGV4dENodW5rZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/CommonTypes.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/CommonTypes.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Common types used throughout the hexagonal framework\n// These are basic building blocks that multiple services will use\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=CommonTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvdHlwZXMvQ29tbW9uVHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb3JlL3R5cGVzL0NvbW1vblR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29tbW9uIHR5cGVzIHVzZWQgdGhyb3VnaG91dCB0aGUgaGV4YWdvbmFsIGZyYW1ld29ya1xuLy8gVGhlc2UgYXJlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyB0aGF0IG11bHRpcGxlIHNlcnZpY2VzIHdpbGwgdXNlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21tb25UeXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/CommonTypes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Error handling types and custom exceptions for the hexagonal framework\n// Provides standardized error handling across all services\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuotaExceededError = exports.ConfigurationError = exports.NetworkError = exports.TimeoutError = exports.ServiceUnavailableError = exports.RateLimitError = exports.AuthorizationError = exports.AuthenticationError = exports.ValidationError = exports.BaseFrameworkError = void 0;\n// Base error class for the framework\nclass BaseFrameworkError extends Error {\n    constructor(code, message, options) {\n        super(message);\n        this.name = 'FrameworkError';\n        this.code = code;\n        this.service = options?.service;\n        this.operation = options?.operation;\n        this.details = options?.details;\n        this.timestamp = new Date();\n        this.retryable = options?.retryable ?? false;\n        if (options?.cause) {\n            this.cause = options.cause;\n        }\n    }\n    toJSON() {\n        return {\n            code: this.code,\n            message: this.message,\n            service: this.service,\n            operation: this.operation,\n            details: this.details,\n            timestamp: this.timestamp,\n            retryable: this.retryable,\n        };\n    }\n}\nexports.BaseFrameworkError = BaseFrameworkError;\n// Specific error classes for different scenarios\nclass ValidationError extends BaseFrameworkError {\n    constructor(message, details) {\n        super('INVALID_INPUT', message, { details, retryable: false });\n        this.name = 'ValidationError';\n    }\n}\nexports.ValidationError = ValidationError;\nclass AuthenticationError extends BaseFrameworkError {\n    constructor(message, service) {\n        super('UNAUTHORIZED', message, { service, retryable: false });\n        this.name = 'AuthenticationError';\n    }\n}\nexports.AuthenticationError = AuthenticationError;\nclass AuthorizationError extends BaseFrameworkError {\n    constructor(message, service) {\n        super('FORBIDDEN', message, { service, retryable: false });\n        this.name = 'AuthorizationError';\n    }\n}\nexports.AuthorizationError = AuthorizationError;\nclass RateLimitError extends BaseFrameworkError {\n    constructor(message, service, retryAfter) {\n        super('RATE_LIMITED', message, {\n            service,\n            retryable: true,\n            details: { retryAfter }\n        });\n        this.name = 'RateLimitError';\n    }\n}\nexports.RateLimitError = RateLimitError;\nclass ServiceUnavailableError extends BaseFrameworkError {\n    constructor(message, service) {\n        super('SERVICE_UNAVAILABLE', message, { service, retryable: true });\n        this.name = 'ServiceUnavailableError';\n    }\n}\nexports.ServiceUnavailableError = ServiceUnavailableError;\nclass TimeoutError extends BaseFrameworkError {\n    constructor(message, service, operation) {\n        super('TIMEOUT', message, { service, operation, retryable: true });\n        this.name = 'TimeoutError';\n    }\n}\nexports.TimeoutError = TimeoutError;\nclass NetworkError extends BaseFrameworkError {\n    constructor(message, service, cause) {\n        super('NETWORK_ERROR', message, { service, retryable: true, cause });\n        this.name = 'NetworkError';\n    }\n}\nexports.NetworkError = NetworkError;\nclass ConfigurationError extends BaseFrameworkError {\n    constructor(message, service, details) {\n        super('INVALID_CONFIGURATION', message, { service, details, retryable: false });\n        this.name = 'ConfigurationError';\n    }\n}\nexports.ConfigurationError = ConfigurationError;\nclass QuotaExceededError extends BaseFrameworkError {\n    constructor(message, service, details) {\n        super('QUOTA_EXCEEDED', message, { service, details, retryable: false });\n        this.name = 'QuotaExceededError';\n    }\n}\nexports.QuotaExceededError = QuotaExceededError;\n//# sourceMappingURL=ErrorTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2NvcmUvdHlwZXMvRXJyb3JUeXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsK0JBQStCLEdBQUcsc0JBQXNCLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCO0FBQ2xSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUNBQXlDLDJCQUEyQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZ0RBQWdELDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG9DQUFvQyxxQ0FBcUM7QUFDekU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSwwQ0FBMEMsaUNBQWlDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esa0RBQWtELG9DQUFvQztBQUN0RjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDJDQUEyQyxvQ0FBb0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9jb3JlL3R5cGVzL0Vycm9yVHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFcnJvciBoYW5kbGluZyB0eXBlcyBhbmQgY3VzdG9tIGV4Y2VwdGlvbnMgZm9yIHRoZSBoZXhhZ29uYWwgZnJhbWV3b3JrXG4vLyBQcm92aWRlcyBzdGFuZGFyZGl6ZWQgZXJyb3IgaGFuZGxpbmcgYWNyb3NzIGFsbCBzZXJ2aWNlc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdW90YUV4Y2VlZGVkRXJyb3IgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25FcnJvciA9IGV4cG9ydHMuTmV0d29ya0Vycm9yID0gZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBleHBvcnRzLlNlcnZpY2VVbmF2YWlsYWJsZUVycm9yID0gZXhwb3J0cy5SYXRlTGltaXRFcnJvciA9IGV4cG9ydHMuQXV0aG9yaXphdGlvbkVycm9yID0gZXhwb3J0cy5BdXRoZW50aWNhdGlvbkVycm9yID0gZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLkJhc2VGcmFtZXdvcmtFcnJvciA9IHZvaWQgMDtcbi8vIEJhc2UgZXJyb3IgY2xhc3MgZm9yIHRoZSBmcmFtZXdvcmtcbmNsYXNzIEJhc2VGcmFtZXdvcmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRnJhbWV3b3JrRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBvcHRpb25zPy5zZXJ2aWNlO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wdGlvbnM/Lm9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gb3B0aW9ucz8uZGV0YWlscztcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnJldHJ5YWJsZSA9IG9wdGlvbnM/LnJldHJ5YWJsZSA/PyBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmNhdXNlKSB7XG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzZXJ2aWNlOiB0aGlzLnNlcnZpY2UsXG4gICAgICAgICAgICBvcGVyYXRpb246IHRoaXMub3BlcmF0aW9uLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogdGhpcy5yZXRyeWFibGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlRnJhbWV3b3JrRXJyb3IgPSBCYXNlRnJhbWV3b3JrRXJyb3I7XG4vLyBTcGVjaWZpYyBlcnJvciBjbGFzc2VzIGZvciBkaWZmZXJlbnQgc2NlbmFyaW9zXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRnJhbWV3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGRldGFpbHMpIHtcbiAgICAgICAgc3VwZXIoJ0lOVkFMSURfSU5QVVQnLCBtZXNzYWdlLCB7IGRldGFpbHMsIHJldHJ5YWJsZTogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xuY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEJhc2VGcmFtZXdvcmtFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc2VydmljZSkge1xuICAgICAgICBzdXBlcignVU5BVVRIT1JJWkVEJywgbWVzc2FnZSwgeyBzZXJ2aWNlLCByZXRyeWFibGU6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aGVudGljYXRpb25FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0cy5BdXRoZW50aWNhdGlvbkVycm9yID0gQXV0aGVudGljYXRpb25FcnJvcjtcbmNsYXNzIEF1dGhvcml6YXRpb25FcnJvciBleHRlbmRzIEJhc2VGcmFtZXdvcmtFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc2VydmljZSkge1xuICAgICAgICBzdXBlcignRk9SQklEREVOJywgbWVzc2FnZSwgeyBzZXJ2aWNlLCByZXRyeWFibGU6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aG9yaXphdGlvbkVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLkF1dGhvcml6YXRpb25FcnJvciA9IEF1dGhvcml6YXRpb25FcnJvcjtcbmNsYXNzIFJhdGVMaW1pdEVycm9yIGV4dGVuZHMgQmFzZUZyYW1ld29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzZXJ2aWNlLCByZXRyeUFmdGVyKSB7XG4gICAgICAgIHN1cGVyKCdSQVRFX0xJTUlURUQnLCBtZXNzYWdlLCB7XG4gICAgICAgICAgICBzZXJ2aWNlLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsczogeyByZXRyeUFmdGVyIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSYXRlTGltaXRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0cy5SYXRlTGltaXRFcnJvciA9IFJhdGVMaW1pdEVycm9yO1xuY2xhc3MgU2VydmljZVVuYXZhaWxhYmxlRXJyb3IgZXh0ZW5kcyBCYXNlRnJhbWV3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ1NFUlZJQ0VfVU5BVkFJTEFCTEUnLCBtZXNzYWdlLCB7IHNlcnZpY2UsIHJldHJ5YWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NlcnZpY2VVbmF2YWlsYWJsZUVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLlNlcnZpY2VVbmF2YWlsYWJsZUVycm9yID0gU2VydmljZVVuYXZhaWxhYmxlRXJyb3I7XG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBCYXNlRnJhbWV3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNlcnZpY2UsIG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlcignVElNRU9VVCcsIG1lc3NhZ2UsIHsgc2VydmljZSwgb3BlcmF0aW9uLCByZXRyeWFibGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgQmFzZUZyYW1ld29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzZXJ2aWNlLCBjYXVzZSkge1xuICAgICAgICBzdXBlcignTkVUV09SS19FUlJPUicsIG1lc3NhZ2UsIHsgc2VydmljZSwgcmV0cnlhYmxlOiB0cnVlLCBjYXVzZSB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ05ldHdvcmtFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrRXJyb3IgPSBOZXR3b3JrRXJyb3I7XG5jbGFzcyBDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBCYXNlRnJhbWV3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNlcnZpY2UsIGRldGFpbHMpIHtcbiAgICAgICAgc3VwZXIoJ0lOVkFMSURfQ09ORklHVVJBVElPTicsIG1lc3NhZ2UsIHsgc2VydmljZSwgZGV0YWlscywgcmV0cnlhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbmZpZ3VyYXRpb25FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0cy5Db25maWd1cmF0aW9uRXJyb3IgPSBDb25maWd1cmF0aW9uRXJyb3I7XG5jbGFzcyBRdW90YUV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBCYXNlRnJhbWV3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNlcnZpY2UsIGRldGFpbHMpIHtcbiAgICAgICAgc3VwZXIoJ1FVT1RBX0VYQ0VFREVEJywgbWVzc2FnZSwgeyBzZXJ2aWNlLCBkZXRhaWxzLCByZXRyeWFibGU6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUXVvdGFFeGNlZWRlZEVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLlF1b3RhRXhjZWVkZWRFcnJvciA9IFF1b3RhRXhjZWVkZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9yVHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Main framework exports - hexagonal architecture with dependency injection\n// This file provides the primary entry point for the framework\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Core domain exports - interfaces only\n__exportStar(__webpack_require__(/*! ./core/ports */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/ports/index.js\"), exports);\n// Core types exports - exclude conflicting embedding types (use ports version)\n__exportStar(__webpack_require__(/*! ./core/types/CommonTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/CommonTypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\"), exports);\n// Configuration and registry\n__exportStar(__webpack_require__(/*! ./config */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/index.js\"), exports);\n// Utilities\n__exportStar(__webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/index.js\"), exports);\n// Adapter implementations\n__exportStar(__webpack_require__(/*! ./adapters */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/index.js\"), exports);\n// Application Framework Facade - High-level interface for applications\n__exportStar(__webpack_require__(/*! ./sdk/ApplicationFramework */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/sdk/ApplicationFramework.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw0R0FBYztBQUNuQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4SEFBMEI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLDRIQUF5QjtBQUM5QztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvR0FBVTtBQUMvQjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxrR0FBUztBQUM5QjtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx3R0FBWTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxrSUFBNEI7QUFDakQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gTWFpbiBmcmFtZXdvcmsgZXhwb3J0cyAtIGhleGFnb25hbCBhcmNoaXRlY3R1cmUgd2l0aCBkZXBlbmRlbmN5IGluamVjdGlvblxuLy8gVGhpcyBmaWxlIHByb3ZpZGVzIHRoZSBwcmltYXJ5IGVudHJ5IHBvaW50IGZvciB0aGUgZnJhbWV3b3JrXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIENvcmUgZG9tYWluIGV4cG9ydHMgLSBpbnRlcmZhY2VzIG9ubHlcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb3JlL3BvcnRzXCIpLCBleHBvcnRzKTtcbi8vIENvcmUgdHlwZXMgZXhwb3J0cyAtIGV4Y2x1ZGUgY29uZmxpY3RpbmcgZW1iZWRkaW5nIHR5cGVzICh1c2UgcG9ydHMgdmVyc2lvbilcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb3JlL3R5cGVzL0NvbW1vblR5cGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb3JlL3R5cGVzL0Vycm9yVHlwZXNcIiksIGV4cG9ydHMpO1xuLy8gQ29uZmlndXJhdGlvbiBhbmQgcmVnaXN0cnlcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25maWdcIiksIGV4cG9ydHMpO1xuLy8gVXRpbGl0aWVzXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuLy8gQWRhcHRlciBpbXBsZW1lbnRhdGlvbnNcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hZGFwdGVyc1wiKSwgZXhwb3J0cyk7XG4vLyBBcHBsaWNhdGlvbiBGcmFtZXdvcmsgRmFjYWRlIC0gSGlnaC1sZXZlbCBpbnRlcmZhY2UgZm9yIGFwcGxpY2F0aW9uc1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Nkay9BcHBsaWNhdGlvbkZyYW1ld29ya1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/sdk/ApplicationFramework.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/sdk/ApplicationFramework.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Application Framework - High-level facade for applications\n// Provides a clean interface to the hexagonal framework without tight coupling\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ApplicationFramework = void 0;\nconst ServiceRegistry_1 = __webpack_require__(/*! ../config/ServiceRegistry */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ServiceRegistry.js\");\nconst Logger_1 = __webpack_require__(/*! ../utils/Logger */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/Logger.js\");\nconst HealthCheck_1 = __webpack_require__(/*! ../utils/HealthCheck */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/HealthCheck.js\");\nconst ConfigLoader_1 = __webpack_require__(/*! ../config/ConfigLoader */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/config/ConfigLoader.js\");\nconst ErrorHandler_1 = __webpack_require__(/*! ../utils/ErrorHandler */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js\");\nconst openai_1 = __webpack_require__(/*! ../adapters/openai */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/index.js\");\nconst scraping_1 = __webpack_require__(/*! ../adapters/scraping */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/scraping/index.js\");\nconst screenshot_1 = __webpack_require__(/*! ../adapters/screenshot */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/screenshot/index.js\");\nconst tavily_1 = __webpack_require__(/*! ../adapters/tavily */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/tavily/index.js\");\nconst database_1 = __webpack_require__(/*! ../adapters/database */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/database/index.js\");\nconst embeddings_1 = __webpack_require__(/*! ../adapters/embeddings */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/embeddings/index.js\");\nconst storage_1 = __webpack_require__(/*! ../adapters/storage */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/storage/index.js\");\nconst textprocessing_1 = __webpack_require__(/*! ../adapters/textprocessing */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/textprocessing/index.js\");\nconst crawling_1 = __webpack_require__(/*! ../adapters/crawling */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/crawling/index.js\");\nclass ApplicationFramework {\n    constructor(config) {\n        this.config = config;\n        this.isInitialized = false;\n    }\n    /**\n     * Initialize the framework with configuration\n     */\n    async initialize() {\n        if (this.isInitialized) {\n            return;\n        }\n        // Load configuration\n        let frameworkConfig;\n        if (this.config) {\n            // Use provided config\n            const configLoader = ConfigLoader_1.ConfigLoaderFactory.createEnvironmentLoader();\n            const envConfig = await configLoader.load();\n            frameworkConfig = { ...envConfig, ...this.config };\n        }\n        else {\n            // Load from environment\n            const configLoader = ConfigLoader_1.ConfigLoaderFactory.createEnvironmentLoader();\n            frameworkConfig = await configLoader.load();\n        }\n        // Initialize logger\n        this.logger = Logger_1.LoggerFactory.getSingleton(frameworkConfig.logLevel);\n        this.logger.info('ApplicationFramework initializing', { environment: frameworkConfig.environment });\n        // Create error handler\n        const errorHandler = new ErrorHandler_1.FrameworkErrorHandler(frameworkConfig.retry);\n        // Create all service factories\n        const serviceFactories = [\n            ...(0, openai_1.createOpenAIServiceFactories)(),\n            (0, scraping_1.createWebScrapingServiceFactory)(),\n            (0, screenshot_1.createScreenshotServiceFactory)(),\n            (0, tavily_1.createTavilyServiceFactory)(),\n            new database_1.PostgreSQLServiceFactory(),\n            new embeddings_1.EmbeddingServiceFactory(),\n            new storage_1.FileStorageServiceFactory(),\n            new textprocessing_1.TextChunkerServiceFactory()\n        ];\n        this.serviceRegistry = ServiceRegistry_1.ServiceRegistryFactory.createWithDefaults(frameworkConfig, this.logger, errorHandler, serviceFactories);\n        await this.serviceRegistry.initialize();\n        // Connect database if available\n        try {\n            const database = this.serviceRegistry.get('databaseAdapter');\n            await database.connect();\n            this.logger.info('Database connected successfully');\n        }\n        catch (error) {\n            this.logger.warn('Database connection failed or not configured', { error: error.message });\n        }\n        // Setup health monitoring\n        this.healthCheck = HealthCheck_1.HealthCheckFactory.createDefault(this.logger);\n        const healthCheckableServices = this.serviceRegistry.getHealthCheckableServices();\n        healthCheckableServices.forEach((service) => {\n            this.healthCheck.registerService(service);\n        });\n        this.healthCheck.start();\n        this.isInitialized = true;\n        this.logger.info('ApplicationFramework initialized successfully');\n    }\n    /**\n     * Generate text using the framework's text generation service\n     */\n    async generateText(prompt, options) {\n        this.ensureInitialized();\n        const textGenerator = this.serviceRegistry.get('textGenerator');\n        const request = {\n            prompt,\n            model: options?.model,\n            maxTokens: options?.maxTokens,\n            temperature: options?.temperature,\n            conversationHistory: options?.conversationHistory\n        };\n        const response = await textGenerator.generateText(request);\n        if (!response.success || !response.data) {\n            throw new Error(response.error || 'Text generation failed');\n        }\n        return response.data.text;\n    }\n    /**\n     * Generate text with streaming response\n     */\n    async generateTextStream(prompt, options) {\n        this.ensureInitialized();\n        const textGenerator = this.serviceRegistry.get('textGenerator');\n        const request = {\n            prompt,\n            model: options.model,\n            maxTokens: options.maxTokens,\n            temperature: options.temperature,\n            conversationHistory: options.conversationHistory\n        };\n        try {\n            const generator = textGenerator.generateTextStream(request);\n            for await (const chunk of generator) {\n                options.onChunk(chunk.text);\n            }\n            options.onComplete();\n        }\n        catch (error) {\n            options.onError(error.message);\n        }\n    }\n    /**\n     * Get the enhanced text generator with responses API support\n     */\n    getEnhancedTextGenerator() {\n        this.ensureInitialized();\n        // Create enhanced text generator on demand since it's not in the standard registry\n        const { EnhancedOpenAITextGenerator } = __webpack_require__(/*! ../adapters/openai/EnhancedOpenAITextGenerator */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/adapters/openai/EnhancedOpenAITextGenerator.js\");\n        // Load OpenAI configuration directly from environment variables\n        const openaiConfig = {\n            apiKey: process.env.OPENAI_API_KEY,\n            baseUrl: process.env.OPENAI_BASE_URL,\n            timeout: process.env.OPENAI_TIMEOUT ? parseInt(process.env.OPENAI_TIMEOUT) : undefined,\n            model: process.env.OPENAI_MODEL,\n            organization: process.env.OPENAI_ORGANIZATION\n        };\n        // Create error handler with default retry configuration\n        const { FrameworkErrorHandler } = __webpack_require__(/*! ../utils/ErrorHandler */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js\");\n        const errorHandler = new FrameworkErrorHandler({\n            maxAttempts: 3,\n            backoffMultiplier: 2,\n            maxBackoffMs: 30000\n        });\n        const enhancedGenerator = new EnhancedOpenAITextGenerator(openaiConfig, this.logger, errorHandler);\n        return enhancedGenerator;\n    }\n    /**\n     * Generate images using the framework's image generation service\n     */\n    async generateImage(prompt, options) {\n        this.ensureInitialized();\n        const imageGenerator = this.serviceRegistry.get('imageGenerator');\n        const request = {\n            prompt,\n            size: options?.size,\n            quality: options?.quality,\n            style: options?.style,\n            n: options?.n\n        };\n        const response = await imageGenerator.generateImage(request);\n        if (!response.success || !response.data) {\n            throw new Error(response.error || 'Image generation failed');\n        }\n        return response.data.images;\n    }\n    /**\n     * Search the web using the framework's web search service\n     */\n    async searchWeb(query, options) {\n        this.ensureInitialized();\n        const webSearcher = this.serviceRegistry.get('webSearcher');\n        const request = {\n            query,\n            maxResults: options?.maxResults,\n            searchDepth: options?.searchDepth,\n            includeDomains: options?.includeDomains,\n            excludeDomains: options?.excludeDomains\n        };\n        const response = await webSearcher.search(request);\n        if (!response.success || !response.data) {\n            throw new Error(response.error || 'Web search failed');\n        }\n        return {\n            results: response.data.results,\n            query: response.data.query,\n            answer: response.data.answer,\n            totalResults: response.data.totalResults\n        };\n    }\n    /**\n     * Scrape a web page using the framework's web scraping service\n     */\n    async scrapeWebPage(url, options) {\n        this.ensureInitialized();\n        const webScraper = this.serviceRegistry.get('webScraper');\n        const request = {\n            url,\n            selector: options?.selector,\n            waitFor: options?.waitFor,\n            includeImages: options?.includeImages,\n            followLinks: options?.followLinks,\n            maxDepth: options?.maxDepth\n        };\n        const response = await webScraper.scrapePage(request);\n        if (!response.success || !response.data) {\n            throw new Error(response.error || 'Web scraping failed');\n        }\n        return {\n            url: response.data.url,\n            title: response.data.title,\n            content: response.data.content,\n            images: response.data.images,\n            links: response.data.links,\n            metadata: response.data.metadata,\n            scrapedAt: response.data.scrapedAt\n        };\n    }\n    /**\n     * Capture a screenshot using the framework's screenshot service\n     */\n    async captureScreenshot(url, options) {\n        this.ensureInitialized();\n        const screenshotCapture = this.serviceRegistry.get('screenshotCapture');\n        const request = {\n            url,\n            fullPage: options?.fullPage,\n            width: options?.width,\n            height: options?.height,\n            format: options?.format,\n            quality: options?.quality,\n            waitFor: options?.waitFor\n        };\n        const response = await screenshotCapture.captureScreenshot(request);\n        if (!response.success || !response.data) {\n            throw new Error(response.error || 'Screenshot capture failed');\n        }\n        return {\n            imageBuffer: response.data.image.buffer || Buffer.from([]),\n            mimeType: response.data.image.mimeType,\n            url: response.data.url,\n            dimensions: response.data.dimensions\n        };\n    }\n    /**\n     * Get health status of all services\n     */\n    async getHealthStatus() {\n        this.ensureInitialized();\n        const healthReport = await this.healthCheck.checkHealth();\n        return healthReport.services.map(service => ({\n            service: service.service,\n            status: service.status,\n            lastChecked: service.timestamp,\n            error: service.details?.error\n        }));\n    }\n    /**\n     * Check if the framework is healthy\n     */\n    async isHealthy() {\n        this.ensureInitialized();\n        return this.healthCheck.isSystemHealthy();\n    }\n    /**\n     * Discover crawlable pages from a website (for preview/analysis)\n     */\n    async discoverCrawlablePages(url, options) {\n        this.ensureInitialized();\n        try {\n            const webScraper = this.serviceRegistry.get('webScraper');\n            const crawler = new crawling_1.WebCrawler(webScraper);\n            const startTime = Date.now();\n            const crawlResults = await crawler.crawlWebsite(url, {\n                maxPages: options?.maxPages || 10,\n                maxDepth: options?.maxDepth || 2,\n                includePatterns: options?.includePatterns || [],\n                excludePatterns: options?.excludePatterns || [],\n                followExternalLinks: options?.followExternalLinks || false,\n                delay: options?.delay || 1000\n            });\n            const crawlDuration = Date.now() - startTime;\n            // Process results for summary\n            const pagesByDepth = {};\n            let totalLinks = 0;\n            const pages = crawlResults.map(result => {\n                pagesByDepth[result.depth] = (pagesByDepth[result.depth] || 0) + 1;\n                totalLinks += result.links.length;\n                return {\n                    url: result.url,\n                    title: result.title,\n                    depth: result.depth,\n                    linkCount: result.links.length,\n                    wordCount: result.metadata.wordCount,\n                    timestamp: result.timestamp\n                };\n            });\n            const maxDepthReached = Math.max(...pages.map(p => p.depth), 0);\n            const averageLinksPerPage = pages.length > 0 ? totalLinks / pages.length : 0;\n            return {\n                success: true,\n                data: {\n                    startUrl: url,\n                    totalPagesDiscovered: pages.length,\n                    maxDepthReached,\n                    crawlDuration,\n                    pages,\n                    summary: {\n                        pagesByDepth,\n                        totalLinks,\n                        averageLinksPerPage: Math.round(averageLinksPerPage * 10) / 10\n                    }\n                }\n            };\n        }\n        catch (error) {\n            this.logger.error('Crawling discovery failed', { url, error: error.message });\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Get database adapter for direct database operations\n     * Note: This is a building block - applications should build their own database logic on top\n     */\n    getDatabaseAdapter() {\n        this.ensureInitialized();\n        return this.serviceRegistry.get('databaseAdapter');\n    }\n    /**\n     * Execute a database query (building block for applications)\n     */\n    async executeQuery(sql, params) {\n        this.ensureInitialized();\n        try {\n            const database = this.serviceRegistry.get('databaseAdapter');\n            const result = await database.query(sql, params);\n            return {\n                success: result.success,\n                rows: result.data?.rows,\n                rowCount: result.data?.rowCount,\n                error: result.error\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Check if database is connected and healthy\n     */\n    async isDatabaseHealthy() {\n        this.ensureInitialized();\n        try {\n            const database = this.serviceRegistry.get('databaseAdapter');\n            return await database.isHealthy();\n        }\n        catch (error) {\n            this.logger.error('Database health check failed', { error: error.message });\n            return false;\n        }\n    }\n    /**\n     * Get database connection information\n     */\n    getDatabaseInfo() {\n        this.ensureInitialized();\n        const database = this.serviceRegistry.get('databaseAdapter');\n        return database.getConnectionInfo();\n    }\n    /**\n     * Generate embeddings for text(s) - building block for vector operations\n     */\n    async generateEmbeddings(texts, options) {\n        this.ensureInitialized();\n        try {\n            const embeddingGenerator = this.serviceRegistry.get('embeddingGenerator');\n            const result = await embeddingGenerator.generateEmbeddings({\n                text: texts,\n                model: options?.model,\n                dimensions: options?.dimensions\n            });\n            return {\n                success: result.success,\n                embeddings: result.data?.embeddings,\n                model: result.data?.model,\n                usage: result.data?.usage,\n                error: result.error\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Generate embedding for a single text - convenience method\n     */\n    async generateEmbedding(text, model) {\n        this.ensureInitialized();\n        try {\n            const embeddingGenerator = this.serviceRegistry.get('embeddingGenerator');\n            const result = await embeddingGenerator.generateEmbedding(text, model);\n            return {\n                success: result.success,\n                embedding: result.data,\n                error: result.error\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Generate embeddings in batches - building block for large datasets\n     */\n    async generateBatchEmbeddings(texts, options) {\n        this.ensureInitialized();\n        try {\n            const embeddingGenerator = this.serviceRegistry.get('embeddingGenerator');\n            const result = await embeddingGenerator.generateBatchEmbeddings(texts, options?.model, options?.batchSize);\n            return {\n                success: result.success,\n                embeddings: result.data,\n                error: result.error\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Calculate similarity between two embeddings - utility building block\n     */\n    calculateEmbeddingSimilarity(embedding1, embedding2, method = 'cosine') {\n        this.ensureInitialized();\n        const embeddingGenerator = this.serviceRegistry.get('embeddingGenerator');\n        return embeddingGenerator.calculateSimilarity(embedding1, embedding2, method);\n    }\n    /**\n     * Get available embedding models\n     */\n    getEmbeddingModels() {\n        this.ensureInitialized();\n        const embeddingGenerator = this.serviceRegistry.get('embeddingGenerator');\n        return embeddingGenerator.getAvailableModels();\n    }\n    // === TEXT CHUNKING METHODS ===\n    /**\n     * Get the text chunker adapter\n     * @returns Text chunker adapter instance\n     */\n    getTextChunker() {\n        this.ensureInitialized();\n        return this.serviceRegistry.get('textChunker');\n    }\n    /**\n     * Chunk text into smaller pieces - convenience method\n     * @param text - Text to chunk\n     * @param chunkSize - Maximum size of each chunk\n     * @param overlap - Overlap between chunks\n     * @returns Chunking result\n     */\n    async chunkText(text, chunkSize, overlap) {\n        this.ensureInitialized();\n        try {\n            const textChunker = this.serviceRegistry.get('textChunker');\n            const result = await textChunker.chunkTextSimple(text, chunkSize, overlap);\n            return {\n                success: result.success,\n                chunks: result.data,\n                error: result.error\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    }\n    /**\n     * Get available chunking strategies\n     */\n    getChunkingStrategies() {\n        this.ensureInitialized();\n        const textChunker = this.serviceRegistry.get('textChunker');\n        return textChunker.getAvailableStrategies();\n    }\n    /**\n     * Estimate optimal chunk size for given text and target tokens\n     * @param text - Sample text to analyze\n     * @param targetTokens - Target tokens per chunk\n     * @returns Recommended chunk size in characters\n     */\n    estimateOptimalChunkSize(text, targetTokens) {\n        this.ensureInitialized();\n        const textChunker = this.serviceRegistry.get('textChunker');\n        return textChunker.estimateOptimalChunkSize(text, targetTokens);\n    }\n    /**\n     * Check if text chunker is healthy\n     * @returns Health status\n     */\n    async isTextChunkerHealthy() {\n        this.ensureInitialized();\n        try {\n            const textChunker = this.serviceRegistry.get('textChunker');\n            return await textChunker.isHealthy();\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Get embedding usage statistics\n     */\n    getEmbeddingUsageStats() {\n        this.ensureInitialized();\n        const embeddingGenerator = this.serviceRegistry.get('embeddingGenerator');\n        return embeddingGenerator.getUsageStats();\n    }\n    // === FILE STORAGE METHODS ===\n    /**\n     * Get the file storage adapter\n     * @returns File storage adapter instance\n     */\n    getFileStorage() {\n        this.ensureInitialized();\n        return this.serviceRegistry.get('fileStorage');\n    }\n    /**\n     * Upload a file to storage\n     * @param fileData - File content as Buffer\n     * @param filename - Original filename\n     * @param options - Upload options\n     * @returns Upload result with file metadata\n     */\n    async uploadFile(fileData, filename, options) {\n        this.ensureInitialized();\n        const fileStorage = this.serviceRegistry.get('fileStorage');\n        const result = await fileStorage.uploadFile(fileData, filename, options);\n        if (!result.success || !result.data) {\n            return {\n                success: false,\n                error: result.error || 'File upload failed'\n            };\n        }\n        return {\n            success: true,\n            file: {\n                filename: result.data.filename,\n                originalName: result.data.originalName,\n                size: result.data.size,\n                mimeType: result.data.mimeType,\n                path: result.data.path,\n                uploadedAt: result.data.uploadedAt,\n                tags: result.data.tags\n            }\n        };\n    }\n    /**\n     * Download a file from storage\n     * @param filePath - Path to the file\n     * @returns File data as Buffer\n     */\n    async downloadFile(filePath) {\n        this.ensureInitialized();\n        const fileStorage = this.serviceRegistry.get('fileStorage');\n        const result = await fileStorage.downloadFile(filePath);\n        if (!result.success || !result.data) {\n            return {\n                success: false,\n                error: result.error || 'File download failed'\n            };\n        }\n        return {\n            success: true,\n            data: result.data\n        };\n    }\n    /**\n     * List files in storage\n     * @param directory - Directory to list (optional)\n     * @param filter - Filter criteria (optional)\n     * @returns List of files\n     */\n    async listFiles(directory, filter) {\n        this.ensureInitialized();\n        const fileStorage = this.serviceRegistry.get('fileStorage');\n        const result = await fileStorage.listFiles(directory, filter);\n        if (!result.success || !result.data) {\n            return {\n                success: false,\n                error: result.error || 'Failed to list files'\n            };\n        }\n        return {\n            success: true,\n            files: result.data.map(file => ({\n                filename: file.filename,\n                size: file.size,\n                mimeType: file.mimeType,\n                path: file.path,\n                uploadedAt: file.uploadedAt\n            }))\n        };\n    }\n    /**\n     * Delete a file from storage\n     * @param filePath - Path to the file to delete\n     * @returns Deletion result\n     */\n    async deleteFile(filePath) {\n        this.ensureInitialized();\n        const fileStorage = this.serviceRegistry.get('fileStorage');\n        const result = await fileStorage.deleteFile(filePath);\n        return {\n            success: result.success,\n            error: result.error\n        };\n    }\n    /**\n     * Check if file storage is healthy\n     * @returns Health status\n     */\n    async isFileStorageHealthy() {\n        this.ensureInitialized();\n        try {\n            const fileStorage = this.serviceRegistry.get('fileStorage');\n            return await fileStorage.isHealthy();\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Get file storage statistics\n     * @returns Storage statistics\n     */\n    async getFileStorageStats() {\n        this.ensureInitialized();\n        const fileStorage = this.serviceRegistry.get('fileStorage');\n        const result = await fileStorage.getStorageStats();\n        if (!result.success || !result.data) {\n            return {\n                success: false,\n                error: result.error || 'Failed to get storage stats'\n            };\n        }\n        return {\n            success: true,\n            stats: {\n                totalFiles: result.data.totalFiles,\n                totalSize: result.data.totalSize,\n                usedSpace: result.data.usedSpace,\n                lastUpdated: result.data.lastUpdated\n            }\n        };\n    }\n    /**\n     * Dispose the framework and clean up resources\n     */\n    async dispose() {\n        if (!this.isInitialized) {\n            return;\n        }\n        this.healthCheck.stop();\n        // Disconnect database if connected\n        try {\n            const database = this.serviceRegistry.get('databaseAdapter');\n            await database.disconnect();\n            this.logger.info('Database disconnected successfully');\n        }\n        catch (error) {\n            this.logger.warn('Database disconnection failed', { error: error.message });\n        }\n        await this.serviceRegistry.dispose();\n        this.isInitialized = false;\n        this.logger.info('ApplicationFramework disposed');\n    }\n    ensureInitialized() {\n        if (!this.isInitialized) {\n            throw new Error('ApplicationFramework not initialized. Call initialize() first.');\n        }\n    }\n}\nexports.ApplicationFramework = ApplicationFramework;\n//# sourceMappingURL=ApplicationFramework.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL3Nkay9BcHBsaWNhdGlvbkZyYW1ld29yay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLDBCQUEwQixtQkFBTyxDQUFDLCtIQUEyQjtBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQywyR0FBaUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMscUhBQXNCO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLHlIQUF3QjtBQUN2RCx1QkFBdUIsbUJBQU8sQ0FBQyx1SEFBdUI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQW9CO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDJIQUFzQjtBQUNqRCxxQkFBcUIsbUJBQU8sQ0FBQywrSEFBd0I7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsdUhBQW9CO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDJIQUFzQjtBQUNqRCxxQkFBcUIsbUJBQU8sQ0FBQywrSEFBd0I7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMseUhBQXFCO0FBQy9DLHlCQUF5QixtQkFBTyxDQUFDLHVJQUE0QjtBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQywySEFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMENBQTBDO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNCQUFzQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEIsRUFBRSxtQkFBTyxDQUFDLHlLQUFnRDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyx1SEFBdUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsMkJBQTJCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay9zZGsvQXBwbGljYXRpb25GcmFtZXdvcmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBBcHBsaWNhdGlvbiBGcmFtZXdvcmsgLSBIaWdoLWxldmVsIGZhY2FkZSBmb3IgYXBwbGljYXRpb25zXG4vLyBQcm92aWRlcyBhIGNsZWFuIGludGVyZmFjZSB0byB0aGUgaGV4YWdvbmFsIGZyYW1ld29yayB3aXRob3V0IHRpZ2h0IGNvdXBsaW5nXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwcGxpY2F0aW9uRnJhbWV3b3JrID0gdm9pZCAwO1xuY29uc3QgU2VydmljZVJlZ2lzdHJ5XzEgPSByZXF1aXJlKFwiLi4vY29uZmlnL1NlcnZpY2VSZWdpc3RyeVwiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL3V0aWxzL0xvZ2dlclwiKTtcbmNvbnN0IEhlYWx0aENoZWNrXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvSGVhbHRoQ2hlY2tcIik7XG5jb25zdCBDb25maWdMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9jb25maWcvQ29uZmlnTG9hZGVyXCIpO1xuY29uc3QgRXJyb3JIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvRXJyb3JIYW5kbGVyXCIpO1xuY29uc3Qgb3BlbmFpXzEgPSByZXF1aXJlKFwiLi4vYWRhcHRlcnMvb3BlbmFpXCIpO1xuY29uc3Qgc2NyYXBpbmdfMSA9IHJlcXVpcmUoXCIuLi9hZGFwdGVycy9zY3JhcGluZ1wiKTtcbmNvbnN0IHNjcmVlbnNob3RfMSA9IHJlcXVpcmUoXCIuLi9hZGFwdGVycy9zY3JlZW5zaG90XCIpO1xuY29uc3QgdGF2aWx5XzEgPSByZXF1aXJlKFwiLi4vYWRhcHRlcnMvdGF2aWx5XCIpO1xuY29uc3QgZGF0YWJhc2VfMSA9IHJlcXVpcmUoXCIuLi9hZGFwdGVycy9kYXRhYmFzZVwiKTtcbmNvbnN0IGVtYmVkZGluZ3NfMSA9IHJlcXVpcmUoXCIuLi9hZGFwdGVycy9lbWJlZGRpbmdzXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4uL2FkYXB0ZXJzL3N0b3JhZ2VcIik7XG5jb25zdCB0ZXh0cHJvY2Vzc2luZ18xID0gcmVxdWlyZShcIi4uL2FkYXB0ZXJzL3RleHRwcm9jZXNzaW5nXCIpO1xuY29uc3QgY3Jhd2xpbmdfMSA9IHJlcXVpcmUoXCIuLi9hZGFwdGVycy9jcmF3bGluZ1wiKTtcbmNsYXNzIEFwcGxpY2F0aW9uRnJhbWV3b3JrIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBmcmFtZXdvcmsgd2l0aCBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvYWQgY29uZmlndXJhdGlvblxuICAgICAgICBsZXQgZnJhbWV3b3JrQ29uZmlnO1xuICAgICAgICBpZiAodGhpcy5jb25maWcpIHtcbiAgICAgICAgICAgIC8vIFVzZSBwcm92aWRlZCBjb25maWdcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ0xvYWRlciA9IENvbmZpZ0xvYWRlcl8xLkNvbmZpZ0xvYWRlckZhY3RvcnkuY3JlYXRlRW52aXJvbm1lbnRMb2FkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGVudkNvbmZpZyA9IGF3YWl0IGNvbmZpZ0xvYWRlci5sb2FkKCk7XG4gICAgICAgICAgICBmcmFtZXdvcmtDb25maWcgPSB7IC4uLmVudkNvbmZpZywgLi4udGhpcy5jb25maWcgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExvYWQgZnJvbSBlbnZpcm9ubWVudFxuICAgICAgICAgICAgY29uc3QgY29uZmlnTG9hZGVyID0gQ29uZmlnTG9hZGVyXzEuQ29uZmlnTG9hZGVyRmFjdG9yeS5jcmVhdGVFbnZpcm9ubWVudExvYWRlcigpO1xuICAgICAgICAgICAgZnJhbWV3b3JrQ29uZmlnID0gYXdhaXQgY29uZmlnTG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGxvZ2dlclxuICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ2dlcl8xLkxvZ2dlckZhY3RvcnkuZ2V0U2luZ2xldG9uKGZyYW1ld29ya0NvbmZpZy5sb2dMZXZlbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0FwcGxpY2F0aW9uRnJhbWV3b3JrIGluaXRpYWxpemluZycsIHsgZW52aXJvbm1lbnQ6IGZyYW1ld29ya0NvbmZpZy5lbnZpcm9ubWVudCB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGVycm9yIGhhbmRsZXJcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcl8xLkZyYW1ld29ya0Vycm9ySGFuZGxlcihmcmFtZXdvcmtDb25maWcucmV0cnkpO1xuICAgICAgICAvLyBDcmVhdGUgYWxsIHNlcnZpY2UgZmFjdG9yaWVzXG4gICAgICAgIGNvbnN0IHNlcnZpY2VGYWN0b3JpZXMgPSBbXG4gICAgICAgICAgICAuLi4oMCwgb3BlbmFpXzEuY3JlYXRlT3BlbkFJU2VydmljZUZhY3RvcmllcykoKSxcbiAgICAgICAgICAgICgwLCBzY3JhcGluZ18xLmNyZWF0ZVdlYlNjcmFwaW5nU2VydmljZUZhY3RvcnkpKCksXG4gICAgICAgICAgICAoMCwgc2NyZWVuc2hvdF8xLmNyZWF0ZVNjcmVlbnNob3RTZXJ2aWNlRmFjdG9yeSkoKSxcbiAgICAgICAgICAgICgwLCB0YXZpbHlfMS5jcmVhdGVUYXZpbHlTZXJ2aWNlRmFjdG9yeSkoKSxcbiAgICAgICAgICAgIG5ldyBkYXRhYmFzZV8xLlBvc3RncmVTUUxTZXJ2aWNlRmFjdG9yeSgpLFxuICAgICAgICAgICAgbmV3IGVtYmVkZGluZ3NfMS5FbWJlZGRpbmdTZXJ2aWNlRmFjdG9yeSgpLFxuICAgICAgICAgICAgbmV3IHN0b3JhZ2VfMS5GaWxlU3RvcmFnZVNlcnZpY2VGYWN0b3J5KCksXG4gICAgICAgICAgICBuZXcgdGV4dHByb2Nlc3NpbmdfMS5UZXh0Q2h1bmtlclNlcnZpY2VGYWN0b3J5KClcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlUmVnaXN0cnkgPSBTZXJ2aWNlUmVnaXN0cnlfMS5TZXJ2aWNlUmVnaXN0cnlGYWN0b3J5LmNyZWF0ZVdpdGhEZWZhdWx0cyhmcmFtZXdvcmtDb25maWcsIHRoaXMubG9nZ2VyLCBlcnJvckhhbmRsZXIsIHNlcnZpY2VGYWN0b3JpZXMpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlcnZpY2VSZWdpc3RyeS5pbml0aWFsaXplKCk7XG4gICAgICAgIC8vIENvbm5lY3QgZGF0YWJhc2UgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnZGF0YWJhc2VBZGFwdGVyJyk7XG4gICAgICAgICAgICBhd2FpdCBkYXRhYmFzZS5jb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdEYXRhYmFzZSBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCBvciBub3QgY29uZmlndXJlZCcsIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dXAgaGVhbHRoIG1vbml0b3JpbmdcbiAgICAgICAgdGhpcy5oZWFsdGhDaGVjayA9IEhlYWx0aENoZWNrXzEuSGVhbHRoQ2hlY2tGYWN0b3J5LmNyZWF0ZURlZmF1bHQodGhpcy5sb2dnZXIpO1xuICAgICAgICBjb25zdCBoZWFsdGhDaGVja2FibGVTZXJ2aWNlcyA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldEhlYWx0aENoZWNrYWJsZVNlcnZpY2VzKCk7XG4gICAgICAgIGhlYWx0aENoZWNrYWJsZVNlcnZpY2VzLmZvckVhY2goKHNlcnZpY2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2sucmVnaXN0ZXJTZXJ2aWNlKHNlcnZpY2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5oZWFsdGhDaGVjay5zdGFydCgpO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdBcHBsaWNhdGlvbkZyYW1ld29yayBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGV4dCB1c2luZyB0aGUgZnJhbWV3b3JrJ3MgdGV4dCBnZW5lcmF0aW9uIHNlcnZpY2VcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVRleHQocHJvbXB0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgdGV4dEdlbmVyYXRvciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgndGV4dEdlbmVyYXRvcicpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgbW9kZWw6IG9wdGlvbnM/Lm1vZGVsLFxuICAgICAgICAgICAgbWF4VG9rZW5zOiBvcHRpb25zPy5tYXhUb2tlbnMsXG4gICAgICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucz8udGVtcGVyYXR1cmUsXG4gICAgICAgICAgICBjb252ZXJzYXRpb25IaXN0b3J5OiBvcHRpb25zPy5jb252ZXJzYXRpb25IaXN0b3J5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGV4dEdlbmVyYXRvci5nZW5lcmF0ZVRleHQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2VzcyB8fCAhcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdUZXh0IGdlbmVyYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEudGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGV4dCB3aXRoIHN0cmVhbWluZyByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlVGV4dFN0cmVhbShwcm9tcHQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB0ZXh0R2VuZXJhdG9yID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCd0ZXh0R2VuZXJhdG9yJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICAgIG1heFRva2Vuczogb3B0aW9ucy5tYXhUb2tlbnMsXG4gICAgICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbkhpc3Rvcnk6IG9wdGlvbnMuY29udmVyc2F0aW9uSGlzdG9yeVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gdGV4dEdlbmVyYXRvci5nZW5lcmF0ZVRleHRTdHJlYW0ocmVxdWVzdCk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25DaHVuayhjaHVuay50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZW5oYW5jZWQgdGV4dCBnZW5lcmF0b3Igd2l0aCByZXNwb25zZXMgQVBJIHN1cHBvcnRcbiAgICAgKi9cbiAgICBnZXRFbmhhbmNlZFRleHRHZW5lcmF0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgLy8gQ3JlYXRlIGVuaGFuY2VkIHRleHQgZ2VuZXJhdG9yIG9uIGRlbWFuZCBzaW5jZSBpdCdzIG5vdCBpbiB0aGUgc3RhbmRhcmQgcmVnaXN0cnlcbiAgICAgICAgY29uc3QgeyBFbmhhbmNlZE9wZW5BSVRleHRHZW5lcmF0b3IgfSA9IHJlcXVpcmUoJy4uL2FkYXB0ZXJzL29wZW5haS9FbmhhbmNlZE9wZW5BSVRleHRHZW5lcmF0b3InKTtcbiAgICAgICAgLy8gTG9hZCBPcGVuQUkgY29uZmlndXJhdGlvbiBkaXJlY3RseSBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAgICBjb25zdCBvcGVuYWlDb25maWcgPSB7XG4gICAgICAgICAgICBhcGlLZXk6IHByb2Nlc3MuZW52Lk9QRU5BSV9BUElfS0VZLFxuICAgICAgICAgICAgYmFzZVVybDogcHJvY2Vzcy5lbnYuT1BFTkFJX0JBU0VfVVJMLFxuICAgICAgICAgICAgdGltZW91dDogcHJvY2Vzcy5lbnYuT1BFTkFJX1RJTUVPVVQgPyBwYXJzZUludChwcm9jZXNzLmVudi5PUEVOQUlfVElNRU9VVCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtb2RlbDogcHJvY2Vzcy5lbnYuT1BFTkFJX01PREVMLFxuICAgICAgICAgICAgb3JnYW5pemF0aW9uOiBwcm9jZXNzLmVudi5PUEVOQUlfT1JHQU5JWkFUSU9OXG4gICAgICAgIH07XG4gICAgICAgIC8vIENyZWF0ZSBlcnJvciBoYW5kbGVyIHdpdGggZGVmYXVsdCByZXRyeSBjb25maWd1cmF0aW9uXG4gICAgICAgIGNvbnN0IHsgRnJhbWV3b3JrRXJyb3JIYW5kbGVyIH0gPSByZXF1aXJlKCcuLi91dGlscy9FcnJvckhhbmRsZXInKTtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEZyYW1ld29ya0Vycm9ySGFuZGxlcih7XG4gICAgICAgICAgICBtYXhBdHRlbXB0czogMyxcbiAgICAgICAgICAgIGJhY2tvZmZNdWx0aXBsaWVyOiAyLFxuICAgICAgICAgICAgbWF4QmFja29mZk1zOiAzMDAwMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5oYW5jZWRHZW5lcmF0b3IgPSBuZXcgRW5oYW5jZWRPcGVuQUlUZXh0R2VuZXJhdG9yKG9wZW5haUNvbmZpZywgdGhpcy5sb2dnZXIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIHJldHVybiBlbmhhbmNlZEdlbmVyYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgaW1hZ2VzIHVzaW5nIHRoZSBmcmFtZXdvcmsncyBpbWFnZSBnZW5lcmF0aW9uIHNlcnZpY2VcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUltYWdlKHByb21wdCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IGltYWdlR2VuZXJhdG9yID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdpbWFnZUdlbmVyYXRvcicpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgc2l6ZTogb3B0aW9ucz8uc2l6ZSxcbiAgICAgICAgICAgIHF1YWxpdHk6IG9wdGlvbnM/LnF1YWxpdHksXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucz8uc3R5bGUsXG4gICAgICAgICAgICBuOiBvcHRpb25zPy5uXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW1hZ2VHZW5lcmF0b3IuZ2VuZXJhdGVJbWFnZShyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzIHx8ICFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IgfHwgJ0ltYWdlIGdlbmVyYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuaW1hZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggdGhlIHdlYiB1c2luZyB0aGUgZnJhbWV3b3JrJ3Mgd2ViIHNlYXJjaCBzZXJ2aWNlXG4gICAgICovXG4gICAgYXN5bmMgc2VhcmNoV2ViKHF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3Qgd2ViU2VhcmNoZXIgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ3dlYlNlYXJjaGVyJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIG1heFJlc3VsdHM6IG9wdGlvbnM/Lm1heFJlc3VsdHMsXG4gICAgICAgICAgICBzZWFyY2hEZXB0aDogb3B0aW9ucz8uc2VhcmNoRGVwdGgsXG4gICAgICAgICAgICBpbmNsdWRlRG9tYWluczogb3B0aW9ucz8uaW5jbHVkZURvbWFpbnMsXG4gICAgICAgICAgICBleGNsdWRlRG9tYWluczogb3B0aW9ucz8uZXhjbHVkZURvbWFpbnNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3ZWJTZWFyY2hlci5zZWFyY2gocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2VzcyB8fCAhcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdXZWIgc2VhcmNoIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHRzOiByZXNwb25zZS5kYXRhLnJlc3VsdHMsXG4gICAgICAgICAgICBxdWVyeTogcmVzcG9uc2UuZGF0YS5xdWVyeSxcbiAgICAgICAgICAgIGFuc3dlcjogcmVzcG9uc2UuZGF0YS5hbnN3ZXIsXG4gICAgICAgICAgICB0b3RhbFJlc3VsdHM6IHJlc3BvbnNlLmRhdGEudG90YWxSZXN1bHRzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcmFwZSBhIHdlYiBwYWdlIHVzaW5nIHRoZSBmcmFtZXdvcmsncyB3ZWIgc2NyYXBpbmcgc2VydmljZVxuICAgICAqL1xuICAgIGFzeW5jIHNjcmFwZVdlYlBhZ2UodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3Qgd2ViU2NyYXBlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnd2ViU2NyYXBlcicpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgc2VsZWN0b3I6IG9wdGlvbnM/LnNlbGVjdG9yLFxuICAgICAgICAgICAgd2FpdEZvcjogb3B0aW9ucz8ud2FpdEZvcixcbiAgICAgICAgICAgIGluY2x1ZGVJbWFnZXM6IG9wdGlvbnM/LmluY2x1ZGVJbWFnZXMsXG4gICAgICAgICAgICBmb2xsb3dMaW5rczogb3B0aW9ucz8uZm9sbG93TGlua3MsXG4gICAgICAgICAgICBtYXhEZXB0aDogb3B0aW9ucz8ubWF4RGVwdGhcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB3ZWJTY3JhcGVyLnNjcmFwZVBhZ2UocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2VzcyB8fCAhcmVzcG9uc2UuZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdXZWIgc2NyYXBpbmcgZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogcmVzcG9uc2UuZGF0YS51cmwsXG4gICAgICAgICAgICB0aXRsZTogcmVzcG9uc2UuZGF0YS50aXRsZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3BvbnNlLmRhdGEuY29udGVudCxcbiAgICAgICAgICAgIGltYWdlczogcmVzcG9uc2UuZGF0YS5pbWFnZXMsXG4gICAgICAgICAgICBsaW5rczogcmVzcG9uc2UuZGF0YS5saW5rcyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiByZXNwb25zZS5kYXRhLm1ldGFkYXRhLFxuICAgICAgICAgICAgc2NyYXBlZEF0OiByZXNwb25zZS5kYXRhLnNjcmFwZWRBdFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlIGEgc2NyZWVuc2hvdCB1c2luZyB0aGUgZnJhbWV3b3JrJ3Mgc2NyZWVuc2hvdCBzZXJ2aWNlXG4gICAgICovXG4gICAgYXN5bmMgY2FwdHVyZVNjcmVlbnNob3QodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3Qgc2NyZWVuc2hvdENhcHR1cmUgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ3NjcmVlbnNob3RDYXB0dXJlJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBmdWxsUGFnZTogb3B0aW9ucz8uZnVsbFBhZ2UsXG4gICAgICAgICAgICB3aWR0aDogb3B0aW9ucz8ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnM/LmhlaWdodCxcbiAgICAgICAgICAgIGZvcm1hdDogb3B0aW9ucz8uZm9ybWF0LFxuICAgICAgICAgICAgcXVhbGl0eTogb3B0aW9ucz8ucXVhbGl0eSxcbiAgICAgICAgICAgIHdhaXRGb3I6IG9wdGlvbnM/LndhaXRGb3JcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzY3JlZW5zaG90Q2FwdHVyZS5jYXB0dXJlU2NyZWVuc2hvdChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzIHx8ICFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IgfHwgJ1NjcmVlbnNob3QgY2FwdHVyZSBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW1hZ2VCdWZmZXI6IHJlc3BvbnNlLmRhdGEuaW1hZ2UuYnVmZmVyIHx8IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiByZXNwb25zZS5kYXRhLmltYWdlLm1pbWVUeXBlLFxuICAgICAgICAgICAgdXJsOiByZXNwb25zZS5kYXRhLnVybCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHJlc3BvbnNlLmRhdGEuZGltZW5zaW9uc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgaGVhbHRoIHN0YXR1cyBvZiBhbGwgc2VydmljZXNcbiAgICAgKi9cbiAgICBhc3luYyBnZXRIZWFsdGhTdGF0dXMoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgaGVhbHRoUmVwb3J0ID0gYXdhaXQgdGhpcy5oZWFsdGhDaGVjay5jaGVja0hlYWx0aCgpO1xuICAgICAgICByZXR1cm4gaGVhbHRoUmVwb3J0LnNlcnZpY2VzLm1hcChzZXJ2aWNlID0+ICh7XG4gICAgICAgICAgICBzZXJ2aWNlOiBzZXJ2aWNlLnNlcnZpY2UsXG4gICAgICAgICAgICBzdGF0dXM6IHNlcnZpY2Uuc3RhdHVzLFxuICAgICAgICAgICAgbGFzdENoZWNrZWQ6IHNlcnZpY2UudGltZXN0YW1wLFxuICAgICAgICAgICAgZXJyb3I6IHNlcnZpY2UuZGV0YWlscz8uZXJyb3JcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZnJhbWV3b3JrIGlzIGhlYWx0aHlcbiAgICAgKi9cbiAgICBhc3luYyBpc0hlYWx0aHkoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhbHRoQ2hlY2suaXNTeXN0ZW1IZWFsdGh5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2NvdmVyIGNyYXdsYWJsZSBwYWdlcyBmcm9tIGEgd2Vic2l0ZSAoZm9yIHByZXZpZXcvYW5hbHlzaXMpXG4gICAgICovXG4gICAgYXN5bmMgZGlzY292ZXJDcmF3bGFibGVQYWdlcyh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgd2ViU2NyYXBlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnd2ViU2NyYXBlcicpO1xuICAgICAgICAgICAgY29uc3QgY3Jhd2xlciA9IG5ldyBjcmF3bGluZ18xLldlYkNyYXdsZXIod2ViU2NyYXBlcik7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgY3Jhd2xSZXN1bHRzID0gYXdhaXQgY3Jhd2xlci5jcmF3bFdlYnNpdGUodXJsLCB7XG4gICAgICAgICAgICAgICAgbWF4UGFnZXM6IG9wdGlvbnM/Lm1heFBhZ2VzIHx8IDEwLFxuICAgICAgICAgICAgICAgIG1heERlcHRoOiBvcHRpb25zPy5tYXhEZXB0aCB8fCAyLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVQYXR0ZXJuczogb3B0aW9ucz8uaW5jbHVkZVBhdHRlcm5zIHx8IFtdLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVQYXR0ZXJuczogb3B0aW9ucz8uZXhjbHVkZVBhdHRlcm5zIHx8IFtdLFxuICAgICAgICAgICAgICAgIGZvbGxvd0V4dGVybmFsTGlua3M6IG9wdGlvbnM/LmZvbGxvd0V4dGVybmFsTGlua3MgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVsYXk6IG9wdGlvbnM/LmRlbGF5IHx8IDEwMDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY3Jhd2xEdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHJlc3VsdHMgZm9yIHN1bW1hcnlcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzQnlEZXB0aCA9IHt9O1xuICAgICAgICAgICAgbGV0IHRvdGFsTGlua3MgPSAwO1xuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSBjcmF3bFJlc3VsdHMubWFwKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgcGFnZXNCeURlcHRoW3Jlc3VsdC5kZXB0aF0gPSAocGFnZXNCeURlcHRoW3Jlc3VsdC5kZXB0aF0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIHRvdGFsTGlua3MgKz0gcmVzdWx0LmxpbmtzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHJlc3VsdC51cmwsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiByZXN1bHQudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiByZXN1bHQuZGVwdGgsXG4gICAgICAgICAgICAgICAgICAgIGxpbmtDb3VudDogcmVzdWx0LmxpbmtzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgd29yZENvdW50OiByZXN1bHQubWV0YWRhdGEud29yZENvdW50LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHJlc3VsdC50aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBtYXhEZXB0aFJlYWNoZWQgPSBNYXRoLm1heCguLi5wYWdlcy5tYXAocCA9PiBwLmRlcHRoKSwgMCk7XG4gICAgICAgICAgICBjb25zdCBhdmVyYWdlTGlua3NQZXJQYWdlID0gcGFnZXMubGVuZ3RoID4gMCA/IHRvdGFsTGlua3MgLyBwYWdlcy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRVcmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxQYWdlc0Rpc2NvdmVyZWQ6IHBhZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGhSZWFjaGVkLFxuICAgICAgICAgICAgICAgICAgICBjcmF3bER1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZXNCeURlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxMaW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VMaW5rc1BlclBhZ2U6IE1hdGgucm91bmQoYXZlcmFnZUxpbmtzUGVyUGFnZSAqIDEwKSAvIDEwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0NyYXdsaW5nIGRpc2NvdmVyeSBmYWlsZWQnLCB7IHVybCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkYXRhYmFzZSBhZGFwdGVyIGZvciBkaXJlY3QgZGF0YWJhc2Ugb3BlcmF0aW9uc1xuICAgICAqIE5vdGU6IFRoaXMgaXMgYSBidWlsZGluZyBibG9jayAtIGFwcGxpY2F0aW9ucyBzaG91bGQgYnVpbGQgdGhlaXIgb3duIGRhdGFiYXNlIGxvZ2ljIG9uIHRvcFxuICAgICAqL1xuICAgIGdldERhdGFiYXNlQWRhcHRlcigpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdkYXRhYmFzZUFkYXB0ZXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIGRhdGFiYXNlIHF1ZXJ5IChidWlsZGluZyBibG9jayBmb3IgYXBwbGljYXRpb25zKVxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGVRdWVyeShzcWwsIHBhcmFtcykge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnZGF0YWJhc2VBZGFwdGVyJyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkYXRhYmFzZS5xdWVyeShzcWwsIHBhcmFtcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIHJvd3M6IHJlc3VsdC5kYXRhPy5yb3dzLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50OiByZXN1bHQuZGF0YT8ucm93Q291bnQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZGF0YWJhc2UgaXMgY29ubmVjdGVkIGFuZCBoZWFsdGh5XG4gICAgICovXG4gICAgYXN5bmMgaXNEYXRhYmFzZUhlYWx0aHkoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFiYXNlID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdkYXRhYmFzZUFkYXB0ZXInKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBkYXRhYmFzZS5pc0hlYWx0aHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdEYXRhYmFzZSBoZWFsdGggY2hlY2sgZmFpbGVkJywgeyBlcnJvcjogZXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YWJhc2UgY29ubmVjdGlvbiBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGdldERhdGFiYXNlSW5mbygpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnZGF0YWJhc2VBZGFwdGVyJyk7XG4gICAgICAgIHJldHVybiBkYXRhYmFzZS5nZXRDb25uZWN0aW9uSW5mbygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBlbWJlZGRpbmdzIGZvciB0ZXh0KHMpIC0gYnVpbGRpbmcgYmxvY2sgZm9yIHZlY3RvciBvcGVyYXRpb25zXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVFbWJlZGRpbmdzKHRleHRzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ0dlbmVyYXRvciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnZW1iZWRkaW5nR2VuZXJhdG9yJyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbWJlZGRpbmdHZW5lcmF0b3IuZ2VuZXJhdGVFbWJlZGRpbmdzKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0cyxcbiAgICAgICAgICAgICAgICBtb2RlbDogb3B0aW9ucz8ubW9kZWwsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogb3B0aW9ucz8uZGltZW5zaW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGVtYmVkZGluZ3M6IHJlc3VsdC5kYXRhPy5lbWJlZGRpbmdzLFxuICAgICAgICAgICAgICAgIG1vZGVsOiByZXN1bHQuZGF0YT8ubW9kZWwsXG4gICAgICAgICAgICAgICAgdXNhZ2U6IHJlc3VsdC5kYXRhPy51c2FnZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBlbWJlZGRpbmcgZm9yIGEgc2luZ2xlIHRleHQgLSBjb252ZW5pZW5jZSBtZXRob2RcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUVtYmVkZGluZyh0ZXh0LCBtb2RlbCkge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdHZW5lcmF0b3IgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ2VtYmVkZGluZ0dlbmVyYXRvcicpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW1iZWRkaW5nR2VuZXJhdG9yLmdlbmVyYXRlRW1iZWRkaW5nKHRleHQsIG1vZGVsKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBlbWJlZGRpbmdzIGluIGJhdGNoZXMgLSBidWlsZGluZyBibG9jayBmb3IgbGFyZ2UgZGF0YXNldHNcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUJhdGNoRW1iZWRkaW5ncyh0ZXh0cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdHZW5lcmF0b3IgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ2VtYmVkZGluZ0dlbmVyYXRvcicpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW1iZWRkaW5nR2VuZXJhdG9yLmdlbmVyYXRlQmF0Y2hFbWJlZGRpbmdzKHRleHRzLCBvcHRpb25zPy5tb2RlbCwgb3B0aW9ucz8uYmF0Y2hTaXplKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nczogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gZW1iZWRkaW5ncyAtIHV0aWxpdHkgYnVpbGRpbmcgYmxvY2tcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVFbWJlZGRpbmdTaW1pbGFyaXR5KGVtYmVkZGluZzEsIGVtYmVkZGluZzIsIG1ldGhvZCA9ICdjb3NpbmUnKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nR2VuZXJhdG9yID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdlbWJlZGRpbmdHZW5lcmF0b3InKTtcbiAgICAgICAgcmV0dXJuIGVtYmVkZGluZ0dlbmVyYXRvci5jYWxjdWxhdGVTaW1pbGFyaXR5KGVtYmVkZGluZzEsIGVtYmVkZGluZzIsIG1ldGhvZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhdmFpbGFibGUgZW1iZWRkaW5nIG1vZGVsc1xuICAgICAqL1xuICAgIGdldEVtYmVkZGluZ01vZGVscygpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCBlbWJlZGRpbmdHZW5lcmF0b3IgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ2VtYmVkZGluZ0dlbmVyYXRvcicpO1xuICAgICAgICByZXR1cm4gZW1iZWRkaW5nR2VuZXJhdG9yLmdldEF2YWlsYWJsZU1vZGVscygpO1xuICAgIH1cbiAgICAvLyA9PT0gVEVYVCBDSFVOS0lORyBNRVRIT0RTID09PVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGV4dCBjaHVua2VyIGFkYXB0ZXJcbiAgICAgKiBAcmV0dXJucyBUZXh0IGNodW5rZXIgYWRhcHRlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldFRleHRDaHVua2VyKCkge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ3RleHRDaHVua2VyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENodW5rIHRleHQgaW50byBzbWFsbGVyIHBpZWNlcyAtIGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAqIEBwYXJhbSB0ZXh0IC0gVGV4dCB0byBjaHVua1xuICAgICAqIEBwYXJhbSBjaHVua1NpemUgLSBNYXhpbXVtIHNpemUgb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbSBvdmVybGFwIC0gT3ZlcmxhcCBiZXR3ZWVuIGNodW5rc1xuICAgICAqIEByZXR1cm5zIENodW5raW5nIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGNodW5rVGV4dCh0ZXh0LCBjaHVua1NpemUsIG92ZXJsYXApIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGV4dENodW5rZXIgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ3RleHRDaHVua2VyJyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXh0Q2h1bmtlci5jaHVua1RleHRTaW1wbGUodGV4dCwgY2h1bmtTaXplLCBvdmVybGFwKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzdWx0LnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXZhaWxhYmxlIGNodW5raW5nIHN0cmF0ZWdpZXNcbiAgICAgKi9cbiAgICBnZXRDaHVua2luZ1N0cmF0ZWdpZXMoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgdGV4dENodW5rZXIgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ3RleHRDaHVua2VyJyk7XG4gICAgICAgIHJldHVybiB0ZXh0Q2h1bmtlci5nZXRBdmFpbGFibGVTdHJhdGVnaWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlIG9wdGltYWwgY2h1bmsgc2l6ZSBmb3IgZ2l2ZW4gdGV4dCBhbmQgdGFyZ2V0IHRva2Vuc1xuICAgICAqIEBwYXJhbSB0ZXh0IC0gU2FtcGxlIHRleHQgdG8gYW5hbHl6ZVxuICAgICAqIEBwYXJhbSB0YXJnZXRUb2tlbnMgLSBUYXJnZXQgdG9rZW5zIHBlciBjaHVua1xuICAgICAqIEByZXR1cm5zIFJlY29tbWVuZGVkIGNodW5rIHNpemUgaW4gY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIGVzdGltYXRlT3B0aW1hbENodW5rU2l6ZSh0ZXh0LCB0YXJnZXRUb2tlbnMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCB0ZXh0Q2h1bmtlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgndGV4dENodW5rZXInKTtcbiAgICAgICAgcmV0dXJuIHRleHRDaHVua2VyLmVzdGltYXRlT3B0aW1hbENodW5rU2l6ZSh0ZXh0LCB0YXJnZXRUb2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0ZXh0IGNodW5rZXIgaXMgaGVhbHRoeVxuICAgICAqIEByZXR1cm5zIEhlYWx0aCBzdGF0dXNcbiAgICAgKi9cbiAgICBhc3luYyBpc1RleHRDaHVua2VySGVhbHRoeSgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGV4dENodW5rZXIgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ3RleHRDaHVua2VyJyk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGV4dENodW5rZXIuaXNIZWFsdGh5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBlbWJlZGRpbmcgdXNhZ2Ugc3RhdGlzdGljc1xuICAgICAqL1xuICAgIGdldEVtYmVkZGluZ1VzYWdlU3RhdHMoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nR2VuZXJhdG9yID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdlbWJlZGRpbmdHZW5lcmF0b3InKTtcbiAgICAgICAgcmV0dXJuIGVtYmVkZGluZ0dlbmVyYXRvci5nZXRVc2FnZVN0YXRzKCk7XG4gICAgfVxuICAgIC8vID09PSBGSUxFIFNUT1JBR0UgTUVUSE9EUyA9PT1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGZpbGUgc3RvcmFnZSBhZGFwdGVyXG4gICAgICogQHJldHVybnMgRmlsZSBzdG9yYWdlIGFkYXB0ZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRGaWxlU3RvcmFnZSgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdmaWxlU3RvcmFnZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHRvIHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gZmlsZURhdGEgLSBGaWxlIGNvbnRlbnQgYXMgQnVmZmVyXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIC0gT3JpZ2luYWwgZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFVwbG9hZCBvcHRpb25zXG4gICAgICogQHJldHVybnMgVXBsb2FkIHJlc3VsdCB3aXRoIGZpbGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGaWxlKGZpbGVEYXRhLCBmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IGZpbGVTdG9yYWdlID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdmaWxlU3RvcmFnZScpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaWxlU3RvcmFnZS51cGxvYWRGaWxlKGZpbGVEYXRhLCBmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgfHwgIXJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3IgfHwgJ0ZpbGUgdXBsb2FkIGZhaWxlZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHJlc3VsdC5kYXRhLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTmFtZTogcmVzdWx0LmRhdGEub3JpZ2luYWxOYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IHJlc3VsdC5kYXRhLnNpemUsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IHJlc3VsdC5kYXRhLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgIHBhdGg6IHJlc3VsdC5kYXRhLnBhdGgsXG4gICAgICAgICAgICAgICAgdXBsb2FkZWRBdDogcmVzdWx0LmRhdGEudXBsb2FkZWRBdCxcbiAgICAgICAgICAgICAgICB0YWdzOiByZXN1bHQuZGF0YS50YWdzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGEgZmlsZSBmcm9tIHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBQYXRoIHRvIHRoZSBmaWxlXG4gICAgICogQHJldHVybnMgRmlsZSBkYXRhIGFzIEJ1ZmZlclxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkRmlsZShmaWxlUGF0aCkge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IGZpbGVTdG9yYWdlID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdmaWxlU3RvcmFnZScpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaWxlU3RvcmFnZS5kb3dubG9hZEZpbGUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzIHx8ICFyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yIHx8ICdGaWxlIGRvd25sb2FkIGZhaWxlZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGZpbGVzIGluIHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gZGlyZWN0b3J5IC0gRGlyZWN0b3J5IHRvIGxpc3QgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBGaWx0ZXIgY3JpdGVyaWEgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm5zIExpc3Qgb2YgZmlsZXNcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0RmlsZXMoZGlyZWN0b3J5LCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICBjb25zdCBmaWxlU3RvcmFnZSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnZmlsZVN0b3JhZ2UnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmlsZVN0b3JhZ2UubGlzdEZpbGVzKGRpcmVjdG9yeSwgZmlsdGVyKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcyB8fCAhcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGxpc3QgZmlsZXMnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgZmlsZXM6IHJlc3VsdC5kYXRhLm1hcChmaWxlID0+ICh7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGUuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICB1cGxvYWRlZEF0OiBmaWxlLnVwbG9hZGVkQXRcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlIGZyb20gc3RvcmFnZVxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFBhdGggdG8gdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybnMgRGVsZXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlRmlsZShmaWxlUGF0aCkge1xuICAgICAgICB0aGlzLmVuc3VyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIGNvbnN0IGZpbGVTdG9yYWdlID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0KCdmaWxlU3RvcmFnZScpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaWxlU3RvcmFnZS5kZWxldGVGaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3VsdC5zdWNjZXNzLFxuICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5lcnJvclxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBmaWxlIHN0b3JhZ2UgaXMgaGVhbHRoeVxuICAgICAqIEByZXR1cm5zIEhlYWx0aCBzdGF0dXNcbiAgICAgKi9cbiAgICBhc3luYyBpc0ZpbGVTdG9yYWdlSGVhbHRoeSgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJbml0aWFsaXplZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmlsZVN0b3JhZ2UgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ2ZpbGVTdG9yYWdlJyk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZmlsZVN0b3JhZ2UuaXNIZWFsdGh5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIHN0b3JhZ2Ugc3RhdGlzdGljc1xuICAgICAqIEByZXR1cm5zIFN0b3JhZ2Ugc3RhdGlzdGljc1xuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVTdG9yYWdlU3RhdHMoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgY29uc3QgZmlsZVN0b3JhZ2UgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXQoJ2ZpbGVTdG9yYWdlJyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbGVTdG9yYWdlLmdldFN0b3JhZ2VTdGF0cygpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzIHx8ICFyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gZ2V0IHN0b3JhZ2Ugc3RhdHMnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgICAgICB0b3RhbEZpbGVzOiByZXN1bHQuZGF0YS50b3RhbEZpbGVzLFxuICAgICAgICAgICAgICAgIHRvdGFsU2l6ZTogcmVzdWx0LmRhdGEudG90YWxTaXplLFxuICAgICAgICAgICAgICAgIHVzZWRTcGFjZTogcmVzdWx0LmRhdGEudXNlZFNwYWNlLFxuICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiByZXN1bHQuZGF0YS5sYXN0VXBkYXRlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSBmcmFtZXdvcmsgYW5kIGNsZWFuIHVwIHJlc291cmNlc1xuICAgICAqL1xuICAgIGFzeW5jIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFsdGhDaGVjay5zdG9wKCk7XG4gICAgICAgIC8vIERpc2Nvbm5lY3QgZGF0YWJhc2UgaWYgY29ubmVjdGVkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldCgnZGF0YWJhc2VBZGFwdGVyJyk7XG4gICAgICAgICAgICBhd2FpdCBkYXRhYmFzZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdEYXRhYmFzZSBkaXNjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdEYXRhYmFzZSBkaXNjb25uZWN0aW9uIGZhaWxlZCcsIHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQXBwbGljYXRpb25GcmFtZXdvcmsgZGlzcG9zZWQnKTtcbiAgICB9XG4gICAgZW5zdXJlSW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FwcGxpY2F0aW9uRnJhbWV3b3JrIG5vdCBpbml0aWFsaXplZC4gQ2FsbCBpbml0aWFsaXplKCkgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFwcGxpY2F0aW9uRnJhbWV3b3JrID0gQXBwbGljYXRpb25GcmFtZXdvcms7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHBsaWNhdGlvbkZyYW1ld29yay5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/sdk/ApplicationFramework.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Centralized Error Handler for the Hexagonal Framework\n// Provides consistent error handling, logging, and retry logic\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrameworkErrorHandler = void 0;\nconst ErrorTypes_1 = __webpack_require__(/*! ../core/types/ErrorTypes */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/core/types/ErrorTypes.js\");\nclass FrameworkErrorHandler {\n    constructor(retryConfig) {\n        this.retryConfig = retryConfig;\n    }\n    /**\n     * Convert any error to a standardized FrameworkError\n     * @param error - Original error\n     * @param service - Service name where error occurred\n     * @param operation - Operation that failed\n     * @returns Standardized FrameworkError\n     */\n    handle(error, service, operation) {\n        // If it's already a FrameworkError, return its JSON representation\n        if (error instanceof ErrorTypes_1.BaseFrameworkError) {\n            return error.toJSON();\n        }\n        // Try to categorize the error based on common patterns\n        const errorCode = this.categorizeError(error);\n        const frameworkError = new ErrorTypes_1.BaseFrameworkError(errorCode, error.message, {\n            service,\n            operation,\n            retryable: this.isRetryable(error),\n            cause: error\n        });\n        return frameworkError.toJSON();\n    }\n    /**\n     * Check if an error is retryable\n     * @param error - Error to check\n     * @returns Whether the error is retryable\n     */\n    isRetryable(error) {\n        if (error instanceof ErrorTypes_1.BaseFrameworkError) {\n            return error.retryable;\n        }\n        const errorCode = this.categorizeError(error);\n        return this.retryConfig.retryableErrors.includes(errorCode);\n    }\n    /**\n     * Determine if a retry should be attempted based on attempt count\n     * @param error - Error that occurred\n     * @param attempt - Current attempt number (1-based)\n     * @returns Whether to retry\n     */\n    shouldRetry(error, attempt) {\n        if (attempt >= this.retryConfig.maxAttempts) {\n            return false;\n        }\n        return this.isRetryable(error);\n    }\n    /**\n     * Calculate backoff delay for retry attempts\n     * @param attempt - Current attempt number (1-based)\n     * @returns Delay in milliseconds\n     */\n    calculateBackoff(attempt) {\n        const baseDelay = 1000; // 1 second\n        const delay = baseDelay * Math.pow(this.retryConfig.backoffMultiplier, attempt - 1);\n        return Math.min(delay, this.retryConfig.maxBackoffMs);\n    }\n    /**\n     * Execute a function with retry logic\n     * @param fn - Function to execute\n     * @param context - Context information for error handling\n     * @returns Promise with result or throws final error\n     */\n    async executeWithRetry(fn, context = {}) {\n        let lastError = null;\n        for (let attempt = 1; attempt <= this.retryConfig.maxAttempts; attempt++) {\n            try {\n                return await fn();\n            }\n            catch (error) {\n                lastError = error;\n                if (!this.shouldRetry(lastError, attempt)) {\n                    break;\n                }\n                if (attempt < this.retryConfig.maxAttempts) {\n                    const delay = this.calculateBackoff(attempt);\n                    await this.sleep(delay);\n                }\n            }\n        }\n        // All retries exhausted, throw the final error\n        throw this.createFrameworkError(lastError, context.service, context.operation);\n    }\n    /**\n     * Create a specific FrameworkError based on error type\n     * @param error - Original error\n     * @param service - Service name\n     * @param operation - Operation name\n     * @returns Specific FrameworkError instance\n     */\n    createFrameworkError(error, service, operation) {\n        if (error instanceof ErrorTypes_1.BaseFrameworkError) {\n            return error;\n        }\n        const errorCode = this.categorizeError(error);\n        switch (errorCode) {\n            case 'INVALID_INPUT':\n                return new ErrorTypes_1.ValidationError(error.message);\n            case 'UNAUTHORIZED':\n                return new ErrorTypes_1.AuthenticationError(error.message, service);\n            case 'RATE_LIMITED':\n                return new ErrorTypes_1.RateLimitError(error.message, service);\n            case 'SERVICE_UNAVAILABLE':\n                return new ErrorTypes_1.ServiceUnavailableError(error.message, service);\n            case 'TIMEOUT':\n                return new ErrorTypes_1.TimeoutError(error.message, service, operation);\n            case 'NETWORK_ERROR':\n                return new ErrorTypes_1.NetworkError(error.message, service, error);\n            case 'INVALID_CONFIGURATION':\n                return new ErrorTypes_1.ConfigurationError(error.message, service);\n            case 'QUOTA_EXCEEDED':\n                return new ErrorTypes_1.QuotaExceededError(error.message, service);\n            default:\n                return new ErrorTypes_1.BaseFrameworkError('UNKNOWN_ERROR', error.message, {\n                    service,\n                    operation,\n                    cause: error\n                });\n        }\n    }\n    /**\n     * Categorize an error into a standard error code\n     * @param error - Error to categorize\n     * @returns Standard error code\n     */\n    categorizeError(error) {\n        const message = error.message.toLowerCase();\n        const name = error.name.toLowerCase();\n        // Network-related errors\n        if (name.includes('network') || message.includes('network') ||\n            message.includes('connection') || message.includes('econnrefused') ||\n            message.includes('dns') || message.includes('socket')) {\n            return 'NETWORK_ERROR';\n        }\n        // Timeout errors\n        if (name.includes('timeout') || message.includes('timeout') ||\n            message.includes('timed out')) {\n            return 'TIMEOUT';\n        }\n        // Authentication errors\n        if (message.includes('unauthorized') || message.includes('authentication') ||\n            message.includes('invalid token') || message.includes('expired token')) {\n            return 'UNAUTHORIZED';\n        }\n        // Authorization errors\n        if (message.includes('forbidden') || message.includes('access denied') ||\n            message.includes('permission')) {\n            return 'FORBIDDEN';\n        }\n        // Rate limiting\n        if (message.includes('rate limit') || message.includes('too many requests') ||\n            message.includes('quota exceeded')) {\n            return 'RATE_LIMITED';\n        }\n        // Service unavailable\n        if (message.includes('service unavailable') || message.includes('server error') ||\n            message.includes('internal server error') || message.includes('502') ||\n            message.includes('503') || message.includes('504')) {\n            return 'SERVICE_UNAVAILABLE';\n        }\n        // Validation errors\n        if (message.includes('validation') || message.includes('invalid input') ||\n            message.includes('bad request') || message.includes('400')) {\n            return 'INVALID_INPUT';\n        }\n        // Configuration errors\n        if (message.includes('configuration') || message.includes('config') ||\n            message.includes('missing api key') || message.includes('invalid api key')) {\n            return 'INVALID_CONFIGURATION';\n        }\n        // Not found errors\n        if (message.includes('not found') || message.includes('404')) {\n            return 'NOT_FOUND';\n        }\n        // Default to unknown error\n        return 'UNKNOWN_ERROR';\n    }\n    /**\n     * Sleep utility for retry delays\n     * @param ms - Milliseconds to sleep\n     * @returns Promise that resolves after delay\n     */\n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\nexports.FrameworkErrorHandler = FrameworkErrorHandler;\n//# sourceMappingURL=ErrorHandler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL3V0aWxzL0Vycm9ySGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLDZIQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsOEJBQThCLHlDQUF5QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2p1aG9tYXR0aWxhL0RvY3VtZW50cy9BZHZhbmNlIG5vZGUuanMgcHJvamVjdHMvaHVic3BvdC1vbmJvYXJkaW5nL25vZGVfbW9kdWxlcy9AanVob21hdC9oZXhhZ29uYWwtYWktZnJhbWV3b3JrL2xpYi9mcmFtZXdvcmsvdXRpbHMvRXJyb3JIYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ2VudHJhbGl6ZWQgRXJyb3IgSGFuZGxlciBmb3IgdGhlIEhleGFnb25hbCBGcmFtZXdvcmtcbi8vIFByb3ZpZGVzIGNvbnNpc3RlbnQgZXJyb3IgaGFuZGxpbmcsIGxvZ2dpbmcsIGFuZCByZXRyeSBsb2dpY1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GcmFtZXdvcmtFcnJvckhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBFcnJvclR5cGVzXzEgPSByZXF1aXJlKFwiLi4vY29yZS90eXBlcy9FcnJvclR5cGVzXCIpO1xuY2xhc3MgRnJhbWV3b3JrRXJyb3JIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXRyeUNvbmZpZykge1xuICAgICAgICB0aGlzLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYW55IGVycm9yIHRvIGEgc3RhbmRhcmRpemVkIEZyYW1ld29ya0Vycm9yXG4gICAgICogQHBhcmFtIGVycm9yIC0gT3JpZ2luYWwgZXJyb3JcbiAgICAgKiBAcGFyYW0gc2VydmljZSAtIFNlcnZpY2UgbmFtZSB3aGVyZSBlcnJvciBvY2N1cnJlZFxuICAgICAqIEBwYXJhbSBvcGVyYXRpb24gLSBPcGVyYXRpb24gdGhhdCBmYWlsZWRcbiAgICAgKiBAcmV0dXJucyBTdGFuZGFyZGl6ZWQgRnJhbWV3b3JrRXJyb3JcbiAgICAgKi9cbiAgICBoYW5kbGUoZXJyb3IsIHNlcnZpY2UsIG9wZXJhdGlvbikge1xuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgYSBGcmFtZXdvcmtFcnJvciwgcmV0dXJuIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yVHlwZXNfMS5CYXNlRnJhbWV3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gY2F0ZWdvcml6ZSB0aGUgZXJyb3IgYmFzZWQgb24gY29tbW9uIHBhdHRlcm5zXG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHRoaXMuY2F0ZWdvcml6ZUVycm9yKGVycm9yKTtcbiAgICAgICAgY29uc3QgZnJhbWV3b3JrRXJyb3IgPSBuZXcgRXJyb3JUeXBlc18xLkJhc2VGcmFtZXdvcmtFcnJvcihlcnJvckNvZGUsIGVycm9yLm1lc3NhZ2UsIHtcbiAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICByZXRyeWFibGU6IHRoaXMuaXNSZXRyeWFibGUoZXJyb3IpLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnJhbWV3b3JrRXJyb3IudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGVycm9yIGlzIHJldHJ5YWJsZVxuICAgICAqIEBwYXJhbSBlcnJvciAtIEVycm9yIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZXJyb3IgaXMgcmV0cnlhYmxlXG4gICAgICovXG4gICAgaXNSZXRyeWFibGUoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3JUeXBlc18xLkJhc2VGcmFtZXdvcmtFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnJldHJ5YWJsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB0aGlzLmNhdGVnb3JpemVFcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJ5Q29uZmlnLnJldHJ5YWJsZUVycm9ycy5pbmNsdWRlcyhlcnJvckNvZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSByZXRyeSBzaG91bGQgYmUgYXR0ZW1wdGVkIGJhc2VkIG9uIGF0dGVtcHQgY291bnRcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBFcnJvciB0aGF0IG9jY3VycmVkXG4gICAgICogQHBhcmFtIGF0dGVtcHQgLSBDdXJyZW50IGF0dGVtcHQgbnVtYmVyICgxLWJhc2VkKVxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdG8gcmV0cnlcbiAgICAgKi9cbiAgICBzaG91bGRSZXRyeShlcnJvciwgYXR0ZW1wdCkge1xuICAgICAgICBpZiAoYXR0ZW1wdCA+PSB0aGlzLnJldHJ5Q29uZmlnLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZXRyeWFibGUoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYmFja29mZiBkZWxheSBmb3IgcmV0cnkgYXR0ZW1wdHNcbiAgICAgKiBAcGFyYW0gYXR0ZW1wdCAtIEN1cnJlbnQgYXR0ZW1wdCBudW1iZXIgKDEtYmFzZWQpXG4gICAgICogQHJldHVybnMgRGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgY2FsY3VsYXRlQmFja29mZihhdHRlbXB0KSB7XG4gICAgICAgIGNvbnN0IGJhc2VEZWxheSA9IDEwMDA7IC8vIDEgc2Vjb25kXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gYmFzZURlbGF5ICogTWF0aC5wb3codGhpcy5yZXRyeUNvbmZpZy5iYWNrb2ZmTXVsdGlwbGllciwgYXR0ZW1wdCAtIDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oZGVsYXksIHRoaXMucmV0cnlDb25maWcubWF4QmFja29mZk1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdpdGggcmV0cnkgbG9naWNcbiAgICAgKiBAcGFyYW0gZm4gLSBGdW5jdGlvbiB0byBleGVjdXRlXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBDb250ZXh0IGluZm9ybWF0aW9uIGZvciBlcnJvciBoYW5kbGluZ1xuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXN1bHQgb3IgdGhyb3dzIGZpbmFsIGVycm9yXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZVdpdGhSZXRyeShmbiwgY29udGV4dCA9IHt9KSB7XG4gICAgICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSB0aGlzLnJldHJ5Q29uZmlnLm1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkUmV0cnkobGFzdEVycm9yLCBhdHRlbXB0KSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCB0aGlzLnJldHJ5Q29uZmlnLm1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5jYWxjdWxhdGVCYWNrb2ZmKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNsZWVwKGRlbGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsIHJldHJpZXMgZXhoYXVzdGVkLCB0aHJvdyB0aGUgZmluYWwgZXJyb3JcbiAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGcmFtZXdvcmtFcnJvcihsYXN0RXJyb3IsIGNvbnRleHQuc2VydmljZSwgY29udGV4dC5vcGVyYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzcGVjaWZpYyBGcmFtZXdvcmtFcnJvciBiYXNlZCBvbiBlcnJvciB0eXBlXG4gICAgICogQHBhcmFtIGVycm9yIC0gT3JpZ2luYWwgZXJyb3JcbiAgICAgKiBAcGFyYW0gc2VydmljZSAtIFNlcnZpY2UgbmFtZVxuICAgICAqIEBwYXJhbSBvcGVyYXRpb24gLSBPcGVyYXRpb24gbmFtZVxuICAgICAqIEByZXR1cm5zIFNwZWNpZmljIEZyYW1ld29ya0Vycm9yIGluc3RhbmNlXG4gICAgICovXG4gICAgY3JlYXRlRnJhbWV3b3JrRXJyb3IoZXJyb3IsIHNlcnZpY2UsIG9wZXJhdGlvbikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvclR5cGVzXzEuQmFzZUZyYW1ld29ya0Vycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gdGhpcy5jYXRlZ29yaXplRXJyb3IoZXJyb3IpO1xuICAgICAgICBzd2l0Y2ggKGVycm9yQ29kZSkge1xuICAgICAgICAgICAgY2FzZSAnSU5WQUxJRF9JTlBVVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclR5cGVzXzEuVmFsaWRhdGlvbkVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY2FzZSAnVU5BVVRIT1JJWkVEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5BdXRoZW50aWNhdGlvbkVycm9yKGVycm9yLm1lc3NhZ2UsIHNlcnZpY2UpO1xuICAgICAgICAgICAgY2FzZSAnUkFURV9MSU1JVEVEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5SYXRlTGltaXRFcnJvcihlcnJvci5tZXNzYWdlLCBzZXJ2aWNlKTtcbiAgICAgICAgICAgIGNhc2UgJ1NFUlZJQ0VfVU5BVkFJTEFCTEUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3JUeXBlc18xLlNlcnZpY2VVbmF2YWlsYWJsZUVycm9yKGVycm9yLm1lc3NhZ2UsIHNlcnZpY2UpO1xuICAgICAgICAgICAgY2FzZSAnVElNRU9VVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclR5cGVzXzEuVGltZW91dEVycm9yKGVycm9yLm1lc3NhZ2UsIHNlcnZpY2UsIG9wZXJhdGlvbik7XG4gICAgICAgICAgICBjYXNlICdORVRXT1JLX0VSUk9SJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5OZXR3b3JrRXJyb3IoZXJyb3IubWVzc2FnZSwgc2VydmljZSwgZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnSU5WQUxJRF9DT05GSUdVUkFUSU9OJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5Db25maWd1cmF0aW9uRXJyb3IoZXJyb3IubWVzc2FnZSwgc2VydmljZSk7XG4gICAgICAgICAgICBjYXNlICdRVU9UQV9FWENFRURFRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvclR5cGVzXzEuUXVvdGFFeGNlZWRlZEVycm9yKGVycm9yLm1lc3NhZ2UsIHNlcnZpY2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yVHlwZXNfMS5CYXNlRnJhbWV3b3JrRXJyb3IoJ1VOS05PV05fRVJST1InLCBlcnJvci5tZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2F0ZWdvcml6ZSBhbiBlcnJvciBpbnRvIGEgc3RhbmRhcmQgZXJyb3IgY29kZVxuICAgICAqIEBwYXJhbSBlcnJvciAtIEVycm9yIHRvIGNhdGVnb3JpemVcbiAgICAgKiBAcmV0dXJucyBTdGFuZGFyZCBlcnJvciBjb2RlXG4gICAgICovXG4gICAgY2F0ZWdvcml6ZUVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBlcnJvci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIE5ldHdvcmstcmVsYXRlZCBlcnJvcnNcbiAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoJ25ldHdvcmsnKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCduZXR3b3JrJykgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ2Nvbm5lY3Rpb24nKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCdlY29ubnJlZnVzZWQnKSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnZG5zJykgfHwgbWVzc2FnZS5pbmNsdWRlcygnc29ja2V0JykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTkVUV09SS19FUlJPUic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGltZW91dCBlcnJvcnNcbiAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoJ3RpbWVvdXQnKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCd0aW1lb3V0JykgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ3RpbWVkIG91dCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1RJTUVPVVQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF1dGhlbnRpY2F0aW9uIGVycm9yc1xuICAgICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygndW5hdXRob3JpemVkJykgfHwgbWVzc2FnZS5pbmNsdWRlcygnYXV0aGVudGljYXRpb24nKSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnaW52YWxpZCB0b2tlbicpIHx8IG1lc3NhZ2UuaW5jbHVkZXMoJ2V4cGlyZWQgdG9rZW4nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdVTkFVVEhPUklaRUQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF1dGhvcml6YXRpb24gZXJyb3JzXG4gICAgICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdmb3JiaWRkZW4nKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCdhY2Nlc3MgZGVuaWVkJykgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGT1JCSURERU4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJhdGUgbGltaXRpbmdcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCd0b28gbWFueSByZXF1ZXN0cycpIHx8XG4gICAgICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdxdW90YSBleGNlZWRlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1JBVEVfTElNSVRFRCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VydmljZSB1bmF2YWlsYWJsZVxuICAgICAgICBpZiAobWVzc2FnZS5pbmNsdWRlcygnc2VydmljZSB1bmF2YWlsYWJsZScpIHx8IG1lc3NhZ2UuaW5jbHVkZXMoJ3NlcnZlciBlcnJvcicpIHx8XG4gICAgICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdpbnRlcm5hbCBzZXJ2ZXIgZXJyb3InKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCc1MDInKSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnNTAzJykgfHwgbWVzc2FnZS5pbmNsdWRlcygnNTA0JykpIHtcbiAgICAgICAgICAgIHJldHVybiAnU0VSVklDRV9VTkFWQUlMQUJMRSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGlvbiBlcnJvcnNcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoJ3ZhbGlkYXRpb24nKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCdpbnZhbGlkIGlucHV0JykgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ2JhZCByZXF1ZXN0JykgfHwgbWVzc2FnZS5pbmNsdWRlcygnNDAwJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9JTlBVVCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uZmlndXJhdGlvbiBlcnJvcnNcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5jbHVkZXMoJ2NvbmZpZ3VyYXRpb24nKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCdjb25maWcnKSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnbWlzc2luZyBhcGkga2V5JykgfHwgbWVzc2FnZS5pbmNsdWRlcygnaW52YWxpZCBhcGkga2V5JykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9DT05GSUdVUkFUSU9OJztcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZm91bmQgZXJyb3JzXG4gICAgICAgIGlmIChtZXNzYWdlLmluY2x1ZGVzKCdub3QgZm91bmQnKSB8fCBtZXNzYWdlLmluY2x1ZGVzKCc0MDQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdOT1RfRk9VTkQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgdG8gdW5rbm93biBlcnJvclxuICAgICAgICByZXR1cm4gJ1VOS05PV05fRVJST1InO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTbGVlcCB1dGlsaXR5IGZvciByZXRyeSBkZWxheXNcbiAgICAgKiBAcGFyYW0gbXMgLSBNaWxsaXNlY29uZHMgdG8gc2xlZXBcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgZGVsYXlcbiAgICAgKi9cbiAgICBzbGVlcChtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gICAgfVxufVxuZXhwb3J0cy5GcmFtZXdvcmtFcnJvckhhbmRsZXIgPSBGcmFtZXdvcmtFcnJvckhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvckhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/HealthCheck.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/HealthCheck.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Health Check System for the Hexagonal Framework\n// Monitors health status of all services and provides unified health reporting\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleHealthCheck = exports.HealthCheckFactory = exports.HealthCheckService = void 0;\nclass HealthCheckService {\n    constructor(config, logger) {\n        this.services = new Map();\n        this.lastHealthReport = null;\n        this.checkInterval = null;\n        this.healthCheckCallbacks = [];\n        this.config = config;\n        this.logger = logger;\n    }\n    /**\n     * Register a service for health monitoring\n     * @param service - Service to monitor\n     */\n    registerService(service) {\n        const serviceName = service.getServiceName();\n        this.services.set(serviceName, service);\n        this.logger.info('Service registered for health monitoring', {\n            service: serviceName\n        });\n    }\n    /**\n     * Unregister a service from health monitoring\n     * @param serviceName - Name of service to unregister\n     */\n    unregisterService(serviceName) {\n        if (this.services.delete(serviceName)) {\n            this.logger.info('Service unregistered from health monitoring', {\n                service: serviceName\n            });\n        }\n    }\n    /**\n     * Start periodic health checks\n     */\n    start() {\n        if (!this.config.enabled) {\n            this.logger.info('Health check service is disabled');\n            return;\n        }\n        if (this.checkInterval) {\n            this.logger.warn('Health check service is already running');\n            return;\n        }\n        this.logger.info('Starting health check service', {\n            intervalMs: this.config.intervalMs,\n            timeoutMs: this.config.timeoutMs\n        });\n        // Perform initial health check\n        this.performHealthCheck();\n        // Schedule periodic health checks\n        this.checkInterval = setInterval(() => this.performHealthCheck(), this.config.intervalMs);\n    }\n    /**\n     * Stop periodic health checks\n     */\n    stop() {\n        if (this.checkInterval) {\n            clearInterval(this.checkInterval);\n            this.checkInterval = null;\n            this.logger.info('Health check service stopped');\n        }\n    }\n    /**\n     * Perform a manual health check on all registered services\n     * @returns Promise with health report\n     */\n    async checkHealth() {\n        return this.performHealthCheck();\n    }\n    /**\n     * Get the last health report\n     * @returns Last health report or null if none available\n     */\n    getLastHealthReport() {\n        return this.lastHealthReport;\n    }\n    /**\n     * Subscribe to health check updates\n     * @param callback - Callback to execute when health check completes\n     */\n    onHealthCheck(callback) {\n        this.healthCheckCallbacks.push(callback);\n    }\n    /**\n     * Unsubscribe from health check updates\n     * @param callback - Callback to remove\n     */\n    offHealthCheck(callback) {\n        const index = this.healthCheckCallbacks.indexOf(callback);\n        if (index > -1) {\n            this.healthCheckCallbacks.splice(index, 1);\n        }\n    }\n    /**\n     * Check if overall system is healthy\n     * @returns Whether system is healthy\n     */\n    isSystemHealthy() {\n        if (!this.lastHealthReport) {\n            return false;\n        }\n        return this.lastHealthReport.overall === 'healthy';\n    }\n    /**\n     * Get health status for a specific service\n     * @param serviceName - Name of service\n     * @returns Health status or null if service not found\n     */\n    getServiceHealth(serviceName) {\n        if (!this.lastHealthReport) {\n            return null;\n        }\n        return this.lastHealthReport.services.find(s => s.service === serviceName) || null;\n    }\n    /**\n     * Internal method to perform health checks on all services\n     * @returns Health report\n     */\n    async performHealthCheck() {\n        const timestamp = new Date();\n        const serviceStatuses = [];\n        this.logger.debug('Performing health check on all services');\n        // Check each registered service\n        for (const serviceName of Array.from(this.services.keys())) {\n            const service = this.services.get(serviceName);\n            if (!service)\n                continue;\n            try {\n                const isHealthy = await this.checkServiceWithTimeout(service);\n                serviceStatuses.push({\n                    service: serviceName,\n                    status: isHealthy ? 'healthy' : 'unhealthy',\n                    timestamp\n                });\n            }\n            catch (error) {\n                this.logger.error('Health check failed for service', {\n                    service: serviceName\n                }, error);\n                serviceStatuses.push({\n                    service: serviceName,\n                    status: 'unhealthy',\n                    timestamp,\n                    details: {\n                        error: error.message\n                    }\n                });\n            }\n        }\n        // Calculate overall health\n        const summary = this.calculateSummary(serviceStatuses);\n        const overall = this.determineOverallHealth(summary);\n        const healthReport = {\n            overall,\n            services: serviceStatuses,\n            timestamp,\n            summary\n        };\n        this.lastHealthReport = healthReport;\n        // Log health status\n        this.logger.info('Health check completed', {\n            overall,\n            healthy: summary.healthy,\n            unhealthy: summary.unhealthy,\n            degraded: summary.degraded\n        });\n        // Notify callbacks\n        this.healthCheckCallbacks.forEach(callback => {\n            try {\n                callback(healthReport);\n            }\n            catch (error) {\n                this.logger.error('Health check callback error', {}, error);\n            }\n        });\n        return healthReport;\n    }\n    /**\n     * Check a single service with timeout\n     * @param service - Service to check\n     * @returns Promise with health status\n     */\n    async checkServiceWithTimeout(service) {\n        return new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                reject(new Error(`Health check timeout after ${this.config.timeoutMs}ms`));\n            }, this.config.timeoutMs);\n            service.isHealthy()\n                .then(result => {\n                clearTimeout(timeoutId);\n                resolve(result);\n            })\n                .catch(error => {\n                clearTimeout(timeoutId);\n                reject(error);\n            });\n        });\n    }\n    /**\n     * Calculate summary statistics from service statuses\n     * @param statuses - Array of service health statuses\n     * @returns Summary statistics\n     */\n    calculateSummary(statuses) {\n        const summary = {\n            total: statuses.length,\n            healthy: 0,\n            unhealthy: 0,\n            degraded: 0\n        };\n        statuses.forEach(status => {\n            switch (status.status) {\n                case 'healthy':\n                    summary.healthy++;\n                    break;\n                case 'unhealthy':\n                    summary.unhealthy++;\n                    break;\n                case 'degraded':\n                    summary.degraded++;\n                    break;\n            }\n        });\n        return summary;\n    }\n    /**\n     * Determine overall system health based on service statuses\n     * @param summary - Summary statistics\n     * @returns Overall health status\n     */\n    determineOverallHealth(summary) {\n        if (summary.total === 0) {\n            return 'healthy'; // No services to check\n        }\n        if (summary.unhealthy > 0) {\n            return 'unhealthy'; // Any unhealthy service makes system unhealthy\n        }\n        if (summary.degraded > 0) {\n            return 'degraded'; // Any degraded service makes system degraded\n        }\n        return 'healthy'; // All services are healthy\n    }\n}\nexports.HealthCheckService = HealthCheckService;\n// Factory for creating health check service\nclass HealthCheckFactory {\n    static create(config, logger) {\n        return new HealthCheckService(config, logger);\n    }\n    static createDefault(logger) {\n        const defaultConfig = {\n            intervalMs: 30000, // 30 seconds\n            timeoutMs: 5000, // 5 seconds\n            enabled: true\n        };\n        return new HealthCheckService(defaultConfig, logger);\n    }\n}\nexports.HealthCheckFactory = HealthCheckFactory;\n// Utility for creating simple health check implementations\nclass SimpleHealthCheck {\n    constructor(serviceName, healthCheckFn) {\n        this.serviceName = serviceName;\n        this.healthCheckFn = healthCheckFn;\n    }\n    async isHealthy() {\n        return this.healthCheckFn();\n    }\n    getServiceName() {\n        return this.serviceName;\n    }\n}\nexports.SimpleHealthCheck = SimpleHealthCheck;\n//# sourceMappingURL=HealthCheck.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL3V0aWxzL0hlYWx0aENoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRywwQkFBMEI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxzQkFBc0I7QUFDckYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL3V0aWxzL0hlYWx0aENoZWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gSGVhbHRoIENoZWNrIFN5c3RlbSBmb3IgdGhlIEhleGFnb25hbCBGcmFtZXdvcmtcbi8vIE1vbml0b3JzIGhlYWx0aCBzdGF0dXMgb2YgYWxsIHNlcnZpY2VzIGFuZCBwcm92aWRlcyB1bmlmaWVkIGhlYWx0aCByZXBvcnRpbmdcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlSGVhbHRoQ2hlY2sgPSBleHBvcnRzLkhlYWx0aENoZWNrRmFjdG9yeSA9IGV4cG9ydHMuSGVhbHRoQ2hlY2tTZXJ2aWNlID0gdm9pZCAwO1xuY2xhc3MgSGVhbHRoQ2hlY2tTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLnNlcnZpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxhc3RIZWFsdGhSZXBvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoZWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWx0aENoZWNrQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzZXJ2aWNlIGZvciBoZWFsdGggbW9uaXRvcmluZ1xuICAgICAqIEBwYXJhbSBzZXJ2aWNlIC0gU2VydmljZSB0byBtb25pdG9yXG4gICAgICovXG4gICAgcmVnaXN0ZXJTZXJ2aWNlKHNlcnZpY2UpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZU5hbWUgPSBzZXJ2aWNlLmdldFNlcnZpY2VOYW1lKCk7XG4gICAgICAgIHRoaXMuc2VydmljZXMuc2V0KHNlcnZpY2VOYW1lLCBzZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2VydmljZSByZWdpc3RlcmVkIGZvciBoZWFsdGggbW9uaXRvcmluZycsIHtcbiAgICAgICAgICAgIHNlcnZpY2U6IHNlcnZpY2VOYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGEgc2VydmljZSBmcm9tIGhlYWx0aCBtb25pdG9yaW5nXG4gICAgICogQHBhcmFtIHNlcnZpY2VOYW1lIC0gTmFtZSBvZiBzZXJ2aWNlIHRvIHVucmVnaXN0ZXJcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyU2VydmljZShzZXJ2aWNlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlcy5kZWxldGUoc2VydmljZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZXJ2aWNlIHVucmVnaXN0ZXJlZCBmcm9tIGhlYWx0aCBtb25pdG9yaW5nJywge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IHNlcnZpY2VOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBwZXJpb2RpYyBoZWFsdGggY2hlY2tzXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnSGVhbHRoIGNoZWNrIHNlcnZpY2UgaXMgZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGVja0ludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdIZWFsdGggY2hlY2sgc2VydmljZSBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTdGFydGluZyBoZWFsdGggY2hlY2sgc2VydmljZScsIHtcbiAgICAgICAgICAgIGludGVydmFsTXM6IHRoaXMuY29uZmlnLmludGVydmFsTXMsXG4gICAgICAgICAgICB0aW1lb3V0TXM6IHRoaXMuY29uZmlnLnRpbWVvdXRNc1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGVyZm9ybSBpbml0aWFsIGhlYWx0aCBjaGVja1xuICAgICAgICB0aGlzLnBlcmZvcm1IZWFsdGhDaGVjaygpO1xuICAgICAgICAvLyBTY2hlZHVsZSBwZXJpb2RpYyBoZWFsdGggY2hlY2tzXG4gICAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMucGVyZm9ybUhlYWx0aENoZWNrKCksIHRoaXMuY29uZmlnLmludGVydmFsTXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHBlcmlvZGljIGhlYWx0aCBjaGVja3NcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2hlY2tJbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnSGVhbHRoIGNoZWNrIHNlcnZpY2Ugc3RvcHBlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBtYW51YWwgaGVhbHRoIGNoZWNrIG9uIGFsbCByZWdpc3RlcmVkIHNlcnZpY2VzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGhlYWx0aCByZXBvcnRcbiAgICAgKi9cbiAgICBhc3luYyBjaGVja0hlYWx0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybUhlYWx0aENoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFzdCBoZWFsdGggcmVwb3J0XG4gICAgICogQHJldHVybnMgTGFzdCBoZWFsdGggcmVwb3J0IG9yIG51bGwgaWYgbm9uZSBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBnZXRMYXN0SGVhbHRoUmVwb3J0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0SGVhbHRoUmVwb3J0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gaGVhbHRoIGNoZWNrIHVwZGF0ZXNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gaGVhbHRoIGNoZWNrIGNvbXBsZXRlc1xuICAgICAqL1xuICAgIG9uSGVhbHRoQ2hlY2soY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5oZWFsdGhDaGVja0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBoZWFsdGggY2hlY2sgdXBkYXRlc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIG9mZkhlYWx0aENoZWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5oZWFsdGhDaGVja0NhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2tDYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBvdmVyYWxsIHN5c3RlbSBpcyBoZWFsdGh5XG4gICAgICogQHJldHVybnMgV2hldGhlciBzeXN0ZW0gaXMgaGVhbHRoeVxuICAgICAqL1xuICAgIGlzU3lzdGVtSGVhbHRoeSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RIZWFsdGhSZXBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0SGVhbHRoUmVwb3J0Lm92ZXJhbGwgPT09ICdoZWFsdGh5JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGhlYWx0aCBzdGF0dXMgZm9yIGEgc3BlY2lmaWMgc2VydmljZVxuICAgICAqIEBwYXJhbSBzZXJ2aWNlTmFtZSAtIE5hbWUgb2Ygc2VydmljZVxuICAgICAqIEByZXR1cm5zIEhlYWx0aCBzdGF0dXMgb3IgbnVsbCBpZiBzZXJ2aWNlIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldFNlcnZpY2VIZWFsdGgoc2VydmljZU5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RIZWFsdGhSZXBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RIZWFsdGhSZXBvcnQuc2VydmljZXMuZmluZChzID0+IHMuc2VydmljZSA9PT0gc2VydmljZU5hbWUpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBwZXJmb3JtIGhlYWx0aCBjaGVja3Mgb24gYWxsIHNlcnZpY2VzXG4gICAgICogQHJldHVybnMgSGVhbHRoIHJlcG9ydFxuICAgICAqL1xuICAgIGFzeW5jIHBlcmZvcm1IZWFsdGhDaGVjaygpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3Qgc2VydmljZVN0YXR1c2VzID0gW107XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdQZXJmb3JtaW5nIGhlYWx0aCBjaGVjayBvbiBhbGwgc2VydmljZXMnKTtcbiAgICAgICAgLy8gQ2hlY2sgZWFjaCByZWdpc3RlcmVkIHNlcnZpY2VcbiAgICAgICAgZm9yIChjb25zdCBzZXJ2aWNlTmFtZSBvZiBBcnJheS5mcm9tKHRoaXMuc2VydmljZXMua2V5cygpKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHRoaXMuc2VydmljZXMuZ2V0KHNlcnZpY2VOYW1lKTtcbiAgICAgICAgICAgIGlmICghc2VydmljZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFsdGh5ID0gYXdhaXQgdGhpcy5jaGVja1NlcnZpY2VXaXRoVGltZW91dChzZXJ2aWNlKTtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlU3RhdHVzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2U6IHNlcnZpY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGlzSGVhbHRoeSA/ICdoZWFsdGh5JyA6ICd1bmhlYWx0aHknLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdIZWFsdGggY2hlY2sgZmFpbGVkIGZvciBzZXJ2aWNlJywge1xuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlOiBzZXJ2aWNlTmFtZVxuICAgICAgICAgICAgICAgIH0sIGVycm9yKTtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlU3RhdHVzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2U6IHNlcnZpY2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICd1bmhlYWx0aHknLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgb3ZlcmFsbCBoZWFsdGhcbiAgICAgICAgY29uc3Qgc3VtbWFyeSA9IHRoaXMuY2FsY3VsYXRlU3VtbWFyeShzZXJ2aWNlU3RhdHVzZXMpO1xuICAgICAgICBjb25zdCBvdmVyYWxsID0gdGhpcy5kZXRlcm1pbmVPdmVyYWxsSGVhbHRoKHN1bW1hcnkpO1xuICAgICAgICBjb25zdCBoZWFsdGhSZXBvcnQgPSB7XG4gICAgICAgICAgICBvdmVyYWxsLFxuICAgICAgICAgICAgc2VydmljZXM6IHNlcnZpY2VTdGF0dXNlcyxcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIHN1bW1hcnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sYXN0SGVhbHRoUmVwb3J0ID0gaGVhbHRoUmVwb3J0O1xuICAgICAgICAvLyBMb2cgaGVhbHRoIHN0YXR1c1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdIZWFsdGggY2hlY2sgY29tcGxldGVkJywge1xuICAgICAgICAgICAgb3ZlcmFsbCxcbiAgICAgICAgICAgIGhlYWx0aHk6IHN1bW1hcnkuaGVhbHRoeSxcbiAgICAgICAgICAgIHVuaGVhbHRoeTogc3VtbWFyeS51bmhlYWx0aHksXG4gICAgICAgICAgICBkZWdyYWRlZDogc3VtbWFyeS5kZWdyYWRlZFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm90aWZ5IGNhbGxiYWNrc1xuICAgICAgICB0aGlzLmhlYWx0aENoZWNrQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhoZWFsdGhSZXBvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0hlYWx0aCBjaGVjayBjYWxsYmFjayBlcnJvcicsIHt9LCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGVhbHRoUmVwb3J0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBhIHNpbmdsZSBzZXJ2aWNlIHdpdGggdGltZW91dFxuICAgICAqIEBwYXJhbSBzZXJ2aWNlIC0gU2VydmljZSB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBoZWFsdGggc3RhdHVzXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tTZXJ2aWNlV2l0aFRpbWVvdXQoc2VydmljZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgSGVhbHRoIGNoZWNrIHRpbWVvdXQgYWZ0ZXIgJHt0aGlzLmNvbmZpZy50aW1lb3V0TXN9bXNgKSk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy50aW1lb3V0TXMpO1xuICAgICAgICAgICAgc2VydmljZS5pc0hlYWx0aHkoKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdW1tYXJ5IHN0YXRpc3RpY3MgZnJvbSBzZXJ2aWNlIHN0YXR1c2VzXG4gICAgICogQHBhcmFtIHN0YXR1c2VzIC0gQXJyYXkgb2Ygc2VydmljZSBoZWFsdGggc3RhdHVzZXNcbiAgICAgKiBAcmV0dXJucyBTdW1tYXJ5IHN0YXRpc3RpY3NcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVTdW1tYXJ5KHN0YXR1c2VzKSB7XG4gICAgICAgIGNvbnN0IHN1bW1hcnkgPSB7XG4gICAgICAgICAgICB0b3RhbDogc3RhdHVzZXMubGVuZ3RoLFxuICAgICAgICAgICAgaGVhbHRoeTogMCxcbiAgICAgICAgICAgIHVuaGVhbHRoeTogMCxcbiAgICAgICAgICAgIGRlZ3JhZGVkOiAwXG4gICAgICAgIH07XG4gICAgICAgIHN0YXR1c2VzLmZvckVhY2goc3RhdHVzID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc3RhdHVzLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hlYWx0aHknOlxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5LmhlYWx0aHkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5oZWFsdGh5JzpcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeS51bmhlYWx0aHkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVncmFkZWQnOlxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5LmRlZ3JhZGVkKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1bW1hcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBvdmVyYWxsIHN5c3RlbSBoZWFsdGggYmFzZWQgb24gc2VydmljZSBzdGF0dXNlc1xuICAgICAqIEBwYXJhbSBzdW1tYXJ5IC0gU3VtbWFyeSBzdGF0aXN0aWNzXG4gICAgICogQHJldHVybnMgT3ZlcmFsbCBoZWFsdGggc3RhdHVzXG4gICAgICovXG4gICAgZGV0ZXJtaW5lT3ZlcmFsbEhlYWx0aChzdW1tYXJ5KSB7XG4gICAgICAgIGlmIChzdW1tYXJ5LnRvdGFsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hlYWx0aHknOyAvLyBObyBzZXJ2aWNlcyB0byBjaGVja1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdW1tYXJ5LnVuaGVhbHRoeSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAndW5oZWFsdGh5JzsgLy8gQW55IHVuaGVhbHRoeSBzZXJ2aWNlIG1ha2VzIHN5c3RlbSB1bmhlYWx0aHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtbWFyeS5kZWdyYWRlZCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnZGVncmFkZWQnOyAvLyBBbnkgZGVncmFkZWQgc2VydmljZSBtYWtlcyBzeXN0ZW0gZGVncmFkZWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2hlYWx0aHknOyAvLyBBbGwgc2VydmljZXMgYXJlIGhlYWx0aHlcbiAgICB9XG59XG5leHBvcnRzLkhlYWx0aENoZWNrU2VydmljZSA9IEhlYWx0aENoZWNrU2VydmljZTtcbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIGhlYWx0aCBjaGVjayBzZXJ2aWNlXG5jbGFzcyBIZWFsdGhDaGVja0ZhY3Rvcnkge1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnLCBsb2dnZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIZWFsdGhDaGVja1NlcnZpY2UoY29uZmlnLCBsb2dnZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRGVmYXVsdChsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsTXM6IDMwMDAwLCAvLyAzMCBzZWNvbmRzXG4gICAgICAgICAgICB0aW1lb3V0TXM6IDUwMDAsIC8vIDUgc2Vjb25kc1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEhlYWx0aENoZWNrU2VydmljZShkZWZhdWx0Q29uZmlnLCBsb2dnZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGVhbHRoQ2hlY2tGYWN0b3J5ID0gSGVhbHRoQ2hlY2tGYWN0b3J5O1xuLy8gVXRpbGl0eSBmb3IgY3JlYXRpbmcgc2ltcGxlIGhlYWx0aCBjaGVjayBpbXBsZW1lbnRhdGlvbnNcbmNsYXNzIFNpbXBsZUhlYWx0aENoZWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlTmFtZSwgaGVhbHRoQ2hlY2tGbikge1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuaGVhbHRoQ2hlY2tGbiA9IGhlYWx0aENoZWNrRm47XG4gICAgfVxuICAgIGFzeW5jIGlzSGVhbHRoeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhbHRoQ2hlY2tGbigpO1xuICAgIH1cbiAgICBnZXRTZXJ2aWNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZU5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVIZWFsdGhDaGVjayA9IFNpbXBsZUhlYWx0aENoZWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGVhbHRoQ2hlY2suanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/HealthCheck.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/Logger.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/Logger.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Logging Abstraction for the Hexagonal Framework\n// Provides consistent logging interface across all services and adapters\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoggerFactory = exports.ChildLogger = exports.StructuredLogHandler = exports.FileLogHandler = exports.ConsoleLogHandler = exports.FrameworkLogger = void 0;\nclass FrameworkLogger {\n    constructor(level = 'info') {\n        this.logHandlers = [];\n        this.level = level;\n        // Add console handler by default\n        this.addHandler(new ConsoleLogHandler());\n    }\n    /**\n     * Add a log handler\n     * @param handler - Log handler to add\n     */\n    addHandler(handler) {\n        this.logHandlers.push(handler);\n    }\n    /**\n     * Remove a log handler\n     * @param handler - Log handler to remove\n     */\n    removeHandler(handler) {\n        const index = this.logHandlers.indexOf(handler);\n        if (index > -1) {\n            this.logHandlers.splice(index, 1);\n        }\n    }\n    /**\n     * Set the minimum log level\n     * @param level - Minimum log level\n     */\n    setLevel(level) {\n        this.level = level;\n    }\n    /**\n     * Get the current log level\n     * @returns Current log level\n     */\n    getLevel() {\n        return this.level;\n    }\n    /**\n     * Log an error message\n     * @param message - Error message\n     * @param context - Log context\n     * @param error - Error object\n     */\n    error(message, context, error) {\n        this.log('error', message, context, error);\n    }\n    /**\n     * Log a warning message\n     * @param message - Warning message\n     * @param context - Log context\n     */\n    warn(message, context) {\n        this.log('warn', message, context);\n    }\n    /**\n     * Log an info message\n     * @param message - Info message\n     * @param context - Log context\n     */\n    info(message, context) {\n        this.log('info', message, context);\n    }\n    /**\n     * Log a debug message\n     * @param message - Debug message\n     * @param context - Log context\n     */\n    debug(message, context) {\n        this.log('debug', message, context);\n    }\n    /**\n     * Internal log method\n     * @param level - Log level\n     * @param message - Log message\n     * @param context - Log context\n     * @param error - Error object\n     */\n    log(level, message, context, error) {\n        if (!this.shouldLog(level)) {\n            return;\n        }\n        const logEntry = {\n            level,\n            message,\n            timestamp: new Date(),\n            context,\n            error\n        };\n        this.logHandlers.forEach(handler => {\n            try {\n                handler.handle(logEntry);\n            }\n            catch (handlerError) {\n                // Don't let handler errors break logging\n                console.error('Logger handler error:', handlerError);\n            }\n        });\n    }\n    /**\n     * Check if a message should be logged based on current level\n     * @param level - Message level\n     * @returns Whether to log the message\n     */\n    shouldLog(level) {\n        const levels = {\n            error: 0,\n            warn: 1,\n            info: 2,\n            debug: 3\n        };\n        return levels[level] <= levels[this.level];\n    }\n    /**\n     * Create a child logger with additional context\n     * @param context - Additional context for child logger\n     * @returns Child logger instance\n     */\n    child(context) {\n        return new ChildLogger(this, context);\n    }\n}\nexports.FrameworkLogger = FrameworkLogger;\n// Console log handler\nclass ConsoleLogHandler {\n    handle(entry) {\n        const { level, message, timestamp, context, error } = entry;\n        const timestampStr = timestamp.toISOString();\n        const contextStr = context ? ` [${this.formatContext(context)}]` : '';\n        const fullMessage = `${timestampStr} [${level.toUpperCase()}]${contextStr} ${message}`;\n        switch (level) {\n            case 'error':\n                console.error(fullMessage);\n                if (error) {\n                    console.error(error);\n                }\n                break;\n            case 'warn':\n                console.warn(fullMessage);\n                break;\n            case 'info':\n                console.info(fullMessage);\n                break;\n            case 'debug':\n                console.debug(fullMessage);\n                break;\n        }\n    }\n    formatContext(context) {\n        const parts = [];\n        if (context.service)\n            parts.push(`service:${context.service}`);\n        if (context.operation)\n            parts.push(`op:${context.operation}`);\n        if (context.userId)\n            parts.push(`user:${context.userId}`);\n        if (context.requestId)\n            parts.push(`req:${context.requestId}`);\n        return parts.join(' ');\n    }\n}\nexports.ConsoleLogHandler = ConsoleLogHandler;\n// File log handler (for production use)\nclass FileLogHandler {\n    constructor(filePath) {\n        this.filePath = filePath;\n    }\n    handle(entry) {\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const logLine = JSON.stringify(entry) + '\\n';\n        fs.appendFileSync(this.filePath, logLine, 'utf8');\n    }\n}\nexports.FileLogHandler = FileLogHandler;\n// Structured log handler (for external logging services)\nclass StructuredLogHandler {\n    constructor(sendLog) {\n        this.sendLog = sendLog;\n    }\n    handle(entry) {\n        this.sendLog(entry);\n    }\n}\nexports.StructuredLogHandler = StructuredLogHandler;\n// Child logger with inherited context\nclass ChildLogger {\n    constructor(parent, context) {\n        this.parent = parent;\n        this.inheritedContext = context;\n    }\n    error(message, context, error) {\n        this.parent.error(message, this.mergeContext(context), error);\n    }\n    warn(message, context) {\n        this.parent.warn(message, this.mergeContext(context));\n    }\n    info(message, context) {\n        this.parent.info(message, this.mergeContext(context));\n    }\n    debug(message, context) {\n        this.parent.debug(message, this.mergeContext(context));\n    }\n    setLevel(level) {\n        this.parent.setLevel(level);\n    }\n    getLevel() {\n        return this.parent.getLevel();\n    }\n    mergeContext(context) {\n        return { ...this.inheritedContext, ...context };\n    }\n}\nexports.ChildLogger = ChildLogger;\n// Factory for creating loggers\nclass LoggerFactory {\n    static create(level = 'info') {\n        return new FrameworkLogger(level);\n    }\n    static getSingleton(level = 'info') {\n        if (!LoggerFactory.instance) {\n            LoggerFactory.instance = new FrameworkLogger(level);\n        }\n        return LoggerFactory.instance;\n    }\n    static createChild(parent, context) {\n        return parent.child(context);\n    }\n}\nexports.LoggerFactory = LoggerFactory;\nLoggerFactory.instance = null;\n//# sourceMappingURL=Logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL3V0aWxzL0xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsbUJBQW1CLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSwrQkFBK0IsY0FBYyxHQUFHLG9CQUFvQixHQUFHLFlBQVksRUFBRSxRQUFRO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUM7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxjQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL2ZyYW1ld29yay91dGlscy9Mb2dnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBMb2dnaW5nIEFic3RyYWN0aW9uIGZvciB0aGUgSGV4YWdvbmFsIEZyYW1ld29ya1xuLy8gUHJvdmlkZXMgY29uc2lzdGVudCBsb2dnaW5nIGludGVyZmFjZSBhY3Jvc3MgYWxsIHNlcnZpY2VzIGFuZCBhZGFwdGVyc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dnZXJGYWN0b3J5ID0gZXhwb3J0cy5DaGlsZExvZ2dlciA9IGV4cG9ydHMuU3RydWN0dXJlZExvZ0hhbmRsZXIgPSBleHBvcnRzLkZpbGVMb2dIYW5kbGVyID0gZXhwb3J0cy5Db25zb2xlTG9nSGFuZGxlciA9IGV4cG9ydHMuRnJhbWV3b3JrTG9nZ2VyID0gdm9pZCAwO1xuY2xhc3MgRnJhbWV3b3JrTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihsZXZlbCA9ICdpbmZvJykge1xuICAgICAgICB0aGlzLmxvZ0hhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgLy8gQWRkIGNvbnNvbGUgaGFuZGxlciBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMuYWRkSGFuZGxlcihuZXcgQ29uc29sZUxvZ0hhbmRsZXIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxvZyBoYW5kbGVyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBMb2cgaGFuZGxlciB0byBhZGRcbiAgICAgKi9cbiAgICBhZGRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5sb2dIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsb2cgaGFuZGxlclxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gTG9nIGhhbmRsZXIgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5sb2dIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5sb2dIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWluaW11bSBsb2cgbGV2ZWxcbiAgICAgKiBAcGFyYW0gbGV2ZWwgLSBNaW5pbXVtIGxvZyBsZXZlbFxuICAgICAqL1xuICAgIHNldExldmVsKGxldmVsKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGxvZyBsZXZlbFxuICAgICAqIEByZXR1cm5zIEN1cnJlbnQgbG9nIGxldmVsXG4gICAgICovXG4gICAgZ2V0TGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gTG9nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBFcnJvciBvYmplY3RcbiAgICAgKi9cbiAgICBlcnJvcihtZXNzYWdlLCBjb250ZXh0LCBlcnJvcikge1xuICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBtZXNzYWdlLCBjb250ZXh0LCBlcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBhIHdhcm5pbmcgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gV2FybmluZyBtZXNzYWdlXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBMb2cgY29udGV4dFxuICAgICAqL1xuICAgIHdhcm4obWVzc2FnZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmxvZygnd2FybicsIG1lc3NhZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgYW4gaW5mbyBtZXNzYWdlXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmZvIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIExvZyBjb250ZXh0XG4gICAgICovXG4gICAgaW5mbyhtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubG9nKCdpbmZvJywgbWVzc2FnZSwgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBhIGRlYnVnIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIERlYnVnIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIExvZyBjb250ZXh0XG4gICAgICovXG4gICAgZGVidWcobWVzc2FnZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmxvZygnZGVidWcnLCBtZXNzYWdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbG9nIG1ldGhvZFxuICAgICAqIEBwYXJhbSBsZXZlbCAtIExvZyBsZXZlbFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gTG9nIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIExvZyBjb250ZXh0XG4gICAgICogQHBhcmFtIGVycm9yIC0gRXJyb3Igb2JqZWN0XG4gICAgICovXG4gICAgbG9nKGxldmVsLCBtZXNzYWdlLCBjb250ZXh0LCBlcnJvcikge1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkTG9nKGxldmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvZ0VudHJ5ID0ge1xuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5oYW5kbGUobG9nRW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IGxldCBoYW5kbGVyIGVycm9ycyBicmVhayBsb2dnaW5nXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTG9nZ2VyIGhhbmRsZXIgZXJyb3I6JywgaGFuZGxlckVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgbWVzc2FnZSBzaG91bGQgYmUgbG9nZ2VkIGJhc2VkIG9uIGN1cnJlbnQgbGV2ZWxcbiAgICAgKiBAcGFyYW0gbGV2ZWwgLSBNZXNzYWdlIGxldmVsXG4gICAgICogQHJldHVybnMgV2hldGhlciB0byBsb2cgdGhlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBzaG91bGRMb2cobGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGV2ZWxzID0ge1xuICAgICAgICAgICAgZXJyb3I6IDAsXG4gICAgICAgICAgICB3YXJuOiAxLFxuICAgICAgICAgICAgaW5mbzogMixcbiAgICAgICAgICAgIGRlYnVnOiAzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBsZXZlbHNbbGV2ZWxdIDw9IGxldmVsc1t0aGlzLmxldmVsXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2hpbGQgbG9nZ2VyIHdpdGggYWRkaXRpb25hbCBjb250ZXh0XG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBBZGRpdGlvbmFsIGNvbnRleHQgZm9yIGNoaWxkIGxvZ2dlclxuICAgICAqIEByZXR1cm5zIENoaWxkIGxvZ2dlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNoaWxkKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZExvZ2dlcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLkZyYW1ld29ya0xvZ2dlciA9IEZyYW1ld29ya0xvZ2dlcjtcbi8vIENvbnNvbGUgbG9nIGhhbmRsZXJcbmNsYXNzIENvbnNvbGVMb2dIYW5kbGVyIHtcbiAgICBoYW5kbGUoZW50cnkpIHtcbiAgICAgICAgY29uc3QgeyBsZXZlbCwgbWVzc2FnZSwgdGltZXN0YW1wLCBjb250ZXh0LCBlcnJvciB9ID0gZW50cnk7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcFN0ciA9IHRpbWVzdGFtcC50b0lTT1N0cmluZygpO1xuICAgICAgICBjb25zdCBjb250ZXh0U3RyID0gY29udGV4dCA/IGAgWyR7dGhpcy5mb3JtYXRDb250ZXh0KGNvbnRleHQpfV1gIDogJyc7XG4gICAgICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gYCR7dGltZXN0YW1wU3RyfSBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0ke2NvbnRleHRTdHJ9ICR7bWVzc2FnZX1gO1xuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihmdWxsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihmdWxsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbmZvJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oZnVsbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGVidWcnOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoZnVsbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcm1hdENvbnRleHQoY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBpZiAoY29udGV4dC5zZXJ2aWNlKVxuICAgICAgICAgICAgcGFydHMucHVzaChgc2VydmljZToke2NvbnRleHQuc2VydmljZX1gKTtcbiAgICAgICAgaWYgKGNvbnRleHQub3BlcmF0aW9uKVxuICAgICAgICAgICAgcGFydHMucHVzaChgb3A6JHtjb250ZXh0Lm9wZXJhdGlvbn1gKTtcbiAgICAgICAgaWYgKGNvbnRleHQudXNlcklkKVxuICAgICAgICAgICAgcGFydHMucHVzaChgdXNlcjoke2NvbnRleHQudXNlcklkfWApO1xuICAgICAgICBpZiAoY29udGV4dC5yZXF1ZXN0SWQpXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGByZXE6JHtjb250ZXh0LnJlcXVlc3RJZH1gKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJyAnKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnNvbGVMb2dIYW5kbGVyID0gQ29uc29sZUxvZ0hhbmRsZXI7XG4vLyBGaWxlIGxvZyBoYW5kbGVyIChmb3IgcHJvZHVjdGlvbiB1c2UpXG5jbGFzcyBGaWxlTG9nSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoZmlsZVBhdGgpIHtcbiAgICAgICAgdGhpcy5maWxlUGF0aCA9IGZpbGVQYXRoO1xuICAgIH1cbiAgICBoYW5kbGUoZW50cnkpIHtcbiAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgICBjb25zdCBsb2dMaW5lID0gSlNPTi5zdHJpbmdpZnkoZW50cnkpICsgJ1xcbic7XG4gICAgICAgIGZzLmFwcGVuZEZpbGVTeW5jKHRoaXMuZmlsZVBhdGgsIGxvZ0xpbmUsICd1dGY4Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlTG9nSGFuZGxlciA9IEZpbGVMb2dIYW5kbGVyO1xuLy8gU3RydWN0dXJlZCBsb2cgaGFuZGxlciAoZm9yIGV4dGVybmFsIGxvZ2dpbmcgc2VydmljZXMpXG5jbGFzcyBTdHJ1Y3R1cmVkTG9nSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2VuZExvZykge1xuICAgICAgICB0aGlzLnNlbmRMb2cgPSBzZW5kTG9nO1xuICAgIH1cbiAgICBoYW5kbGUoZW50cnkpIHtcbiAgICAgICAgdGhpcy5zZW5kTG9nKGVudHJ5KTtcbiAgICB9XG59XG5leHBvcnRzLlN0cnVjdHVyZWRMb2dIYW5kbGVyID0gU3RydWN0dXJlZExvZ0hhbmRsZXI7XG4vLyBDaGlsZCBsb2dnZXIgd2l0aCBpbmhlcml0ZWQgY29udGV4dFxuY2xhc3MgQ2hpbGRMb2dnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5pbmhlcml0ZWRDb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSwgY29udGV4dCwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuZXJyb3IobWVzc2FnZSwgdGhpcy5tZXJnZUNvbnRleHQoY29udGV4dCksIGVycm9yKTtcbiAgICB9XG4gICAgd2FybihtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGFyZW50Lndhcm4obWVzc2FnZSwgdGhpcy5tZXJnZUNvbnRleHQoY29udGV4dCkpO1xuICAgIH1cbiAgICBpbmZvKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5mbyhtZXNzYWdlLCB0aGlzLm1lcmdlQ29udGV4dChjb250ZXh0KSk7XG4gICAgfVxuICAgIGRlYnVnKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuZGVidWcobWVzc2FnZSwgdGhpcy5tZXJnZUNvbnRleHQoY29udGV4dCkpO1xuICAgIH1cbiAgICBzZXRMZXZlbChsZXZlbCkge1xuICAgICAgICB0aGlzLnBhcmVudC5zZXRMZXZlbChsZXZlbCk7XG4gICAgfVxuICAgIGdldExldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0TGV2ZWwoKTtcbiAgICB9XG4gICAgbWVyZ2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4udGhpcy5pbmhlcml0ZWRDb250ZXh0LCAuLi5jb250ZXh0IH07XG4gICAgfVxufVxuZXhwb3J0cy5DaGlsZExvZ2dlciA9IENoaWxkTG9nZ2VyO1xuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbG9nZ2Vyc1xuY2xhc3MgTG9nZ2VyRmFjdG9yeSB7XG4gICAgc3RhdGljIGNyZWF0ZShsZXZlbCA9ICdpbmZvJykge1xuICAgICAgICByZXR1cm4gbmV3IEZyYW1ld29ya0xvZ2dlcihsZXZlbCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaW5nbGV0b24obGV2ZWwgPSAnaW5mbycpIHtcbiAgICAgICAgaWYgKCFMb2dnZXJGYWN0b3J5Lmluc3RhbmNlKSB7XG4gICAgICAgICAgICBMb2dnZXJGYWN0b3J5Lmluc3RhbmNlID0gbmV3IEZyYW1ld29ya0xvZ2dlcihsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExvZ2dlckZhY3RvcnkuaW5zdGFuY2U7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVDaGlsZChwYXJlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZChjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2dlckZhY3RvcnkgPSBMb2dnZXJGYWN0b3J5O1xuTG9nZ2VyRmFjdG9yeS5pbnN0YW5jZSA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/Logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/index.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Utility functions for the hexagonal framework\n// Common helpers, error handling, logging, and other utilities\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./ErrorHandler */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/ErrorHandler.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Logger */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/Logger.js\"), exports);\n__exportStar(__webpack_require__(/*! ./HealthCheck */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/HealthCheck.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL3V0aWxzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxvR0FBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsOEdBQWU7QUFDcEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdWhvbWF0dGlsYS9Eb2N1bWVudHMvQWR2YW5jZSBub2RlLmpzIHByb2plY3RzL2h1YnNwb3Qtb25ib2FyZGluZy9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvZnJhbWV3b3JrL3V0aWxzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHRoZSBoZXhhZ29uYWwgZnJhbWV3b3JrXG4vLyBDb21tb24gaGVscGVycywgZXJyb3IgaGFuZGxpbmcsIGxvZ2dpbmcsIGFuZCBvdGhlciB1dGlsaXRpZXNcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0Vycm9ySGFuZGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTG9nZ2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9IZWFsdGhDaGVja1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/utils/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/src/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@juhomat/hexagonal-ai-framework/lib/src/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Main package exports for Hexagonal AI Framework\n// This is the entry point for npm package consumers\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ApplicationFramework = void 0;\n// Export everything from the framework\n__exportStar(__webpack_require__(/*! ../framework */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/index.js\"), exports);\n// Explicitly export the main ApplicationFramework class for convenience\nvar ApplicationFramework_1 = __webpack_require__(/*! ../framework/sdk/ApplicationFramework */ \"(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/framework/sdk/ApplicationFramework.js\");\nObject.defineProperty(exports, \"ApplicationFramework\", ({ enumerable: true, get: function () { return ApplicationFramework_1.ApplicationFramework; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGp1aG9tYXQvaGV4YWdvbmFsLWFpLWZyYW1ld29yay9saWIvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUI7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUdBQWM7QUFDbkM7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyw2SUFBdUM7QUFDNUUsd0RBQXVELEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQ3RKIiwic291cmNlcyI6WyIvVXNlcnMvanVob21hdHRpbGEvRG9jdW1lbnRzL0FkdmFuY2Ugbm9kZS5qcyBwcm9qZWN0cy9odWJzcG90LW9uYm9hcmRpbmcvbm9kZV9tb2R1bGVzL0BqdWhvbWF0L2hleGFnb25hbC1haS1mcmFtZXdvcmsvbGliL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIE1haW4gcGFja2FnZSBleHBvcnRzIGZvciBIZXhhZ29uYWwgQUkgRnJhbWV3b3JrXG4vLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgbnBtIHBhY2thZ2UgY29uc3VtZXJzXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBwbGljYXRpb25GcmFtZXdvcmsgPSB2b2lkIDA7XG4vLyBFeHBvcnQgZXZlcnl0aGluZyBmcm9tIHRoZSBmcmFtZXdvcmtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi4vZnJhbWV3b3JrXCIpLCBleHBvcnRzKTtcbi8vIEV4cGxpY2l0bHkgZXhwb3J0IHRoZSBtYWluIEFwcGxpY2F0aW9uRnJhbWV3b3JrIGNsYXNzIGZvciBjb252ZW5pZW5jZVxudmFyIEFwcGxpY2F0aW9uRnJhbWV3b3JrXzEgPSByZXF1aXJlKFwiLi4vZnJhbWV3b3JrL3Nkay9BcHBsaWNhdGlvbkZyYW1ld29ya1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwcGxpY2F0aW9uRnJhbWV3b3JrXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBcHBsaWNhdGlvbkZyYW1ld29ya18xLkFwcGxpY2F0aW9uRnJhbWV3b3JrOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@juhomat/hexagonal-ai-framework/lib/src/index.js\n");

/***/ })

};
;